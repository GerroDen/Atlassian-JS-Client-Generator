/* tslint:disable */
/* eslint-disable */
/**
 * The Confluence Cloud REST API v2
 * This document describes Confluence\'s v2 APIs. This is intended to be an iteration on the existing Confluence Cloud REST API with improvements in both endpoint definitions and performance.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CommentSortOrder,
  CreateFooterComment201Response,
  CreateFooterCommentModel,
  CreateInlineComment201Response,
  CreateInlineCommentModel,
  FooterCommentModel,
  MultiEntityResultAttachmentCommentModel,
  MultiEntityResultBlogPostCommentModel,
  MultiEntityResultBlogPostInlineCommentModel,
  MultiEntityResultChildrenCommentModel,
  MultiEntityResultCustomContentCommentModel,
  MultiEntityResultFooterCommentModel,
  MultiEntityResultInlineCommentChildrenModel,
  MultiEntityResultInlineCommentModel,
  MultiEntityResultPageCommentModel,
  MultiEntityResultPageInlineCommentModel,
  PrimaryBodyRepresentation,
  PrimaryBodyRepresentationSingle,
  UpdateFooterCommentRequest,
  UpdateInlineCommentModel,
} from '../models/index';

export interface CreateFooterCommentRequest {
    createFooterCommentModel: CreateFooterCommentModel;
}

export interface CreateInlineCommentRequest {
    createInlineCommentModel: CreateInlineCommentModel;
}

export interface DeleteFooterCommentRequest {
    commentId: number;
}

export interface DeleteInlineCommentRequest {
    commentId: number;
}

export interface GetAttachmentCommentsRequest {
    id: string;
    bodyFormat?: PrimaryBodyRepresentation;
    cursor?: string;
    limit?: number;
    sort?: CommentSortOrder;
    version?: number;
}

export interface GetBlogPostFooterCommentsRequest {
    id: number;
    bodyFormat?: PrimaryBodyRepresentation;
    status?: Array<GetBlogPostFooterCommentsStatusEnum>;
    sort?: CommentSortOrder;
    cursor?: string;
    limit?: number;
}

export interface GetBlogPostInlineCommentsRequest {
    id: number;
    bodyFormat?: PrimaryBodyRepresentation;
    status?: Array<GetBlogPostInlineCommentsStatusEnum>;
    resolutionStatus?: Array<GetBlogPostInlineCommentsResolutionStatusEnum>;
    sort?: CommentSortOrder;
    cursor?: string;
    limit?: number;
}

export interface GetCustomContentCommentsRequest {
    id: number;
    bodyFormat?: PrimaryBodyRepresentation;
    cursor?: string;
    limit?: number;
    sort?: CommentSortOrder;
}

export interface GetFooterCommentByIdRequest {
    commentId: number;
    bodyFormat?: PrimaryBodyRepresentationSingle;
    version?: number;
    includeProperties?: boolean;
    includeOperations?: boolean;
    includeLikes?: boolean;
    includeVersions?: boolean;
    includeVersion?: boolean;
}

export interface GetFooterCommentChildrenRequest {
    id: number;
    bodyFormat?: PrimaryBodyRepresentation;
    sort?: CommentSortOrder;
    cursor?: string;
    limit?: number;
}

export interface GetFooterCommentsRequest {
    bodyFormat?: PrimaryBodyRepresentation;
    sort?: CommentSortOrder;
    cursor?: string;
    limit?: number;
}

export interface GetInlineCommentByIdRequest {
    commentId: number;
    bodyFormat?: PrimaryBodyRepresentationSingle;
    version?: number;
    includeProperties?: boolean;
    includeOperations?: boolean;
    includeLikes?: boolean;
    includeVersions?: boolean;
    includeVersion?: boolean;
}

export interface GetInlineCommentChildrenRequest {
    id: number;
    bodyFormat?: PrimaryBodyRepresentation;
    sort?: CommentSortOrder;
    cursor?: string;
    limit?: number;
}

export interface GetInlineCommentsRequest {
    bodyFormat?: PrimaryBodyRepresentation;
    sort?: CommentSortOrder;
    cursor?: string;
    limit?: number;
}

export interface GetPageFooterCommentsRequest {
    id: number;
    bodyFormat?: PrimaryBodyRepresentation;
    status?: Array<GetPageFooterCommentsStatusEnum>;
    sort?: CommentSortOrder;
    cursor?: string;
    limit?: number;
}

export interface GetPageInlineCommentsRequest {
    id: number;
    bodyFormat?: PrimaryBodyRepresentation;
    status?: Array<GetPageInlineCommentsStatusEnum>;
    resolutionStatus?: Array<GetPageInlineCommentsResolutionStatusEnum>;
    sort?: CommentSortOrder;
    cursor?: string;
    limit?: number;
}

export interface UpdateFooterCommentOperationRequest {
    commentId: number;
    updateFooterCommentRequest: UpdateFooterCommentRequest;
}

export interface UpdateInlineCommentRequest {
    commentId: number;
    updateInlineCommentModel: UpdateInlineCommentModel;
}

/**
 * 
 */
export class CommentApi extends runtime.BaseAPI {

    /**
     * Create a footer comment.  The footer comment can be made against several locations:  - at the top level (specifying pageId or blogPostId in the request body) - as a reply (specifying parentCommentId in the request body) - against an attachment (note: this is different than the comments added via the attachment properties page on the UI, which are referred to as version comments) - against a custom content  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
     * Create footer comment
     */
    async createFooterCommentRaw(requestParameters: CreateFooterCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateFooterComment201Response>> {
        if (requestParameters['createFooterCommentModel'] == null) {
            throw new runtime.RequiredError(
                'createFooterCommentModel',
                'Required parameter "createFooterCommentModel" was null or undefined when calling createFooterComment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["write:comment:confluence"]);
        }

        const response = await this.request({
            path: `/footer-comments`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['createFooterCommentModel'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a footer comment.  The footer comment can be made against several locations:  - at the top level (specifying pageId or blogPostId in the request body) - as a reply (specifying parentCommentId in the request body) - against an attachment (note: this is different than the comments added via the attachment properties page on the UI, which are referred to as version comments) - against a custom content  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
     * Create footer comment
     */
    async createFooterComment(requestParameters: CreateFooterCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateFooterComment201Response> {
        const response = await this.createFooterCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an inline comment. This can be at the top level (specifying pageId or blogPostId in the request body) or as a reply (specifying parentCommentId in the request body). Note the inlineCommentProperties object in the request body is used to select the text the inline comment should be tied to. This is what determines the text  highlighting when viewing a page in Confluence.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
     * Create inline comment
     */
    async createInlineCommentRaw(requestParameters: CreateInlineCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateInlineComment201Response>> {
        if (requestParameters['createInlineCommentModel'] == null) {
            throw new runtime.RequiredError(
                'createInlineCommentModel',
                'Required parameter "createInlineCommentModel" was null or undefined when calling createInlineComment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["write:comment:confluence"]);
        }

        const response = await this.request({
            path: `/inline-comments`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['createInlineCommentModel'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create an inline comment. This can be at the top level (specifying pageId or blogPostId in the request body) or as a reply (specifying parentCommentId in the request body). Note the inlineCommentProperties object in the request body is used to select the text the inline comment should be tied to. This is what determines the text  highlighting when viewing a page in Confluence.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
     * Create inline comment
     */
    async createInlineComment(requestParameters: CreateInlineCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateInlineComment201Response> {
        const response = await this.createInlineCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes a footer comment. This is a permanent deletion and cannot be reverted.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to delete comments in the space.
     * Delete footer comment
     */
    async deleteFooterCommentRaw(requestParameters: DeleteFooterCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling deleteFooterComment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["delete:comment:confluence"]);
        }

        const response = await this.request({
            path: `/footer-comments/{comment-id}`.replace(`{${"comment-id"}}`, encodeURIComponent(String(requestParameters['commentId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a footer comment. This is a permanent deletion and cannot be reverted.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to delete comments in the space.
     * Delete footer comment
     */
    async deleteFooterComment(requestParameters: DeleteFooterCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteFooterCommentRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes an inline comment. This is a permanent deletion and cannot be reverted.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to delete comments in the space.
     * Delete inline comment
     */
    async deleteInlineCommentRaw(requestParameters: DeleteInlineCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling deleteInlineComment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["delete:comment:confluence"]);
        }

        const response = await this.request({
            path: `/inline-comments/{comment-id}`.replace(`{${"comment-id"}}`, encodeURIComponent(String(requestParameters['commentId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes an inline comment. This is a permanent deletion and cannot be reverted.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to delete comments in the space.
     * Delete inline comment
     */
    async deleteInlineComment(requestParameters: DeleteInlineCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteInlineCommentRaw(requestParameters, initOverrides);
    }

    /**
     * Returns the comments of the specific attachment. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the attachment and its corresponding containers.
     * Get attachment comments
     */
    async getAttachmentCommentsRaw(requestParameters: GetAttachmentCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MultiEntityResultAttachmentCommentModel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getAttachmentComments().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['bodyFormat'] != null) {
            queryParameters['body-format'] = requestParameters['bodyFormat'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:comment:confluence"]);
        }

        const response = await this.request({
            path: `/attachments/{id}/footer-comments`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the comments of the specific attachment. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the attachment and its corresponding containers.
     * Get attachment comments
     */
    async getAttachmentComments(requestParameters: GetAttachmentCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MultiEntityResultAttachmentCommentModel> {
        const response = await this.getAttachmentCommentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the root footer comments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the blog post and its corresponding space.
     * Get footer comments for blog post
     */
    async getBlogPostFooterCommentsRaw(requestParameters: GetBlogPostFooterCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MultiEntityResultBlogPostCommentModel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getBlogPostFooterComments().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['bodyFormat'] != null) {
            queryParameters['body-format'] = requestParameters['bodyFormat'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:comment:confluence"]);
        }

        const response = await this.request({
            path: `/blogposts/{id}/footer-comments`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the root footer comments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the blog post and its corresponding space.
     * Get footer comments for blog post
     */
    async getBlogPostFooterComments(requestParameters: GetBlogPostFooterCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MultiEntityResultBlogPostCommentModel> {
        const response = await this.getBlogPostFooterCommentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the root inline comments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the blog post and its corresponding space.
     * Get inline comments for blog post
     */
    async getBlogPostInlineCommentsRaw(requestParameters: GetBlogPostInlineCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MultiEntityResultBlogPostInlineCommentModel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getBlogPostInlineComments().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['bodyFormat'] != null) {
            queryParameters['body-format'] = requestParameters['bodyFormat'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['resolutionStatus'] != null) {
            queryParameters['resolution-status'] = requestParameters['resolutionStatus'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:comment:confluence"]);
        }

        const response = await this.request({
            path: `/blogposts/{id}/inline-comments`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the root inline comments of specific blog post. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the blog post and its corresponding space.
     * Get inline comments for blog post
     */
    async getBlogPostInlineComments(requestParameters: GetBlogPostInlineCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MultiEntityResultBlogPostInlineCommentModel> {
        const response = await this.getBlogPostInlineCommentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the comments of the specific custom content. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the custom content and its corresponding containers.
     * Get custom content comments
     */
    async getCustomContentCommentsRaw(requestParameters: GetCustomContentCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MultiEntityResultCustomContentCommentModel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getCustomContentComments().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['bodyFormat'] != null) {
            queryParameters['body-format'] = requestParameters['bodyFormat'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:comment:confluence"]);
        }

        const response = await this.request({
            path: `/custom-content/{id}/footer-comments`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the comments of the specific custom content. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the custom content and its corresponding containers.
     * Get custom content comments
     */
    async getCustomContentComments(requestParameters: GetCustomContentCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MultiEntityResultCustomContentCommentModel> {
        const response = await this.getCustomContentCommentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a footer comment by id  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the container and its corresponding space.
     * Get footer comment by id
     */
    async getFooterCommentByIdRaw(requestParameters: GetFooterCommentByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateFooterComment201Response>> {
        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling getFooterCommentById().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['bodyFormat'] != null) {
            queryParameters['body-format'] = requestParameters['bodyFormat'];
        }

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        if (requestParameters['includeProperties'] != null) {
            queryParameters['include-properties'] = requestParameters['includeProperties'];
        }

        if (requestParameters['includeOperations'] != null) {
            queryParameters['include-operations'] = requestParameters['includeOperations'];
        }

        if (requestParameters['includeLikes'] != null) {
            queryParameters['include-likes'] = requestParameters['includeLikes'];
        }

        if (requestParameters['includeVersions'] != null) {
            queryParameters['include-versions'] = requestParameters['includeVersions'];
        }

        if (requestParameters['includeVersion'] != null) {
            queryParameters['include-version'] = requestParameters['includeVersion'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:comment:confluence"]);
        }

        const response = await this.request({
            path: `/footer-comments/{comment-id}`.replace(`{${"comment-id"}}`, encodeURIComponent(String(requestParameters['commentId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves a footer comment by id  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the container and its corresponding space.
     * Get footer comment by id
     */
    async getFooterCommentById(requestParameters: GetFooterCommentByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateFooterComment201Response> {
        const response = await this.getFooterCommentByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the children footer comments of specific comment. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page and its corresponding space.
     * Get children footer comments
     */
    async getFooterCommentChildrenRaw(requestParameters: GetFooterCommentChildrenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MultiEntityResultChildrenCommentModel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getFooterCommentChildren().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['bodyFormat'] != null) {
            queryParameters['body-format'] = requestParameters['bodyFormat'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:comment:confluence"]);
        }

        const response = await this.request({
            path: `/footer-comments/{id}/children`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the children footer comments of specific comment. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page and its corresponding space.
     * Get children footer comments
     */
    async getFooterCommentChildren(requestParameters: GetFooterCommentChildrenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MultiEntityResultChildrenCommentModel> {
        const response = await this.getFooterCommentChildrenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all footer comments. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the container and its corresponding space.
     * Get footer comments
     */
    async getFooterCommentsRaw(requestParameters: GetFooterCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MultiEntityResultFooterCommentModel>> {
        const queryParameters: any = {};

        if (requestParameters['bodyFormat'] != null) {
            queryParameters['body-format'] = requestParameters['bodyFormat'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:comment:confluence"]);
        }

        const response = await this.request({
            path: `/footer-comments`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns all footer comments. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the container and its corresponding space.
     * Get footer comments
     */
    async getFooterComments(requestParameters: GetFooterCommentsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MultiEntityResultFooterCommentModel> {
        const response = await this.getFooterCommentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves an inline comment by id  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space.
     * Get inline comment by id
     */
    async getInlineCommentByIdRaw(requestParameters: GetInlineCommentByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateInlineComment201Response>> {
        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling getInlineCommentById().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['bodyFormat'] != null) {
            queryParameters['body-format'] = requestParameters['bodyFormat'];
        }

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        if (requestParameters['includeProperties'] != null) {
            queryParameters['include-properties'] = requestParameters['includeProperties'];
        }

        if (requestParameters['includeOperations'] != null) {
            queryParameters['include-operations'] = requestParameters['includeOperations'];
        }

        if (requestParameters['includeLikes'] != null) {
            queryParameters['include-likes'] = requestParameters['includeLikes'];
        }

        if (requestParameters['includeVersions'] != null) {
            queryParameters['include-versions'] = requestParameters['includeVersions'];
        }

        if (requestParameters['includeVersion'] != null) {
            queryParameters['include-version'] = requestParameters['includeVersion'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:comment:confluence"]);
        }

        const response = await this.request({
            path: `/inline-comments/{comment-id}`.replace(`{${"comment-id"}}`, encodeURIComponent(String(requestParameters['commentId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves an inline comment by id  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space.
     * Get inline comment by id
     */
    async getInlineCommentById(requestParameters: GetInlineCommentByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateInlineComment201Response> {
        const response = await this.getInlineCommentByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the children inline comments of specific comment. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page and its corresponding space.
     * Get children inline comments
     */
    async getInlineCommentChildrenRaw(requestParameters: GetInlineCommentChildrenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MultiEntityResultInlineCommentChildrenModel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getInlineCommentChildren().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['bodyFormat'] != null) {
            queryParameters['body-format'] = requestParameters['bodyFormat'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:comment:confluence"]);
        }

        const response = await this.request({
            path: `/inline-comments/{id}/children`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the children inline comments of specific comment. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page and its corresponding space.
     * Get children inline comments
     */
    async getInlineCommentChildren(requestParameters: GetInlineCommentChildrenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MultiEntityResultInlineCommentChildrenModel> {
        const response = await this.getInlineCommentChildrenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all inline comments. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page and its corresponding space.
     * Get inline comments
     */
    async getInlineCommentsRaw(requestParameters: GetInlineCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MultiEntityResultInlineCommentModel>> {
        const queryParameters: any = {};

        if (requestParameters['bodyFormat'] != null) {
            queryParameters['body-format'] = requestParameters['bodyFormat'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:comment:confluence"]);
        }

        const response = await this.request({
            path: `/inline-comments`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns all inline comments. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page and its corresponding space.
     * Get inline comments
     */
    async getInlineComments(requestParameters: GetInlineCommentsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MultiEntityResultInlineCommentModel> {
        const response = await this.getInlineCommentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the root footer comments of specific page. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page and its corresponding space.
     * Get footer comments for page
     */
    async getPageFooterCommentsRaw(requestParameters: GetPageFooterCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MultiEntityResultPageCommentModel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getPageFooterComments().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['bodyFormat'] != null) {
            queryParameters['body-format'] = requestParameters['bodyFormat'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:comment:confluence"]);
        }

        const response = await this.request({
            path: `/pages/{id}/footer-comments`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the root footer comments of specific page. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page and its corresponding space.
     * Get footer comments for page
     */
    async getPageFooterComments(requestParameters: GetPageFooterCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MultiEntityResultPageCommentModel> {
        const response = await this.getPageFooterCommentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the root inline comments of specific page. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page and its corresponding space.
     * Get inline comments for page
     */
    async getPageInlineCommentsRaw(requestParameters: GetPageInlineCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MultiEntityResultPageInlineCommentModel>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getPageInlineComments().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['bodyFormat'] != null) {
            queryParameters['body-format'] = requestParameters['bodyFormat'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['resolutionStatus'] != null) {
            queryParameters['resolution-status'] = requestParameters['resolutionStatus'];
        }

        if (requestParameters['sort'] != null) {
            queryParameters['sort'] = requestParameters['sort'];
        }

        if (requestParameters['cursor'] != null) {
            queryParameters['cursor'] = requestParameters['cursor'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:comment:confluence"]);
        }

        const response = await this.request({
            path: `/pages/{id}/inline-comments`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the root inline comments of specific page. The number of results is limited by the `limit` parameter and additional results (if available) will be available through the `next` URL present in the `Link` response header.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page and its corresponding space.
     * Get inline comments for page
     */
    async getPageInlineComments(requestParameters: GetPageInlineCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MultiEntityResultPageInlineCommentModel> {
        const response = await this.getPageInlineCommentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update a footer comment. This can be used to update the body text of a comment.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
     * Update footer comment
     */
    async updateFooterCommentRaw(requestParameters: UpdateFooterCommentOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FooterCommentModel>> {
        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling updateFooterComment().'
            );
        }

        if (requestParameters['updateFooterCommentRequest'] == null) {
            throw new runtime.RequiredError(
                'updateFooterCommentRequest',
                'Required parameter "updateFooterCommentRequest" was null or undefined when calling updateFooterComment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["write:comment:confluence"]);
        }

        const response = await this.request({
            path: `/footer-comments/{comment-id}`.replace(`{${"comment-id"}}`, encodeURIComponent(String(requestParameters['commentId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['updateFooterCommentRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update a footer comment. This can be used to update the body text of a comment.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
     * Update footer comment
     */
    async updateFooterComment(requestParameters: UpdateFooterCommentOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FooterCommentModel> {
        const response = await this.updateFooterCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update an inline comment. This can be used to update the body text of a comment and/or to resolve the comment  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
     * Update inline comment
     */
    async updateInlineCommentRaw(requestParameters: UpdateInlineCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CreateInlineComment201Response>> {
        if (requestParameters['commentId'] == null) {
            throw new runtime.RequiredError(
                'commentId',
                'Required parameter "commentId" was null or undefined when calling updateInlineComment().'
            );
        }

        if (requestParameters['updateInlineCommentModel'] == null) {
            throw new runtime.RequiredError(
                'updateInlineCommentModel',
                'Required parameter "updateInlineCommentModel" was null or undefined when calling updateInlineComment().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["write:comment:confluence"]);
        }

        const response = await this.request({
            path: `/inline-comments/{comment-id}`.replace(`{${"comment-id"}}`, encodeURIComponent(String(requestParameters['commentId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['updateInlineCommentModel'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update an inline comment. This can be used to update the body text of a comment and/or to resolve the comment  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content of the page or blogpost and its corresponding space. Permission to create comments in the space.
     * Update inline comment
     */
    async updateInlineComment(requestParameters: UpdateInlineCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CreateInlineComment201Response> {
        const response = await this.updateInlineCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetBlogPostFooterCommentsStatusEnum = {
    Current: 'current',
    Deleted: 'deleted',
    Trashed: 'trashed',
    Historical: 'historical',
    Draft: 'draft'
} as const;
export type GetBlogPostFooterCommentsStatusEnum = typeof GetBlogPostFooterCommentsStatusEnum[keyof typeof GetBlogPostFooterCommentsStatusEnum];
/**
 * @export
 */
export const GetBlogPostInlineCommentsStatusEnum = {
    Current: 'current',
    Deleted: 'deleted',
    Trashed: 'trashed',
    Historical: 'historical',
    Draft: 'draft'
} as const;
export type GetBlogPostInlineCommentsStatusEnum = typeof GetBlogPostInlineCommentsStatusEnum[keyof typeof GetBlogPostInlineCommentsStatusEnum];
/**
 * @export
 */
export const GetBlogPostInlineCommentsResolutionStatusEnum = {
    Resolved: 'resolved',
    Open: 'open',
    Dangling: 'dangling',
    Reopened: 'reopened'
} as const;
export type GetBlogPostInlineCommentsResolutionStatusEnum = typeof GetBlogPostInlineCommentsResolutionStatusEnum[keyof typeof GetBlogPostInlineCommentsResolutionStatusEnum];
/**
 * @export
 */
export const GetPageFooterCommentsStatusEnum = {
    Current: 'current',
    Archived: 'archived',
    Trashed: 'trashed',
    Deleted: 'deleted',
    Historical: 'historical',
    Draft: 'draft'
} as const;
export type GetPageFooterCommentsStatusEnum = typeof GetPageFooterCommentsStatusEnum[keyof typeof GetPageFooterCommentsStatusEnum];
/**
 * @export
 */
export const GetPageInlineCommentsStatusEnum = {
    Current: 'current',
    Archived: 'archived',
    Trashed: 'trashed',
    Deleted: 'deleted',
    Historical: 'historical',
    Draft: 'draft'
} as const;
export type GetPageInlineCommentsStatusEnum = typeof GetPageInlineCommentsStatusEnum[keyof typeof GetPageInlineCommentsStatusEnum];
/**
 * @export
 */
export const GetPageInlineCommentsResolutionStatusEnum = {
    Resolved: 'resolved',
    Open: 'open',
    Dangling: 'dangling',
    Reopened: 'reopened'
} as const;
export type GetPageInlineCommentsResolutionStatusEnum = typeof GetPageInlineCommentsResolutionStatusEnum[keyof typeof GetPageInlineCommentsResolutionStatusEnum];
