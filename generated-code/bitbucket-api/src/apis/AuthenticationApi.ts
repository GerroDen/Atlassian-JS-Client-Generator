/* tslint:disable */
/* eslint-disable */
/**
 * Bitbucket Data Center
 * This is the reference document for the Atlassian Bitbucket REST API. The REST API is for developers who want to:    - integrate Bitbucket with other applications;   - create scripts that interact with Bitbucket; or   - develop plugins that enhance the Bitbucket UI, using REST to interact with the backend.    You can read more about developing Bitbucket plugins in the [Bitbucket Developer Documentation](https://developer.atlassian.com/bitbucket/server/docs/latest/).
 *
 * The version of the OpenAPI document: 9.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AddSshKeyRequest,
  GetAllAccessTokens200Response,
  GetAllAccessTokens401Response,
  GetForRepository1200Response,
  GetSshKeys200Response,
  RestAccessToken,
  RestAccessTokenRequest,
  RestRawAccessToken,
  RestSshAccessKey,
  RestSshKey,
  RestSshSettings,
  RevokeManyRequest,
} from '../models/index';

interface AddForProjectRequest {
    projectKey: string;
    restSshAccessKey?: RestSshAccessKey;
}

interface AddForRepositoryRequest {
    projectKey: string;
    repositorySlug: string;
    restSshAccessKey?: RestSshAccessKey;
}

interface AddSshKeyOperationRequest {
    user?: Omit<RestSshKey, 'createdDate'|'fingerprint'|'id'|'lastAuthenticated'>;
    addSshKeyRequest?: Omit<AddSshKeyRequest, 'createdDate'|'fingerprint'|'id'|'lastAuthenticated'>;
}

interface CreateAccessTokenRequest {
    projectKey: string;
    restAccessTokenRequest?: RestAccessTokenRequest;
}

interface CreateAccessToken1Request {
    projectKey: string;
    repositorySlug: string;
    restAccessTokenRequest?: RestAccessTokenRequest;
}

interface CreateAccessToken2Request {
    userSlug: string;
    restAccessTokenRequest?: RestAccessTokenRequest;
}

interface DeleteByIdRequest {
    projectKey: string;
    tokenId: string;
}

interface DeleteById1Request {
    projectKey: string;
    tokenId: string;
    repositorySlug: string;
}

interface DeleteById2Request {
    tokenId: string;
    userSlug: string;
}

interface DeleteSshKeyRequest {
    keyId: string;
}

interface DeleteSshKeysRequest {
    userName?: string;
    user?: string;
}

interface GetAllAccessTokensRequest {
    projectKey: string;
    start?: number;
    limit?: number;
}

interface GetAllAccessTokens1Request {
    projectKey: string;
    repositorySlug: string;
    start?: number;
    limit?: number;
}

interface GetAllAccessTokens2Request {
    userSlug: string;
    start?: number;
    limit?: number;
}

interface GetByIdRequest {
    projectKey: string;
    tokenId: string;
}

interface GetById1Request {
    projectKey: string;
    tokenId: string;
    repositorySlug: string;
}

interface GetById2Request {
    tokenId: string;
    userSlug: string;
}

interface GetForProjectRequest {
    projectKey: string;
    keyId: string;
}

interface GetForProjectsRequest {
    keyId: number;
}

interface GetForRepositoriesRequest {
    keyId: string;
    withRestrictions?: string;
}

interface GetForRepositoryRequest {
    projectKey: string;
    keyId: string;
    repositorySlug: string;
}

interface GetForRepository1Request {
    projectKey: string;
    repositorySlug: string;
    filter?: string;
    effective?: string;
    minimumPermission?: string;
    permission?: string;
    start?: number;
    limit?: number;
}

interface GetSshKeyRequest {
    keyId: string;
}

interface GetSshKeysRequest {
    userName?: string;
    user?: string;
    start?: number;
    limit?: number;
}

interface GetSshKeysForProjectRequest {
    projectKey: string;
    filter?: string;
    permission?: string;
    start?: number;
    limit?: number;
}

interface RevokeForProjectRequest {
    projectKey: string;
    keyId: string;
}

interface RevokeForRepositoryRequest {
    projectKey: string;
    keyId: string;
    repositorySlug: string;
}

interface RevokeManyOperationRequest {
    keyId: string;
    revokeManyRequest?: RevokeManyRequest;
}

interface UpdateAccessTokenRequest {
    projectKey: string;
    tokenId: string;
    restAccessTokenRequest?: RestAccessTokenRequest;
}

interface UpdateAccessToken1Request {
    projectKey: string;
    tokenId: string;
    repositorySlug: string;
    restAccessTokenRequest?: RestAccessTokenRequest;
}

interface UpdateAccessToken2Request {
    tokenId: string;
    userSlug: string;
    restAccessTokenRequest?: RestAccessTokenRequest;
}

interface UpdatePermissionRequest {
    projectKey: string;
    keyId: string;
    permission: string;
}

interface UpdatePermission1Request {
    projectKey: string;
    keyId: string;
    permission: string;
    repositorySlug: string;
}

/**
 * 
 */
export class AuthenticationApi extends runtime.BaseAPI {

    /**
     * Register a new SSH key and grants access to the project identified in the URL.
     * Add project SSH key
     */
    async addForProjectRaw(requestParameters: AddForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshAccessKey>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling addForProject().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/ssh`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restSshAccessKey'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Register a new SSH key and grants access to the project identified in the URL.
     * Add project SSH key
     */
    async addForProject(requestParameters: AddForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshAccessKey> {
        const response = await this.addForProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Register a new SSH key and grants access to the repository identified in the URL.
     * Add repository SSH key
     */
    async addForRepositoryRaw(requestParameters: AddForRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshAccessKey>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling addForRepository().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling addForRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/repos/{repositorySlug}/ssh`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restSshAccessKey'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Register a new SSH key and grants access to the repository identified in the URL.
     * Add repository SSH key
     */
    async addForRepository(requestParameters: AddForRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshAccessKey> {
        const response = await this.addForRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a new SSH key to a supplied user.
     * Add SSH key for user
     */
    async addSshKeyRaw(requestParameters: AddSshKeyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshKey>> {
        const queryParameters: any = {};

        if (requestParameters['user'] != null) {
            queryParameters['user'] = requestParameters['user'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/ssh/latest/keys`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['addSshKeyRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Add a new SSH key to a supplied user.
     * Add SSH key for user
     */
    async addSshKey(requestParameters: AddSshKeyOperationRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshKey> {
        const response = await this.addSshKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an access token for the project according to the given request.
     * Create project HTTP token
     */
    async createAccessTokenRaw(requestParameters: CreateAccessTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRawAccessToken>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createAccessToken().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAccessTokenRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create an access token for the project according to the given request.
     * Create project HTTP token
     */
    async createAccessToken(requestParameters: CreateAccessTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRawAccessToken> {
        const response = await this.createAccessTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an access token for the repository according to the given request.
     * Create repository HTTP token
     */
    async createAccessToken1Raw(requestParameters: CreateAccessToken1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRawAccessToken>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling createAccessToken1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling createAccessToken1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/repos/{repositorySlug}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAccessTokenRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create an access token for the repository according to the given request.
     * Create repository HTTP token
     */
    async createAccessToken1(requestParameters: CreateAccessToken1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRawAccessToken> {
        const response = await this.createAccessToken1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create an access token for the user according to the given request.
     * Create personal HTTP token
     */
    async createAccessToken2Raw(requestParameters: CreateAccessToken2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRawAccessToken>> {
        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling createAccessToken2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/access-tokens/latest/users/{userSlug}`.replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAccessTokenRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create an access token for the user according to the given request.
     * Create personal HTTP token
     */
    async createAccessToken2(requestParameters: CreateAccessToken2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRawAccessToken> {
        const response = await this.createAccessToken2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete the access token identified by the given ID.
     * Delete a HTTP token
     */
    async deleteByIdRaw(requestParameters: DeleteByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteById().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling deleteById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/{tokenId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the access token identified by the given ID.
     * Delete a HTTP token
     */
    async deleteById(requestParameters: DeleteByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteByIdRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the access token identified by the given ID.
     * Delete a HTTP token
     */
    async deleteById1Raw(requestParameters: DeleteById1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling deleteById1().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling deleteById1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling deleteById1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/repos/{repositorySlug}/{tokenId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the access token identified by the given ID.
     * Delete a HTTP token
     */
    async deleteById1(requestParameters: DeleteById1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteById1Raw(requestParameters, initOverrides);
    }

    /**
     * Delete the access token identified by the given ID.
     * Delete a HTTP token
     */
    async deleteById2Raw(requestParameters: DeleteById2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling deleteById2().'
            );
        }

        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling deleteById2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/users/{userSlug}/{tokenId}`.replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))).replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the access token identified by the given ID.
     * Delete a HTTP token
     */
    async deleteById2(requestParameters: DeleteById2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteById2Raw(requestParameters, initOverrides);
    }

    /**
     * Delete an SSH key.  The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     * Remove SSH key
     */
    async deleteSshKeyRaw(requestParameters: DeleteSshKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling deleteSshKey().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ssh/latest/keys/{keyId}`.replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an SSH key.  The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     * Remove SSH key
     */
    async deleteSshKey(requestParameters: DeleteSshKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteSshKeyRaw(requestParameters, initOverrides);
    }

    /**
     * Delete all SSH keys for a supplied user.
     * Delete all user SSH key
     */
    async deleteSshKeysRaw(requestParameters: DeleteSshKeysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters['userName'] != null) {
            queryParameters['userName'] = requestParameters['userName'];
        }

        if (requestParameters['user'] != null) {
            queryParameters['user'] = requestParameters['user'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ssh/latest/keys`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete all SSH keys for a supplied user.
     * Delete all user SSH key
     */
    async deleteSshKeys(requestParameters: DeleteSshKeysRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteSshKeysRaw(requestParameters, initOverrides);
    }

    /**
     * Get all access tokens associated with the given project.
     * Get project HTTP tokens
     */
    async getAllAccessTokensRaw(requestParameters: GetAllAccessTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAllAccessTokens200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getAllAccessTokens().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get all access tokens associated with the given project.
     * Get project HTTP tokens
     */
    async getAllAccessTokens(requestParameters: GetAllAccessTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAllAccessTokens200Response> {
        const response = await this.getAllAccessTokensRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all access tokens associated with the given repository.
     * Get repository HTTP tokens
     */
    async getAllAccessTokens1Raw(requestParameters: GetAllAccessTokens1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAllAccessTokens200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getAllAccessTokens1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getAllAccessTokens1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/repos/{repositorySlug}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get all access tokens associated with the given repository.
     * Get repository HTTP tokens
     */
    async getAllAccessTokens1(requestParameters: GetAllAccessTokens1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAllAccessTokens200Response> {
        const response = await this.getAllAccessTokens1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all access tokens associated with the given user.
     * Get personal HTTP tokens
     */
    async getAllAccessTokens2Raw(requestParameters: GetAllAccessTokens2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAllAccessTokens200Response>> {
        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling getAllAccessTokens2().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/users/{userSlug}`.replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get all access tokens associated with the given user.
     * Get personal HTTP tokens
     */
    async getAllAccessTokens2(requestParameters: GetAllAccessTokens2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAllAccessTokens200Response> {
        const response = await this.getAllAccessTokens2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the access token identified by the given ID.
     * Get HTTP token by ID
     */
    async getByIdRaw(requestParameters: GetByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAccessToken>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getById().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling getById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/{tokenId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get the access token identified by the given ID.
     * Get HTTP token by ID
     */
    async getById(requestParameters: GetByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAccessToken> {
        const response = await this.getByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the access token identified by the given ID.
     * Get HTTP token by ID
     */
    async getById1Raw(requestParameters: GetById1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAccessToken>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getById1().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling getById1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getById1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/repos/{repositorySlug}/{tokenId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get the access token identified by the given ID.
     * Get HTTP token by ID
     */
    async getById1(requestParameters: GetById1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAccessToken> {
        const response = await this.getById1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the access token identified by the given ID.
     * Get HTTP token by ID
     */
    async getById2Raw(requestParameters: GetById2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAccessToken>> {
        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling getById2().'
            );
        }

        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling getById2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/access-tokens/latest/users/{userSlug}/{tokenId}`.replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))).replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get the access token identified by the given ID.
     * Get HTTP token by ID
     */
    async getById2(requestParameters: GetById2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAccessToken> {
        const response = await this.getById2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the access key for the SSH key with id <code>keyId</code> on the project identified in the URL.
     * Get project SSH key
     */
    async getForProjectRaw(requestParameters: GetForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshAccessKey>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getForProject().'
            );
        }

        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling getForProject().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/ssh/{keyId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the access key for the SSH key with id <code>keyId</code> on the project identified in the URL.
     * Get project SSH key
     */
    async getForProject(requestParameters: GetForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshAccessKey> {
        const response = await this.getForProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves all project-related access keys for the SSH key with id <code>keyId</code>. If the current user is not an admin any of the projects the key provides access to, none are returned.
     * Get project SSH keys
     */
    async getForProjectsRaw(requestParameters: GetForProjectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling getForProjects().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/ssh/{keyId}/projects`.replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves all project-related access keys for the SSH key with id <code>keyId</code>. If the current user is not an admin any of the projects the key provides access to, none are returned.
     * Get project SSH keys
     */
    async getForProjects(requestParameters: GetForProjectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getForProjectsRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves all repository-related access keys for the SSH key with id <code>keyId</code>. If the current user is not an admin of any of the projects the key provides access to, none are returned.
     * Get repository SSH key
     */
    async getForRepositoriesRaw(requestParameters: GetForRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling getForRepositories().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['withRestrictions'] != null) {
            queryParameters['withRestrictions'] = requestParameters['withRestrictions'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/ssh/{keyId}/repos`.replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves all repository-related access keys for the SSH key with id <code>keyId</code>. If the current user is not an admin of any of the projects the key provides access to, none are returned.
     * Get repository SSH key
     */
    async getForRepositories(requestParameters: GetForRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getForRepositoriesRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves the access key for the SSH key with id <code>keyId</code> on the repository identified in the URL.
     * Get repository SSH key
     */
    async getForRepositoryRaw(requestParameters: GetForRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshAccessKey>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getForRepository().'
            );
        }

        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling getForRepository().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getForRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/repos/{repositorySlug}/ssh/{keyId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the access key for the SSH key with id <code>keyId</code> on the repository identified in the URL.
     * Get repository SSH key
     */
    async getForRepository(requestParameters: GetForRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshAccessKey> {
        const response = await this.getForRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the access keys for the repository identified in the URL.
     * Get repository SSH keys
     */
    async getForRepository1Raw(requestParameters: GetForRepository1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetForRepository1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getForRepository1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling getForRepository1().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['effective'] != null) {
            queryParameters['effective'] = requestParameters['effective'];
        }

        if (requestParameters['minimumPermission'] != null) {
            queryParameters['minimumPermission'] = requestParameters['minimumPermission'];
        }

        if (requestParameters['permission'] != null) {
            queryParameters['permission'] = requestParameters['permission'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/repos/{repositorySlug}/ssh`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the access keys for the repository identified in the URL.
     * Get repository SSH keys
     */
    async getForRepository1(requestParameters: GetForRepository1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetForRepository1200Response> {
        const response = await this.getForRepository1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve an SSH key by keyId  The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     * Get SSH key for user by keyId
     */
    async getSshKeyRaw(requestParameters: GetSshKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshKey>> {
        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling getSshKey().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ssh/latest/keys/{keyId}`.replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve an SSH key by keyId  The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     * Get SSH key for user by keyId
     */
    async getSshKey(requestParameters: GetSshKeyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshKey> {
        const response = await this.getSshKeyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a page of SSH keys.
     * Get SSH keys for user
     */
    async getSshKeysRaw(requestParameters: GetSshKeysRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetSshKeys200Response>> {
        const queryParameters: any = {};

        if (requestParameters['userName'] != null) {
            queryParameters['userName'] = requestParameters['userName'];
        }

        if (requestParameters['user'] != null) {
            queryParameters['user'] = requestParameters['user'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ssh/latest/keys`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a page of SSH keys.
     * Get SSH keys for user
     */
    async getSshKeys(requestParameters: GetSshKeysRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetSshKeys200Response> {
        const response = await this.getSshKeysRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the access keys for the project identified in the URL.
     * Get SSH key
     */
    async getSshKeysForProjectRaw(requestParameters: GetSshKeysForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetForRepository1200Response>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getSshKeysForProject().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['filter'] != null) {
            queryParameters['filter'] = requestParameters['filter'];
        }

        if (requestParameters['permission'] != null) {
            queryParameters['permission'] = requestParameters['permission'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/ssh`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the access keys for the project identified in the URL.
     * Get SSH key
     */
    async getSshKeysForProject(requestParameters: GetSshKeysForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetForRepository1200Response> {
        const response = await this.getSshKeysForProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove an existing access key for the project identified in the URL. If the same SSH key is used as an access key for multiple projects or repositories, only the access to the project identified in the URL will be revoked.
     * Revoke project SSH key
     */
    async revokeForProjectRaw(requestParameters: RevokeForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling revokeForProject().'
            );
        }

        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling revokeForProject().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/ssh/{keyId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove an existing access key for the project identified in the URL. If the same SSH key is used as an access key for multiple projects or repositories, only the access to the project identified in the URL will be revoked.
     * Revoke project SSH key
     */
    async revokeForProject(requestParameters: RevokeForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokeForProjectRaw(requestParameters, initOverrides);
    }

    /**
     * Remove an existing access key for the repository identified in the URL. If the same SSH key is used as an access key for multiple projects or repositories, only the access to the repository identified in the URL will be revoked.
     * Revoke repository SSH key
     */
    async revokeForRepositoryRaw(requestParameters: RevokeForRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling revokeForRepository().'
            );
        }

        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling revokeForRepository().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling revokeForRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/repos/{repositorySlug}/ssh/{keyId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove an existing access key for the repository identified in the URL. If the same SSH key is used as an access key for multiple projects or repositories, only the access to the repository identified in the URL will be revoked.
     * Revoke repository SSH key
     */
    async revokeForRepository(requestParameters: RevokeForRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokeForRepositoryRaw(requestParameters, initOverrides);
    }

    /**
     * Remove an existing access key for the projects and repositories in the submitted entity. If the same SSH key is used as an access key for multiple projects or repositories not supplied, only the access to the projects or repositories identified will be revoked.
     * Revoke project SSH key
     */
    async revokeManyRaw(requestParameters: RevokeManyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling revokeMany().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/keys/latest/ssh/{keyId}`.replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['revokeManyRequest'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove an existing access key for the projects and repositories in the submitted entity. If the same SSH key is used as an access key for multiple projects or repositories not supplied, only the access to the projects or repositories identified will be revoked.
     * Revoke project SSH key
     */
    async revokeMany(requestParameters: RevokeManyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokeManyRaw(requestParameters, initOverrides);
    }

    /**
     * Gets the SSH settings from the upstream.
     * Get SSH settings
     */
    async sshSettingsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshSettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ssh/latest/settings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets the SSH settings from the upstream.
     * Get SSH settings
     */
    async sshSettings(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshSettings> {
        const response = await this.sshSettingsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Modify an access token according to the given request. Any fields not specified will not be altered.
     * Update HTTP token
     */
    async updateAccessTokenRaw(requestParameters: UpdateAccessTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAccessToken>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updateAccessToken().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling updateAccessToken().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/{tokenId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAccessTokenRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Modify an access token according to the given request. Any fields not specified will not be altered.
     * Update HTTP token
     */
    async updateAccessToken(requestParameters: UpdateAccessTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAccessToken> {
        const response = await this.updateAccessTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modify an access token according to the given request. Any fields not specified will not be altered.
     * Update HTTP token
     */
    async updateAccessToken1Raw(requestParameters: UpdateAccessToken1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAccessToken>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updateAccessToken1().'
            );
        }

        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling updateAccessToken1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling updateAccessToken1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/access-tokens/latest/projects/{projectKey}/repos/{repositorySlug}/{tokenId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAccessTokenRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Modify an access token according to the given request. Any fields not specified will not be altered.
     * Update HTTP token
     */
    async updateAccessToken1(requestParameters: UpdateAccessToken1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAccessToken> {
        const response = await this.updateAccessToken1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Modify an access token according to the given request. Any fields not specified will not be altered.
     * Update HTTP token
     */
    async updateAccessToken2Raw(requestParameters: UpdateAccessToken2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAccessToken>> {
        if (requestParameters['tokenId'] == null) {
            throw new runtime.RequiredError(
                'tokenId',
                'Required parameter "tokenId" was null or undefined when calling updateAccessToken2().'
            );
        }

        if (requestParameters['userSlug'] == null) {
            throw new runtime.RequiredError(
                'userSlug',
                'Required parameter "userSlug" was null or undefined when calling updateAccessToken2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/access-tokens/latest/users/{userSlug}/{tokenId}`.replace(`{${"tokenId"}}`, encodeURIComponent(String(requestParameters['tokenId']))).replace(`{${"userSlug"}}`, encodeURIComponent(String(requestParameters['userSlug']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restAccessTokenRequest'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Modify an access token according to the given request. Any fields not specified will not be altered.
     * Update HTTP token
     */
    async updateAccessToken2(requestParameters: UpdateAccessToken2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAccessToken> {
        const response = await this.updateAccessToken2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the permission granted to the specified SSH key to the project identified in the URL.
     * Update project SSH key permission
     */
    async updatePermissionRaw(requestParameters: UpdatePermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshAccessKey>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updatePermission().'
            );
        }

        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling updatePermission().'
            );
        }

        if (requestParameters['permission'] == null) {
            throw new runtime.RequiredError(
                'permission',
                'Required parameter "permission" was null or undefined when calling updatePermission().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/ssh/{keyId}/permission/{permission}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))).replace(`{${"permission"}}`, encodeURIComponent(String(requestParameters['permission']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates the permission granted to the specified SSH key to the project identified in the URL.
     * Update project SSH key permission
     */
    async updatePermission(requestParameters: UpdatePermissionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshAccessKey> {
        const response = await this.updatePermissionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the permission granted to the specified SSH key to the repository identified in the URL.
     * Update repository SSH key permission
     */
    async updatePermission1Raw(requestParameters: UpdatePermission1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSshAccessKey>> {
        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling updatePermission1().'
            );
        }

        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling updatePermission1().'
            );
        }

        if (requestParameters['permission'] == null) {
            throw new runtime.RequiredError(
                'permission',
                'Required parameter "permission" was null or undefined when calling updatePermission1().'
            );
        }

        if (requestParameters['repositorySlug'] == null) {
            throw new runtime.RequiredError(
                'repositorySlug',
                'Required parameter "repositorySlug" was null or undefined when calling updatePermission1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/keys/latest/projects/{projectKey}/repos/{repositorySlug}/ssh/{keyId}/permission/{permission}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))).replace(`{${"keyId"}}`, encodeURIComponent(String(requestParameters['keyId']))).replace(`{${"permission"}}`, encodeURIComponent(String(requestParameters['permission']))).replace(`{${"repositorySlug"}}`, encodeURIComponent(String(requestParameters['repositorySlug']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates the permission granted to the specified SSH key to the repository identified in the URL.
     * Update repository SSH key permission
     */
    async updatePermission1(requestParameters: UpdatePermission1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSshAccessKey> {
        const response = await this.updatePermission1Raw(requestParameters, initOverrides);
        return await response.value();
    }

}
