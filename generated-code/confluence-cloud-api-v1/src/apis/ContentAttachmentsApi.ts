/* tslint:disable */
/* eslint-disable */
/**
 * The Confluence Cloud REST API
 * This document describes the REST API and resources provided by Confluence. The REST APIs are for developers who want to integrate Confluence into their application and for administrators who want to script interactions with the Confluence server.Confluence\'s REST APIs provide access to resources (data entities) via URI paths. To use a REST API, your application will make an HTTP request and parse the response. The response format is JSON. Your methods will be the standard HTTP methods like GET, PUT, POST and DELETE. Because the REST API is based on open standards, you can use any web development language to access the API.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AttachmentPropertiesUpdateBody,
  Content,
  ContentArray,
} from '../models/index';

export interface CreateAttachmentRequest {
    id: string;
    file: Blob;
    minorEdit: Blob;
    status?: CreateAttachmentStatusEnum;
    comment?: Blob;
}

export interface CreateOrUpdateAttachmentsRequest {
    id: string;
    file: Blob;
    minorEdit: Blob;
    status?: CreateOrUpdateAttachmentsStatusEnum;
    comment?: Blob;
}

export interface DownloadAttatchmentRequest {
    id: string;
    attachmentId: string;
    version?: number;
}

export interface GetAttachmentsRequest {
    id: string;
    expand?: Array<string>;
    start?: number;
    limit?: number;
    filename?: string;
    mediaType?: string;
}

export interface UpdateAttachmentDataRequest {
    id: string;
    attachmentId: string;
    file: Blob;
    minorEdit: Blob;
    comment?: Blob;
}

export interface UpdateAttachmentPropertiesRequest {
    id: string;
    attachmentId: string;
    body: AttachmentPropertiesUpdateBody;
}

/**
 * 
 */
export class ContentAttachmentsApi extends runtime.BaseAPI {

    /**
     * Adds an attachment to a piece of content. This method only adds a new attachment. If you want to update an existing attachment, use [Create or update attachments](#api-content-id-child-attachment-put).  Note, you must set a `X-Atlassian-Token: nocheck` header on the request for this method, otherwise it will be blocked. This protects against XSRF attacks, which is necessary as this method accepts multipart/form-data.  The media type \'multipart/form-data\' is defined in [RFC 7578](https://www.ietf.org/rfc/rfc7578.txt). Most client libraries have classes that make it easier to implement multipart posts, like the [MultipartEntityBuilder](https://hc.apache.org/httpcomponents-client-5.1.x/current/httpclient5/apidocs/) Java class provided by Apache HTTP Components.  Note, according to [RFC 7578](https://tools.ietf.org/html/rfc7578#section-4.5), in the case where the form data is text, the charset parameter for the \"text/plain\" Content-Type may be used to indicate the character encoding used in that part. In the case of this API endpoint, the `comment` body parameter should be sent with `type=text/plain` and `charset=utf-8` values. This will force the charset to be UTF-8.  Example: This curl command attaches a file (\'example.txt\') to a container (id=\'123\') with a comment and `minorEdits`=true.  ``` bash curl -D- \\   -u admin:admin \\   -X POST \\   -H \'X-Atlassian-Token: nocheck\' \\   -F \'file=@\"example.txt\"\' \\   -F \'minorEdit=\"true\"\' \\   -F \'comment=\"Example attachment comment\"; type=text/plain; charset=utf-8\' \\   http://myhost/rest/api/content/123/child/attachment ``` **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the content.
     * Create attachment
     */
    async createAttachmentRaw(requestParameters: CreateAttachmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContentArray>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling createAttachment().'
            );
        }

        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling createAttachment().'
            );
        }

        if (requestParameters['minorEdit'] == null) {
            throw new runtime.RequiredError(
                'minorEdit',
                'Required parameter "minorEdit" was null or undefined when calling createAttachment().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["write:confluence-file"]);
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['comment'] != null) {
            formParams.append('comment', requestParameters['comment'] as any);
        }

        if (requestParameters['minorEdit'] != null) {
            formParams.append('minorEdit', requestParameters['minorEdit'] as any);
        }

        const response = await this.request({
            path: `/wiki/rest/api/content/{id}/child/attachment`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Adds an attachment to a piece of content. This method only adds a new attachment. If you want to update an existing attachment, use [Create or update attachments](#api-content-id-child-attachment-put).  Note, you must set a `X-Atlassian-Token: nocheck` header on the request for this method, otherwise it will be blocked. This protects against XSRF attacks, which is necessary as this method accepts multipart/form-data.  The media type \'multipart/form-data\' is defined in [RFC 7578](https://www.ietf.org/rfc/rfc7578.txt). Most client libraries have classes that make it easier to implement multipart posts, like the [MultipartEntityBuilder](https://hc.apache.org/httpcomponents-client-5.1.x/current/httpclient5/apidocs/) Java class provided by Apache HTTP Components.  Note, according to [RFC 7578](https://tools.ietf.org/html/rfc7578#section-4.5), in the case where the form data is text, the charset parameter for the \"text/plain\" Content-Type may be used to indicate the character encoding used in that part. In the case of this API endpoint, the `comment` body parameter should be sent with `type=text/plain` and `charset=utf-8` values. This will force the charset to be UTF-8.  Example: This curl command attaches a file (\'example.txt\') to a container (id=\'123\') with a comment and `minorEdits`=true.  ``` bash curl -D- \\   -u admin:admin \\   -X POST \\   -H \'X-Atlassian-Token: nocheck\' \\   -F \'file=@\"example.txt\"\' \\   -F \'minorEdit=\"true\"\' \\   -F \'comment=\"Example attachment comment\"; type=text/plain; charset=utf-8\' \\   http://myhost/rest/api/content/123/child/attachment ``` **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the content.
     * Create attachment
     */
    async createAttachment(requestParameters: CreateAttachmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContentArray> {
        const response = await this.createAttachmentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Adds an attachment to a piece of content. If the attachment already exists for the content, then the attachment is updated (i.e. a new version of the attachment is created).  Note, you must set a `X-Atlassian-Token: nocheck` header on the request for this method, otherwise it will be blocked. This protects against XSRF attacks, which is necessary as this method accepts multipart/form-data.  The media type \'multipart/form-data\' is defined in [RFC 7578](https://www.ietf.org/rfc/rfc7578.txt). Most client libraries have classes that make it easier to implement multipart posts, like the [MultipartEntityBuilder](https://hc.apache.org/httpcomponents-client-5.1.x/current/httpclient5/apidocs/) Java class provided by Apache HTTP Components.  Note, according to [RFC 7578](https://tools.ietf.org/html/rfc7578#section-4.5), in the case where the form data is text, the charset parameter for the \"text/plain\" Content-Type may be used to indicate the character encoding used in that part. In the case of this API endpoint, the `comment` body parameter should be sent with `type=text/plain` and `charset=utf-8` values. This will force the charset to be UTF-8.  Example: This curl command attaches a file (\'example.txt\') to a piece of content (id=\'123\') with a comment and `minorEdits`=true. If the \'example.txt\' file already exists, it will update it with a new version of the attachment.  ``` bash curl -D- \\   -u admin:admin \\   -X PUT \\   -H \'X-Atlassian-Token: nocheck\' \\   -F \'file=@\"example.txt\"\' \\   -F \'minorEdit=\"true\"\' \\   -F \'comment=\"Example attachment comment\"; type=text/plain; charset=utf-8\' \\   http://myhost/rest/api/content/123/child/attachment ``` **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the content.
     * Create or update attachment
     */
    async createOrUpdateAttachmentsRaw(requestParameters: CreateOrUpdateAttachmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContentArray>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling createOrUpdateAttachments().'
            );
        }

        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling createOrUpdateAttachments().'
            );
        }

        if (requestParameters['minorEdit'] == null) {
            throw new runtime.RequiredError(
                'minorEdit',
                'Required parameter "minorEdit" was null or undefined when calling createOrUpdateAttachments().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["write:confluence-file"]);
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['comment'] != null) {
            formParams.append('comment', requestParameters['comment'] as any);
        }

        if (requestParameters['minorEdit'] != null) {
            formParams.append('minorEdit', requestParameters['minorEdit'] as any);
        }

        const response = await this.request({
            path: `/wiki/rest/api/content/{id}/child/attachment`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Adds an attachment to a piece of content. If the attachment already exists for the content, then the attachment is updated (i.e. a new version of the attachment is created).  Note, you must set a `X-Atlassian-Token: nocheck` header on the request for this method, otherwise it will be blocked. This protects against XSRF attacks, which is necessary as this method accepts multipart/form-data.  The media type \'multipart/form-data\' is defined in [RFC 7578](https://www.ietf.org/rfc/rfc7578.txt). Most client libraries have classes that make it easier to implement multipart posts, like the [MultipartEntityBuilder](https://hc.apache.org/httpcomponents-client-5.1.x/current/httpclient5/apidocs/) Java class provided by Apache HTTP Components.  Note, according to [RFC 7578](https://tools.ietf.org/html/rfc7578#section-4.5), in the case where the form data is text, the charset parameter for the \"text/plain\" Content-Type may be used to indicate the character encoding used in that part. In the case of this API endpoint, the `comment` body parameter should be sent with `type=text/plain` and `charset=utf-8` values. This will force the charset to be UTF-8.  Example: This curl command attaches a file (\'example.txt\') to a piece of content (id=\'123\') with a comment and `minorEdits`=true. If the \'example.txt\' file already exists, it will update it with a new version of the attachment.  ``` bash curl -D- \\   -u admin:admin \\   -X PUT \\   -H \'X-Atlassian-Token: nocheck\' \\   -F \'file=@\"example.txt\"\' \\   -F \'minorEdit=\"true\"\' \\   -F \'comment=\"Example attachment comment\"; type=text/plain; charset=utf-8\' \\   http://myhost/rest/api/content/123/child/attachment ``` **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the content.
     * Create or update attachment
     */
    async createOrUpdateAttachments(requestParameters: CreateOrUpdateAttachmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContentArray> {
        const response = await this.createOrUpdateAttachmentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Redirects the client to a URL that serves an attachment\'s binary data.
     * Get URI to download attachment
     */
    async downloadAttatchmentRaw(requestParameters: DownloadAttatchmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling downloadAttatchment().'
            );
        }

        if (requestParameters['attachmentId'] == null) {
            throw new runtime.RequiredError(
                'attachmentId',
                'Required parameter "attachmentId" was null or undefined when calling downloadAttatchment().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['version'] != null) {
            queryParameters['version'] = requestParameters['version'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["readonly:content.attachment:confluence"]);
        }

        const response = await this.request({
            path: `/wiki/rest/api/content/{id}/child/attachment/{attachmentId}/download`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"attachmentId"}}`, encodeURIComponent(String(requestParameters['attachmentId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Redirects the client to a URL that serves an attachment\'s binary data.
     * Get URI to download attachment
     */
    async downloadAttatchment(requestParameters: DownloadAttatchmentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.downloadAttatchmentRaw(requestParameters, initOverrides);
    }

    /**
     * Deprecated, use [Confluence\'s v2 API](https://developer.atlassian.com/cloud/confluence/rest/v2/intro/).  Returns the attachments for a piece of content.  By default, the following objects are expanded: `metadata`.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content. If the content is a blog post, \'View\' permission for the space is required.
     * Get attachments
     * @deprecated
     */
    async getAttachmentsRaw(requestParameters: GetAttachmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContentArray>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getAttachments().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['expand'] != null) {
            queryParameters['expand'] = requestParameters['expand']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['filename'] != null) {
            queryParameters['filename'] = requestParameters['filename'];
        }

        if (requestParameters['mediaType'] != null) {
            queryParameters['mediaType'] = requestParameters['mediaType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:confluence-content.summary"]);
        }

        const response = await this.request({
            path: `/wiki/rest/api/content/{id}/child/attachment`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deprecated, use [Confluence\'s v2 API](https://developer.atlassian.com/cloud/confluence/rest/v2/intro/).  Returns the attachments for a piece of content.  By default, the following objects are expanded: `metadata`.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view the content. If the content is a blog post, \'View\' permission for the space is required.
     * Get attachments
     * @deprecated
     */
    async getAttachments(requestParameters: GetAttachmentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContentArray> {
        const response = await this.getAttachmentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the binary data of an attachment, given the attachment ID, and optionally the comment and the minor edit field.  This method is essentially the same as [Create or update attachments](#api-content-id-child-attachment-put), except that it matches the attachment ID rather than the name.  Note, you must set a `X-Atlassian-Token: nocheck` header on the request for this method, otherwise it will be blocked. This protects against XSRF attacks, which is necessary as this method accepts multipart/form-data.  The media type \'multipart/form-data\' is defined in [RFC 7578](https://www.ietf.org/rfc/rfc7578.txt). Most client libraries have classes that make it easier to implement multipart posts, like the [MultipartEntityBuilder](https://hc.apache.org/httpcomponents-client-5.1.x/current/httpclient5/apidocs/) Java class provided by Apache HTTP Components.  Note, according to [RFC 7578](https://tools.ietf.org/html/rfc7578#section-4.5), in the case where the form data is text, the charset parameter for the \"text/plain\" Content-Type may be used to indicate the character encoding used in that part. In the case of this API endpoint, the `comment` body parameter should be sent with `type=text/plain` and `charset=utf-8` values. This will force the charset to be UTF-8.  Example: This curl command updates an attachment (id=\'att456\') that is attached to a piece of content (id=\'123\') with a comment and `minorEdits`=true.  ``` bash curl -D- \\   -u admin:admin \\   -X POST \\   -H \'X-Atlassian-Token: nocheck\' \\   -F \'file=@\"example.txt\"\' \\   -F \'minorEdit=\"true\"\' \\   -F \'comment=\"Example attachment comment\"; type=text/plain; charset=utf-8\' \\   http://myhost/rest/api/content/123/child/attachment/att456/data ``` **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the content.
     * Update attachment data
     */
    async updateAttachmentDataRaw(requestParameters: UpdateAttachmentDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Content>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateAttachmentData().'
            );
        }

        if (requestParameters['attachmentId'] == null) {
            throw new runtime.RequiredError(
                'attachmentId',
                'Required parameter "attachmentId" was null or undefined when calling updateAttachmentData().'
            );
        }

        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling updateAttachmentData().'
            );
        }

        if (requestParameters['minorEdit'] == null) {
            throw new runtime.RequiredError(
                'minorEdit',
                'Required parameter "minorEdit" was null or undefined when calling updateAttachmentData().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["write:confluence-file"]);
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['comment'] != null) {
            formParams.append('comment', requestParameters['comment'] as any);
        }

        if (requestParameters['minorEdit'] != null) {
            formParams.append('minorEdit', requestParameters['minorEdit'] as any);
        }

        const response = await this.request({
            path: `/wiki/rest/api/content/{id}/child/attachment/{attachmentId}/data`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"attachmentId"}}`, encodeURIComponent(String(requestParameters['attachmentId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates the binary data of an attachment, given the attachment ID, and optionally the comment and the minor edit field.  This method is essentially the same as [Create or update attachments](#api-content-id-child-attachment-put), except that it matches the attachment ID rather than the name.  Note, you must set a `X-Atlassian-Token: nocheck` header on the request for this method, otherwise it will be blocked. This protects against XSRF attacks, which is necessary as this method accepts multipart/form-data.  The media type \'multipart/form-data\' is defined in [RFC 7578](https://www.ietf.org/rfc/rfc7578.txt). Most client libraries have classes that make it easier to implement multipart posts, like the [MultipartEntityBuilder](https://hc.apache.org/httpcomponents-client-5.1.x/current/httpclient5/apidocs/) Java class provided by Apache HTTP Components.  Note, according to [RFC 7578](https://tools.ietf.org/html/rfc7578#section-4.5), in the case where the form data is text, the charset parameter for the \"text/plain\" Content-Type may be used to indicate the character encoding used in that part. In the case of this API endpoint, the `comment` body parameter should be sent with `type=text/plain` and `charset=utf-8` values. This will force the charset to be UTF-8.  Example: This curl command updates an attachment (id=\'att456\') that is attached to a piece of content (id=\'123\') with a comment and `minorEdits`=true.  ``` bash curl -D- \\   -u admin:admin \\   -X POST \\   -H \'X-Atlassian-Token: nocheck\' \\   -F \'file=@\"example.txt\"\' \\   -F \'minorEdit=\"true\"\' \\   -F \'comment=\"Example attachment comment\"; type=text/plain; charset=utf-8\' \\   http://myhost/rest/api/content/123/child/attachment/att456/data ``` **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the content.
     * Update attachment data
     */
    async updateAttachmentData(requestParameters: UpdateAttachmentDataRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Content> {
        const response = await this.updateAttachmentDataRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates the attachment properties, i.e. the non-binary data of an attachment like the filename, media-type, comment, and parent container.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the content.
     * Update attachment properties
     */
    async updateAttachmentPropertiesRaw(requestParameters: UpdateAttachmentPropertiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Content>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling updateAttachmentProperties().'
            );
        }

        if (requestParameters['attachmentId'] == null) {
            throw new runtime.RequiredError(
                'attachmentId',
                'Required parameter "attachmentId" was null or undefined when calling updateAttachmentProperties().'
            );
        }

        if (requestParameters['body'] == null) {
            throw new runtime.RequiredError(
                'body',
                'Required parameter "body" was null or undefined when calling updateAttachmentProperties().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["write:confluence-file", "write:confluence-props"]);
        }

        const response = await this.request({
            path: `/wiki/rest/api/content/{id}/child/attachment/{attachmentId}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"attachmentId"}}`, encodeURIComponent(String(requestParameters['attachmentId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Updates the attachment properties, i.e. the non-binary data of an attachment like the filename, media-type, comment, and parent container.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to update the content.
     * Update attachment properties
     */
    async updateAttachmentProperties(requestParameters: UpdateAttachmentPropertiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Content> {
        const response = await this.updateAttachmentPropertiesRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const CreateAttachmentStatusEnum = {
    Current: 'current',
    Draft: 'draft'
} as const;
export type CreateAttachmentStatusEnum = typeof CreateAttachmentStatusEnum[keyof typeof CreateAttachmentStatusEnum];
/**
 * @export
 */
export const CreateOrUpdateAttachmentsStatusEnum = {
    Current: 'current',
    Draft: 'draft'
} as const;
export type CreateOrUpdateAttachmentsStatusEnum = typeof CreateOrUpdateAttachmentsStatusEnum[keyof typeof CreateOrUpdateAttachmentsStatusEnum];
