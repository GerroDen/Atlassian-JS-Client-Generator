/* tslint:disable */
/* eslint-disable */
/**
 * Bitbucket Data Center
 * This is the reference document for the Atlassian Bitbucket REST API. The REST API is for developers who want to:    - integrate Bitbucket with other applications;   - create scripts that interact with Bitbucket; or   - develop plugins that enhance the Bitbucket UI, using REST to interact with the backend.    You can read more about developing Bitbucket plugins in the [Bitbucket Developer Documentation](https://developer.atlassian.com/bitbucket/server/docs/latest/).
 *
 * The version of the OpenAPI document: 9.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  GetAllAccessTokens401Response,
  GetRepoSyncStatus200Response,
  RestClusterNode,
  RestErrors,
  RestMirrorRepositorySynchronizationStatus,
  RestMirroredRepository,
  RestRefSyncQueue,
  RestRollingUpgradeState,
  RestSyncProgress,
  RestUpstreamServer,
  RestUpstreamSettings,
} from '../models/index';

interface GetMirroredRepositoryRequest {
    externalRepositoryId: string;
}

interface GetRepoSyncStatusRequest {
    start?: number;
    limit?: number;
}

interface GetRepoSyncStatus1Request {
    repoSlug: string;
    projectKey: string;
}

interface SetMirrorModeRequest {
    body?: string;
}

interface SetMirrorSettingsRequest {
    restUpstreamSettings?: RestUpstreamSettings;
}

interface StartMirroringProjectRequest {
    projectId: string;
}

interface StartMirroringProjectsRequest {
    requestBody?: Array<string>;
}

interface StopMirroringProjectRequest {
    projectId: string;
}

/**
 * 
 */
export class MirroringMirrorApi extends runtime.BaseAPI {

    /**
     * Finalizes the ZDU upgrade on the mirror farm denying heterogeneous cluster formation
     * End ZDU upgrade on mirror farm
     */
    async endRollingUpgradeRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRollingUpgradeState>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/zdu/end`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Finalizes the ZDU upgrade on the mirror farm denying heterogeneous cluster formation
     * End ZDU upgrade on mirror farm
     */
    async endRollingUpgrade(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRollingUpgradeState> {
        const response = await this.endRollingUpgradeRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the list of farm nodes in this cluster
     * Get farm nodes
     */
    async getFarmNodesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestClusterNode>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/farmNodes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the list of farm nodes in this cluster
     * Get farm nodes
     */
    async getFarmNodes(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestClusterNode>> {
        const response = await this.getFarmNodesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Gets the current mirror mode
     * Get mirror mode
     */
    async getMirrorModeRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/syncSettings/mode`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Gets the current mirror mode
     * Get mirror mode
     */
    async getMirrorMode(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getMirrorModeRaw(initOverrides);
    }

    /**
     * Retrieves upstream settings
     * Get upstream settings
     */
    async getMirrorSettingsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestUpstreamSettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/syncSettings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves upstream settings
     * Get upstream settings
     */
    async getMirrorSettings(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestUpstreamSettings> {
        const response = await this.getMirrorSettingsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns the IDs of the projects that the mirror is configured to mirror
     * Get mirrored project IDs
     */
    async getMirroredProjectsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/syncSettings/projects`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Returns the IDs of the projects that the mirror is configured to mirror
     * Get mirrored project IDs
     */
    async getMirroredProjects(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getMirroredProjectsRaw(initOverrides);
    }

    /**
     * Retrieves all available clone urls for the specified repository.
     * Get clone URLs
     */
    async getMirroredRepositoryRaw(requestParameters: GetMirroredRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMirroredRepository>> {
        if (requestParameters['externalRepositoryId'] == null) {
            throw new runtime.RequiredError(
                'externalRepositoryId',
                'Required parameter "externalRepositoryId" was null or undefined when calling getMirroredRepository().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/mirrorRepos/{externalRepositoryId}`.replace(`{${"externalRepositoryId"}}`, encodeURIComponent(String(requestParameters['externalRepositoryId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves all available clone urls for the specified repository.
     * Get clone URLs
     */
    async getMirroredRepository(requestParameters: GetMirroredRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMirroredRepository> {
        const response = await this.getMirroredRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a list of up to <code>plugin.mirroring.farm.max.ref.change.queue.dump.size</code> items currently in the ref changes queue. The ref changes queue is an internal component of every mirror farm, and is shared between all nodes. When the contents of an upstream repository changes, an item is added to this queue so that the mirror farm nodes know to synchronize. The mirror farm constantly polls and removes items from this queue for processing, so it is empty most of the time.
     * Get items in ref changes queue
     */
    async getRefChangesQueueRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRefSyncQueue>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/supportInfo/refChangesQueue`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves a list of up to <code>plugin.mirroring.farm.max.ref.change.queue.dump.size</code> items currently in the ref changes queue. The ref changes queue is an internal component of every mirror farm, and is shared between all nodes. When the contents of an upstream repository changes, an item is added to this queue so that the mirror farm nodes know to synchronize. The mirror farm constantly polls and removes items from this queue for processing, so it is empty most of the time.
     * Get items in ref changes queue
     */
    async getRefChangesQueue(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRefSyncQueue> {
        const response = await this.getRefChangesQueueRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieves the total number of items currently in the ref changes queue
     * Get total number of items in ref changes queue
     */
    async getRefChangesQueueCountRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/supportInfo/refChangesQueue/count`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Retrieves the total number of items currently in the ref changes queue
     * Get total number of items in ref changes queue
     */
    async getRefChangesQueueCount(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getRefChangesQueueCountRaw(initOverrides);
    }

    /**
     * Retrieves a page of sync statuses of the repositories on this mirror node
     * Get sync status of repositories
     */
    async getRepoSyncStatusRaw(requestParameters: GetRepoSyncStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetRepoSyncStatus200Response>> {
        const queryParameters: any = {};

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/supportInfo/repoSyncStatus`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves a page of sync statuses of the repositories on this mirror node
     * Get sync status of repositories
     */
    async getRepoSyncStatus(requestParameters: GetRepoSyncStatusRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetRepoSyncStatus200Response> {
        const response = await this.getRepoSyncStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves information about an external repository mirrored by the mirror server. Particularly the local ID & external ID of the repository
     * Gets information about the mirrored repository
     */
    async getRepoSyncStatus1Raw(requestParameters: GetRepoSyncStatus1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMirrorRepositorySynchronizationStatus>> {
        if (requestParameters['repoSlug'] == null) {
            throw new runtime.RequiredError(
                'repoSlug',
                'Required parameter "repoSlug" was null or undefined when calling getRepoSyncStatus1().'
            );
        }

        if (requestParameters['projectKey'] == null) {
            throw new runtime.RequiredError(
                'projectKey',
                'Required parameter "projectKey" was null or undefined when calling getRepoSyncStatus1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/supportInfo/projects/{projectKey}/repos/{repoSlug}/repoSyncStatus`.replace(`{${"repoSlug"}}`, encodeURIComponent(String(requestParameters['repoSlug']))).replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters['projectKey']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves information about an external repository mirrored by the mirror server. Particularly the local ID & external ID of the repository
     * Gets information about the mirrored repository
     */
    async getRepoSyncStatus1(requestParameters: GetRepoSyncStatus1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMirrorRepositorySynchronizationStatus> {
        const response = await this.getRepoSyncStatus1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *  Retrieves synchronization progress state.If there\'s no progress to report, this resource will return <pre><code> {\"discovering\":false,\"syncedRepos\":0,\"totalRepos\":0}</code></pre> If there are repositories in the process of synchronizing, but the precise number hasn\'t been discovered yet, this resource will return: <pre><code> {\"discovering\":true,\"syncedRepos\":3,\"totalRepos\":100}</code></pre> If there is progress to report and the total number of repositories is known, this resource will return: <pre> <code> {\"discovering\":false,\"syncedRepos\":242,\"totalRepos\":1071}</code> </pre>
     * Get synchronization progress state
     */
    async getSynchronizationProgressRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSyncProgress>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/progress`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     *  Retrieves synchronization progress state.If there\'s no progress to report, this resource will return <pre><code> {\"discovering\":false,\"syncedRepos\":0,\"totalRepos\":0}</code></pre> If there are repositories in the process of synchronizing, but the precise number hasn\'t been discovered yet, this resource will return: <pre><code> {\"discovering\":true,\"syncedRepos\":3,\"totalRepos\":100}</code></pre> If there is progress to report and the total number of repositories is known, this resource will return: <pre> <code> {\"discovering\":false,\"syncedRepos\":242,\"totalRepos\":1071}</code> </pre>
     * Get synchronization progress state
     */
    async getSynchronizationProgress(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSyncProgress> {
        const response = await this.getSynchronizationProgressRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieves upstream server details.
     * Get upstream server
     */
    async getUpstreamServerRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestUpstreamServer>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/upstreamServer`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves upstream server details.
     * Get upstream server
     */
    async getUpstreamServer(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestUpstreamServer> {
        const response = await this.getUpstreamServerRaw(initOverrides);
        return await response.value();
    }

    /**
     * Sets the mirror mode for the specified upstream
     * Update mirror mode
     */
    async setMirrorModeRaw(requestParameters: SetMirrorModeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/mirroring/latest/syncSettings/mode`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['body'] as any,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Sets the mirror mode for the specified upstream
     * Update mirror mode
     */
    async setMirrorMode(requestParameters: SetMirrorModeRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setMirrorModeRaw(requestParameters, initOverrides);
    }

    /**
     * Sets the settings for the specified upstream
     * Update upstream settings
     */
    async setMirrorSettingsRaw(requestParameters: SetMirrorSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestUpstreamSettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/mirroring/latest/syncSettings`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['restUpstreamSettings'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Sets the settings for the specified upstream
     * Update upstream settings
     */
    async setMirrorSettings(requestParameters: SetMirrorSettingsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestUpstreamSettings> {
        const response = await this.setMirrorSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Configures the mirror to mirror the provided project
     * Add project to be mirrored
     */
    async startMirroringProjectRaw(requestParameters: StartMirroringProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling startMirroringProject().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/syncSettings/projects/{projectId}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Configures the mirror to mirror the provided project
     * Add project to be mirrored
     */
    async startMirroringProject(requestParameters: StartMirroringProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.startMirroringProjectRaw(requestParameters, initOverrides);
    }

    /**
     * Configures the mirror to mirror the provided projects
     * Add multiple projects to be mirrored
     */
    async startMirroringProjectsRaw(requestParameters: StartMirroringProjectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/mirroring/latest/syncSettings/projects`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Configures the mirror to mirror the provided projects
     * Add multiple projects to be mirrored
     */
    async startMirroringProjects(requestParameters: StartMirroringProjectsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.startMirroringProjectsRaw(requestParameters, initOverrides);
    }

    /**
     * Enables upgrading of individual nodes within the cluster, allowing a heterogeneous cluster formation
     * Start ZDU upgrade on mirror farm
     */
    async startRollingUpgradeRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRollingUpgradeState>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/zdu/start`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Enables upgrading of individual nodes within the cluster, allowing a heterogeneous cluster formation
     * Start ZDU upgrade on mirror farm
     */
    async startRollingUpgrade(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRollingUpgradeState> {
        const response = await this.startRollingUpgradeRaw(initOverrides);
        return await response.value();
    }

    /**
     * Configures the mirror to no longer mirror the provided project
     * Stop mirroring project
     */
    async stopMirroringProjectRaw(requestParameters: StopMirroringProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['projectId'] == null) {
            throw new runtime.RequiredError(
                'projectId',
                'Required parameter "projectId" was null or undefined when calling stopMirroringProject().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/mirroring/latest/syncSettings/projects/{projectId}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters['projectId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Configures the mirror to no longer mirror the provided project
     * Stop mirroring project
     */
    async stopMirroringProject(requestParameters: StopMirroringProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.stopMirroringProjectRaw(requestParameters, initOverrides);
    }

}
