/* tslint:disable */
/* eslint-disable */
/**
 * Bamboo
 * This is the reference document for the Atlassian Bamboo REST API. The REST API is for developers who want to:    - integrate Bamboo with other applications;   - create scripts that interact with Bamboo; or   - develop plugins that enhance the Bamboo UI, using REST to interact with the backend.    You can read more about developing Bamboo plugins in the [Bamboo Developer Documentation](https://developer.atlassian.com/bamboo/server/docs/latest/).
 *
 * The version of the OpenAPI document: 9.3.2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BuildMonitoringLink,
  CreateCommentRequest,
  DashboardProjectWithEnvironmentStatus,
  EnvironmentIds,
  EphemeralAgentsConfigurationDTO,
  FindPlansWithCustomExpirySettings200Response,
  GetAgents200Response,
  GetBrokenBuildsForUser200Response,
  GetDeploymentProjects200Response,
  GetEphemeralAgentPodLogs200Response,
  GetEphemeralAgentPodRawLogs200Response,
  GetPaginatedProjectRepositories200Response,
  GetPaginatedProjectSharedCredentials200Response,
  JsonSearchResultsList,
  ManualEncryptionRequest,
  ManualEncryptionResponse,
  ReindexBean,
  RestAgent,
  RestAgentInformation,
  RestAnonymousServerStatusInfo,
  RestArtifactHandler,
  RestAuditLogConfiguration,
  RestBranchList,
  RestBuildAgent,
  RestBuildConcurrency,
  RestBuildLabel,
  RestBuildLabels,
  RestBuildMonitoring,
  RestCapability,
  RestChart,
  RestCombinedExpiryConfiguration,
  RestCombinedExpiryStatus,
  RestComments,
  RestCreateDeploymentProjectRequest,
  RestCreateVersionRequest,
  RestDarkFeature,
  RestDependencies,
  RestDeploymentProject,
  RestDeploymentProjectStatusForJiraIssue,
  RestDeploymentResult,
  RestDeploymentVersion,
  RestDeploymentVersionAndPlanResult,
  RestDeploymentVersionStatus,
  RestElasticConfiguration,
  RestElasticImageConfig,
  RestElasticInstanceLog,
  RestEnableContainer,
  RestEnvironmentStatusForDashboard,
  RestEphemeralAgentTemplate,
  RestErrorCollection,
  RestFavicon,
  RestGeneralConfiguration,
  RestGlobalVariable,
  RestGlobalVariables,
  RestGroup,
  RestIMServerConfiguration,
  RestIdContainer,
  RestInfo,
  RestJiraIssueRelatedDeploymentProjects,
  RestLinkedDeploymentProject,
  RestMailConfiguration,
  RestNamingPreview,
  RestPlan,
  RestProject,
  RestProjects,
  RestQuarantineConfig,
  RestQueuedBuild,
  RestQueuedBuilds,
  RestQuickFilter,
  RestRemoteAgentAuthentication,
  RestRemoteAgentCapability,
  RestRemoteAgentConfiguration,
  RestReports,
  RestRepository,
  RestRepositoryConnectionResult,
  RestRepositoryList,
  RestRepositoryMinimal,
  RestRepositoryUsageModel,
  RestResources,
  RestResultStatus,
  RestResults,
  RestScheduledJob,
  RestSecuritySettings,
  RestServerNodesInfo,
  RestServerStatusInfo,
  RestUpdateDeploymentProjectRequest,
  RestUserDarkFeature,
  RestVariable,
  RestVariableDefinitionContext,
  RestVcsLocationSpecsStatus,
  RestVerificationRequest,
  Result,
  RunExpiryResponse,
  SearchResultsList,
  SecuritySettingsLink,
  SimpleRestArtifactHandler,
  StartBuildRequest,
  Status,
  TestConnectionResultDto,
  UserBean,
  VersionVariables,
} from '../models';

export interface ActivateFilterRequest {
    id: number;
}

export interface AddAssignedRepositoryRequest {
    deploymentProjectId: string;
    restIdContainer: RestIdContainer;
}

export interface AddAssignedRepository1Request {
    projectKey: string;
    restIdContainer: RestIdContainer;
}

export interface AddBuildCommentRequest {
    projectKey: string;
    buildKey: string;
    buildNumber: string;
    createCommentRequest: CreateCommentRequest;
}

export interface AddBuildLabelRequest {
    projectKey: string;
    buildKey: string;
    buildNumber: string;
    restBuildLabel: RestBuildLabel;
}

export interface AddCapabilityRequest {
    configurationId: number;
    restCapability: RestCapability;
}

export interface AddDeploymentProjectRequest {
    restCreateDeploymentProjectRequest: RestCreateDeploymentProjectRequest;
}

export interface AddResponsibleRequest {
    name: string;
    planResultKeyOrPlanKey: string;
}

export interface AuthenticateAgentRequest {
    agentUuid: string;
}

export interface ContinueBuildRequest {
    projectKey: string;
    buildKey: string;
    buildNumber: number;
    executeAllStages?: boolean;
    stage?: string;
}

export interface CreateAgentCapabilityRequest {
    agentId: number;
    restCapability: RestCapability;
}

export interface CreateGlobalVariableRequest {
    restGlobalVariable: RestGlobalVariable;
}

export interface CreateGroupRequest {
    restGroup: RestGroup;
}

export interface CreateImageConfigurationRequest {
    restElasticImageConfig: RestElasticImageConfig;
}

export interface CreateOrUpdateVariableRequest {
    projectKey: string;
    restVariable: RestVariable;
}

export interface CreateProjectRequest {
    restProject: RestProject;
}

export interface CreateQuickFilterRequest {
    restQuickFilter: RestQuickFilter;
}

export interface CreateTemplateConfigurationRequest {
    restEphemeralAgentTemplate: RestEphemeralAgentTemplate;
}

export interface CreateVersionRequest {
    deploymentProjectId: string;
    restCreateVersionRequest: RestCreateVersionRequest;
}

export interface DeactivateFilterRequest {
    id: number;
}

export interface DeleteAgentRequest {
    agentId: number;
}

export interface DeleteAgentCapabilityRequest {
    agentId: number;
    capabilityKey: string;
}

export interface DeleteAllAgentCapabilitiesRequest {
    agentId: number;
}

export interface DeleteCapabilityRequest {
    name: string;
    configurationId: number;
}

export interface DeleteConfigurationRequest {
    configurationId: number;
}

export interface DeleteDeploymentProjectRequest {
    deploymentProjectId: string;
}

export interface DeleteGlobalVariableRequest {
    variableId: string;
}

export interface DeleteProjectRequest {
    projectKey: string;
}

export interface DeleteProjectSharedCredentialsRequest {
    projectKey: string;
    sharedCredentialId: string;
}

export interface DeleteProjectVariableRequest {
    projectKey: string;
    variableName: string;
}

export interface DeleteQuickFilterRequest {
    id: number;
}

export interface DeleteRepositoryMappingRequest {
    repositoryId: string;
    deploymentProjectId: string;
}

export interface DeleteRepositoryMapping1Request {
    projectKey: string;
    repositoryId: string;
}

export interface DeleteTemplateConfigurationRequest {
    configurationId: number;
}

export interface DisableAgentRequest {
    agentId: number;
}

export interface EditDeploymentProjectRequest {
    deploymentProjectId: string;
    restUpdateDeploymentProjectRequest: RestUpdateDeploymentProjectRequest;
}

export interface EnableAgentRequest {
    agentId: number;
}

export interface EnableAllProjectsAccessRequest {
    repositoryId: number;
    restEnableContainer: RestEnableContainer;
}

export interface EnableAllRepositoriesAccessRequest {
    projectKey: string;
    repositoryId: number;
    restEnableContainer: RestEnableContainer;
}

export interface EnableAllRepositoriesAccess1Request {
    repositoryId: number;
    restEnableContainer: RestEnableContainer;
}

export interface EnableCiRequest {
    repositoryId: number;
    restEnableContainer: RestEnableContainer;
}

export interface EnableProjectCreationRequest {
    repositoryId: number;
    restEnableContainer: RestEnableContainer;
}

export interface EncryptRequest {
    manualEncryptionRequest: ManualEncryptionRequest;
}

export interface ExportDeploymentSpecRequest {
    deploymentProjectId: string;
    _package?: string;
    format?: string;
}

export interface ExportProjectSpecsRequest {
    projectKey: string;
    _package?: string;
    format?: ExportProjectSpecsFormatEnum;
}

export interface FindPlansWithCustomExpirySettingsRequest {
    limit?: number;
    start?: number;
}

export interface FindRepositoryRequest {
    searchTerm?: string;
}

export interface FindUsageRequest {
    repositoryId: number;
    maxPlans?: number;
    maxEnvironments?: number;
}

export interface GetRequest {
    key: string;
}

export interface GetAgentAuthenticationsRequest {
    pending?: boolean;
}

export interface GetAgentByIdRequest {
    agentId: string;
}

export interface GetAgentCapabilitiesRequest {
    agentId: number;
    includeShared?: boolean;
}

export interface GetAgentInformationRequest {
    agentId: number;
    maxResult?: number;
    expand?: string;
    includeShared?: boolean;
    startIndex?: number;
}

export interface GetAgentStatusRequest {
    agentId: number;
}

export interface GetAgents1Request {
    online?: boolean;
}

export interface GetAllCapabilitiesOnServerRequest {
    maxResult?: number;
    searchTerm?: string;
    lastGroup?: string;
    startIndex?: number;
}

export interface GetAvailableReportsRequest {
    maxResult?: number;
    expand?: string;
    startIndex?: number;
}

export interface GetBranchHistoryRequest {
    buildKey: string;
    branchName: string;
    projectKey: string;
    includeAllStates?: boolean;
    continuable?: boolean;
    issueKey?: string;
    maxResults?: number;
    startIndex?: number;
    label?: string;
    buildstate?: string;
    favourite?: string;
    expand?: string;
    lifeCycleState?: string;
}

export interface GetBrokenBuildsForUserRequest {
    name: string;
    showAllResponsible?: string;
}

export interface GetBuildRequest {
    projectKey: string;
    buildKey: string;
    buildNumber: string;
    expand?: string;
    buildPositions?: string;
}

export interface GetBuildAliasRequest {
    projectKey: string;
    buildKey: string;
    buildNumber: string;
    expand?: string;
}

export interface GetBuildCommentsRequest {
    projectKey: string;
    buildKey: string;
    buildNumber: string;
}

export interface GetBuildHistoryRequest {
    projectKey: string;
    buildKey: string;
    includeAllStates?: boolean;
    continuable?: boolean;
    expand?: string;
    issueKey?: string;
    maxResults?: number;
    startIndex?: number;
    label?: string;
    buildstate?: string;
    favourite?: string;
    lifeCycleState?: string;
}

export interface GetBuildLabelsRequest {
    projectKey: string;
    buildKey: string;
    buildNumber: string;
}

export interface GetBuildQueue1Request {
    maxResult?: number;
    startIndex?: number;
}

export interface GetBuildResultsForChangesetRequest {
    csid: string;
}

export interface GetBuildResultsForCheckoutChangesetRequest {
    csid: string;
}

export interface GetCapabilitiesRequest {
    configurationId: number;
}

export interface GetCloneRequest {
    projectKey: string;
    buildKey: string;
    toBuildKey: string;
    toProjectKey: string;
}

export interface GetConfiguration2Request {
    configurationId: number;
}

export interface GetDeploymentNamingPreviewRequest {
    deploymentProjectId: string;
    nextVersionName: string;
    incrementableVariables?: string;
    incrementNumbers?: string;
}

export interface GetDeploymentProjectRequest {
    projectId: string;
}

export interface GetDeploymentProject1Request {
    deploymentProjectId: string;
}

export interface GetDeploymentProjectVariablesRequest {
    deploymentProjectId: string;
}

export interface GetDeploymentProjectVersionsRequest {
    deploymentProjectId: string;
    branchKey?: string;
}

export interface GetDeploymentProjectsRequest {
    filter?: string;
    limit?: number;
    start?: number;
}

export interface GetDeploymentProjectsForPlanRequest {
    planKey: string;
}

export interface GetDeploymentResultRequest {
    deploymentResultId: string;
    includeLogs?: string;
}

export interface GetEnvironmentStatutesRequest {
    environmentIds: EnvironmentIds;
}

export interface GetEphemeralAgentPodLogsRequest {
    pod: string;
    containerName?: string;
    limit?: string;
    afterTimestamp?: string;
}

export interface GetEphemeralAgentPodRawLogsRequest {
    pod: string;
    containerName?: string;
}

export interface GetFaviconForPlanRequest {
    planKey: string;
}

export interface GetForUserRequest {
    userName: string;
    key: string;
}

export interface GetGlobalVariableRequest {
    variableId: string;
}

export interface GetGroupRequest {
    name: string;
}

export interface GetImageUrlRequest {
    buildKeys?: string;
    reportKey?: string;
}

export interface GetInstanceLogRequest {
    instanceId: string;
}

export interface GetJiraIssueStatusForProjectRequest {
    issueKey: string;
}

export interface GetJiraIssueStatusForProject1Request {
    issueKey: string;
    deploymentProjectId: string;
}

export interface GetLatestBuildResultsRequest {
    includeAllStates?: boolean;
    continuable?: boolean;
    expand?: string;
    issueKey?: string;
    maxResults?: number;
    startIndex?: number;
    label?: string;
    buildstate?: string;
    favourite?: string;
    lifeCycleState?: string;
}

export interface GetLatestBuildResultsForProjectRequest {
    projectKey: string;
    includeAllStates?: boolean;
    continuable?: boolean;
    expand?: string;
    issueKey?: string;
    maxResults?: number;
    startIndex?: number;
    label?: string;
    buildstate?: string;
    favourite?: string;
    lifeCycleState?: string;
}

export interface GetLatestVersionStatusRequest {
    deploymentVersionId: string;
}

export interface GetNextDeploymentVersionsRequest {
    deploymentProjectId: string;
    resultKey?: string;
}

export interface GetPaginateDeploymentProjectRequest {
    projectId: string;
    filter?: string;
    limit?: number;
    start?: string;
}

export interface GetPaginatedProjectRepositoriesRequest {
    projectKey: string;
    filter?: string;
    limit?: number;
    start?: number;
}

export interface GetPaginatedProjectSharedCredentialsRequest {
    projectKey: string;
    filter?: string;
    limit?: number;
    start?: number;
}

export interface GetPlanSummaryRequest {
    buildKeys?: string;
}

export interface GetProjectRequest {
    projectKey: string;
    expand?: string;
    showEmpty?: boolean;
}

export interface GetProjectVariableRequest {
    projectKey: string;
    variableName: string;
}

export interface GetProjectVariablesRequest {
    projectKey: string;
}

export interface GetProjectsRequest {
    expand?: string;
    showEmpty?: boolean;
}

export interface GetQuickFilterRequest {
    id: number;
}

export interface GetQuickFiltersRequest {
    configured?: boolean;
}

export interface GetRemoteAgentsRequest {
    online?: boolean;
}

export interface GetResponsibleForPlanResultRequest {
    name: string;
    planResultKeyOrPlanKey: string;
}

export interface GetResultStatusRequest {
    projectKey: string;
    buildKey: string;
    buildNumber: string;
}

export interface GetRssRepositoriesAllowedToAccessRepositoryRequest {
    repositoryId: number;
}

export interface GetSpecsDetectionStatusRequest {
    repositoryId: number;
    maxResult?: number;
    branch?: string;
}

export interface GetTemplateConfigurationRequest {
    configurationId: number;
}

export interface GetTemplateConfigurationsPageRequest {
    filter?: string;
}

export interface GetVariablesFromNameRequest {
    deploymentProjectId: string;
    nextVersionName: string;
}

export interface GetVersionAndPlanResultRequest {
    deploymentVersionId: string;
}

export interface GrantRssRepositoryAccessRequest {
    repositoryId: number;
    restIdContainer: RestIdContainer;
}

export interface ListAssignedRepositoriesRequest {
    deploymentProjectId: string;
}

export interface ListAssignedRepositories1Request {
    projectKey: string;
}

export interface PutRequest {
    userName: string;
    key: string;
    restDarkFeature: RestDarkFeature;
}

export interface Put1Request {
    key: string;
    restDarkFeature: RestDarkFeature;
}

export interface RemoveBuildCommentRequest {
    projectKey: string;
    buildKey: string;
    commentId: string;
    buildNumber: string;
}

export interface RemoveBuildLabelRequest {
    projectKey: string;
    buildKey: string;
    labelName: string;
    buildNumber: string;
}

export interface RemovePlanCustomExpirySettingsRequest {
    planKey: string;
}

export interface RemoveResponsibleRequest {
    name: string;
    planResultKeyOrPlanKey: string;
}

export interface RevokePermissionToUseRepositoryByRssRepoRequest {
    repositoryId: number;
    targetRepositoryId: number;
}

export interface SaveConfigurationRequest {
    ephemeralAgentsConfigurationDTO: EphemeralAgentsConfigurationDTO;
}

export interface SearchRequest {
    searchTerm?: string;
    searchEntity?: SearchSearchEntityEnum;
}

export interface SearchAuthorsRequest {
    searchTerm: string;
    maxResult?: number;
    unlinkedOnly?: boolean;
    startIndex?: number;
}

export interface SearchAvailableRepositoriesRequest {
    deploymentProjectId: string;
    maxResult?: number;
    searchTerm?: string;
    startIndex?: number;
}

export interface SearchAvailableRepositories1Request {
    projectKey: string;
    searchTerm?: string;
}

export interface SearchAvailableRepositories2Request {
    repositoryId: number;
    searchTerm?: string;
}

export interface SearchBranchesRequest {
    masterPlanKey: string;
    maxResult?: number;
    searchTerm?: string;
    includeMasterBranch?: boolean;
    startIndex?: number;
    branchNameOnly?: boolean;
    fuzzy?: boolean;
    releasedInDeployment?: number;
}

export interface SearchDeploymentsRequest {
    maxResult?: number;
    searchTerm?: string;
    startIndex?: number;
    permission?: SearchDeploymentsPermissionEnum;
}

export interface SearchForAvailablePlanChildDependenciesRequest {
    projectKey: string;
    searchTerm: string;
    buildKey: string;
    maxResult?: number;
    startIndex?: number;
}

export interface SearchForAvailablePlanParentDependenciesRequest {
    projectKey: string;
    searchTerm: string;
    buildKey: string;
    maxResult?: number;
    startIndex?: number;
}

export interface SearchJobsRequest {
    planKey: string;
    maxResult?: number;
    searchTerm?: string;
    startIndex?: number;
}

export interface SearchPlansRequest {
    maxResult?: number;
    searchTerm?: string;
    startIndex?: number;
    permission?: SearchPlansPermissionEnum;
    type?: SearchPlansTypeEnum;
    fuzzy?: boolean;
}

export interface SearchProjectsRequest {
    maxResult?: number;
    searchTerm?: string;
    startIndex?: number;
    permission?: SearchProjectsPermissionEnum;
}

export interface SearchSpecsBranchesRequest {
    repositoryId: number;
    searchTerm?: string;
}

export interface SearchStagesRequest {
    planKey: string;
    maxResult?: number;
    searchTerm?: string;
    startIndex?: number;
    stageId?: string;
}

export interface SearchUsersRequest {
    searchTerm: string;
    maxResult?: number;
    includeAvatars?: boolean;
    startIndex?: number;
}

export interface SearchVersionsRequest {
    deploymentProjectId: number;
    maxResult?: number;
    branchKey?: string;
    searchTerm?: string;
    startIndex?: number;
    chronologicalOrder?: boolean;
}

export interface SetConfigurationRequest {
    restCombinedExpiryConfiguration: RestCombinedExpiryConfiguration;
}

export interface SetVisibleFiltersRequest {
    requestBody: Array<number>;
}

export interface StartBuildOperationRequest {
    projectKey: string;
    buildKey: string;
    executeAllStages?: boolean;
    customRevision?: string;
    stage?: string;
    startBuildRequest?: StartBuildRequest;
}

export interface StopBuildRequest {
    projectKey: string;
    buildKey: string;
    buildNumber: number;
}

export interface TestConnectionRequest {
    ephemeralAgentsConfigurationDTO: EphemeralAgentsConfigurationDTO;
}

export interface TestConnection1Request {
    body?: object;
}

export interface TriggerJobRequest {
    restScheduledJob: RestScheduledJob;
}

export interface TriggerSpecsScanningRequest {
    name?: string;
    repositoryId?: number;
    id?: number;
    repositoryName?: string;
}

export interface TriggerSpecsScanning1Request {
    repositoryId: number;
    branch?: string;
}

export interface UpdateAgentCapabilityRequest {
    agentId: number;
    capabilityKey: string;
    restRemoteAgentCapability: RestRemoteAgentCapability;
}

export interface UpdateAgentLocalHandlerRequest {
    restArtifactHandler: RestArtifactHandler;
}

export interface UpdateAllImageIdsRequest {
    imageId: string;
    newImageId: string;
}

export interface UpdateAuditLogConfigurationRequest {
    restAuditLogConfiguration: RestAuditLogConfiguration;
}

export interface UpdateBambooRemoteHandlerRequest {
    simpleRestArtifactHandler: SimpleRestArtifactHandler;
}

export interface UpdateCapabilityRequest {
    configurationId: number;
    restCapability: RestCapability;
}

export interface UpdateConfigurationRequest {
    configurationId: number;
    restElasticImageConfig: RestElasticImageConfig;
}

export interface UpdateGeneralConfigurationRequest {
    restGeneralConfiguration: RestGeneralConfiguration;
}

export interface UpdateGlobalVariableRequest {
    variableId: string;
    restGlobalVariable: RestGlobalVariable;
}

export interface UpdateIMServerConfigRequest {
    restIMServerConfiguration: RestIMServerConfiguration;
}

export interface UpdateMailConfigurationRequest {
    restMailConfiguration: RestMailConfiguration;
}

export interface UpdateQuarantineSettingsRequest {
    restQuarantineConfig: RestQuarantineConfig;
}

export interface UpdateQuickFilterRequest {
    id: number;
    restQuickFilter: RestQuickFilter;
}

export interface UpdateRemoteAgentConfigurationRequest {
    restRemoteAgentConfiguration: RestRemoteAgentConfiguration;
}

export interface UpdateRestAgentRequest {
    agentId: string;
    restAgent: RestAgent;
}

export interface UpdateRestBuildConcurrencyRequest {
    restBuildConcurrency: RestBuildConcurrency;
}

export interface UpdateRestBuildMonitoringRequest {
    restBuildMonitoring: RestBuildMonitoring;
}

export interface UpdateRestElasticConfigurationRequest {
    restElasticConfiguration: RestElasticConfiguration;
}

export interface UpdateRestSecuritySettingsRequest {
    restSecuritySettings: RestSecuritySettings;
}

export interface UpdateS3HandlerRequest {
    restArtifactHandler: RestArtifactHandler;
}

export interface UpdateSftpHandlerRequest {
    simpleRestArtifactHandler: SimpleRestArtifactHandler;
}

export interface UpdateTemplateConfigurationRequest {
    configurationId: number;
    restEphemeralAgentTemplate: RestEphemeralAgentTemplate;
}

export interface UpdateVersionStatusRequest {
    deploymentVersionId: string;
    newStatus: string;
}

export interface VerifyGlobalVariableValueRequest {
    restVerificationRequest: RestVerificationRequest;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Activates a quick filter for currently logged in user.
     */
    async activateFilterRaw(requestParameters: ActivateFilterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling activateFilter.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/quickFilter/{id}/activate`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Activates a quick filter for currently logged in user.
     */
    async activateFilter(requestParameters: ActivateFilterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.activateFilterRaw(requestParameters, initOverrides);
    }

    /**
     * Grant permission to create/edit plan in given deployment project by Bamboo Specs from given repository.
     */
    async addAssignedRepositoryRaw(requestParameters: AddAssignedRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryMinimal>> {
        if (requestParameters.deploymentProjectId === null || requestParameters.deploymentProjectId === undefined) {
            throw new runtime.RequiredError('deploymentProjectId','Required parameter requestParameters.deploymentProjectId was null or undefined when calling addAssignedRepository.');
        }

        if (requestParameters.restIdContainer === null || requestParameters.restIdContainer === undefined) {
            throw new runtime.RequiredError('restIdContainer','Required parameter requestParameters.restIdContainer was null or undefined when calling addAssignedRepository.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/deploy/project/{deploymentProjectId}/repository`.replace(`{${"deploymentProjectId"}}`, encodeURIComponent(String(requestParameters.deploymentProjectId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restIdContainer,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Grant permission to create/edit plan in given deployment project by Bamboo Specs from given repository.
     */
    async addAssignedRepository(requestParameters: AddAssignedRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryMinimal> {
        const response = await this.addAssignedRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Grant permission to create/edit plan in given project by Bamboo Specs from given repository.
     */
    async addAssignedRepository1Raw(requestParameters: AddAssignedRepository1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryMinimal>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling addAssignedRepository1.');
        }

        if (requestParameters.restIdContainer === null || requestParameters.restIdContainer === undefined) {
            throw new runtime.RequiredError('restIdContainer','Required parameter requestParameters.restIdContainer was null or undefined when calling addAssignedRepository1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/xml';

        const response = await this.request({
            path: `/api/latest/project/{projectKey}/repository`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restIdContainer,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Grant permission to create/edit plan in given project by Bamboo Specs from given repository.
     */
    async addAssignedRepository1(requestParameters: AddAssignedRepository1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryMinimal> {
        const response = await this.addAssignedRepository1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Adds new comment to build result.
     */
    async addBuildCommentRaw(requestParameters: AddBuildCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling addBuildComment.');
        }

        if (requestParameters.buildKey === null || requestParameters.buildKey === undefined) {
            throw new runtime.RequiredError('buildKey','Required parameter requestParameters.buildKey was null or undefined when calling addBuildComment.');
        }

        if (requestParameters.buildNumber === null || requestParameters.buildNumber === undefined) {
            throw new runtime.RequiredError('buildNumber','Required parameter requestParameters.buildNumber was null or undefined when calling addBuildComment.');
        }

        if (requestParameters.createCommentRequest === null || requestParameters.createCommentRequest === undefined) {
            throw new runtime.RequiredError('createCommentRequest','Required parameter requestParameters.createCommentRequest was null or undefined when calling addBuildComment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/xml';

        const response = await this.request({
            path: `/api/latest/result/{projectKey}-{buildKey}-{buildNumber}/comment`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters.buildKey))).replace(`{${"buildNumber"}}`, encodeURIComponent(String(requestParameters.buildNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.createCommentRequest,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Adds new comment to build result.
     */
    async addBuildComment(requestParameters: AddBuildCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.addBuildCommentRaw(requestParameters, initOverrides);
    }

    /**
     * Adds new label to build result specified by projectKey-buildKey-buildNumber.
     */
    async addBuildLabelRaw(requestParameters: AddBuildLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling addBuildLabel.');
        }

        if (requestParameters.buildKey === null || requestParameters.buildKey === undefined) {
            throw new runtime.RequiredError('buildKey','Required parameter requestParameters.buildKey was null or undefined when calling addBuildLabel.');
        }

        if (requestParameters.buildNumber === null || requestParameters.buildNumber === undefined) {
            throw new runtime.RequiredError('buildNumber','Required parameter requestParameters.buildNumber was null or undefined when calling addBuildLabel.');
        }

        if (requestParameters.restBuildLabel === null || requestParameters.restBuildLabel === undefined) {
            throw new runtime.RequiredError('restBuildLabel','Required parameter requestParameters.restBuildLabel was null or undefined when calling addBuildLabel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/xml';

        const response = await this.request({
            path: `/api/latest/result/{projectKey}-{buildKey}-{buildNumber}/label`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters.buildKey))).replace(`{${"buildNumber"}}`, encodeURIComponent(String(requestParameters.buildNumber))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restBuildLabel,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Adds new label to build result specified by projectKey-buildKey-buildNumber.
     */
    async addBuildLabel(requestParameters: AddBuildLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.addBuildLabelRaw(requestParameters, initOverrides);
    }

    /**
     * Add ephemeral agent template capability.
     */
    async addCapabilityRaw(requestParameters: AddCapabilityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.configurationId === null || requestParameters.configurationId === undefined) {
            throw new runtime.RequiredError('configurationId','Required parameter requestParameters.configurationId was null or undefined when calling addCapability.');
        }

        if (requestParameters.restCapability === null || requestParameters.restCapability === undefined) {
            throw new runtime.RequiredError('restCapability','Required parameter requestParameters.restCapability was null or undefined when calling addCapability.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/ephemeral/templateConfiguration/{configurationId}/capability`.replace(`{${"configurationId"}}`, encodeURIComponent(String(requestParameters.configurationId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restCapability,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add ephemeral agent template capability.
     */
    async addCapability(requestParameters: AddCapabilityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.addCapabilityRaw(requestParameters, initOverrides);
    }

    /**
     * Create deployment project.
     */
    async addDeploymentProjectRaw(requestParameters: AddDeploymentProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDeploymentProject>> {
        if (requestParameters.restCreateDeploymentProjectRequest === null || requestParameters.restCreateDeploymentProjectRequest === undefined) {
            throw new runtime.RequiredError('restCreateDeploymentProjectRequest','Required parameter requestParameters.restCreateDeploymentProjectRequest was null or undefined when calling addDeploymentProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/deploy/project`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restCreateDeploymentProjectRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create deployment project.
     */
    async addDeploymentProject(requestParameters: AddDeploymentProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDeploymentProject> {
        const response = await this.addDeploymentProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add a responsible user for broken build.
     */
    async addResponsibleRaw(requestParameters: AddResponsibleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling addResponsible.');
        }

        if (requestParameters.planResultKeyOrPlanKey === null || requestParameters.planResultKeyOrPlanKey === undefined) {
            throw new runtime.RequiredError('planResultKeyOrPlanKey','Required parameter requestParameters.planResultKeyOrPlanKey was null or undefined when calling addResponsible.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/responsibility/latest/brokenBuild/{planResultKeyOrPlanKey}/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"planResultKeyOrPlanKey"}}`, encodeURIComponent(String(requestParameters.planResultKeyOrPlanKey))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add a responsible user for broken build.
     */
    async addResponsible(requestParameters: AddResponsibleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.addResponsibleRaw(requestParameters, initOverrides);
    }

    /**
     * Authenticates a pending agent with the given UUID. If the agent has already been authenticated, the call will not      * change it\'s state.
     */
    async authenticateAgentRaw(requestParameters: AuthenticateAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.agentUuid === null || requestParameters.agentUuid === undefined) {
            throw new runtime.RequiredError('agentUuid','Required parameter requestParameters.agentUuid was null or undefined when calling authenticateAgent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/agent/authentication/{agentUuid}`.replace(`{${"agentUuid"}}`, encodeURIComponent(String(requestParameters.agentUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Authenticates a pending agent with the given UUID. If the agent has already been authenticated, the call will not      * change it\'s state.
     */
    async authenticateAgent(requestParameters: AuthenticateAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.authenticateAgentRaw(requestParameters, initOverrides);
    }

    /**
     * Continue partially done build.  Effectively, this method adds build to the build queue, so is not guarantied that build would be executed immediately. Depending on currently executed builds and length of build queue, build may be executed when queue would be drained. Additional variables could be passed to this method only query parameters (variableName=variableValue). Variables defined in Bamboo as global variables or plan variables MUST be prefixed with bamboo.variable ie. bamboo.variable.myVariable=valueForMyVariable. When global or plan variables would be passed to this method, will override values valid for previous build execution (override).
     */
    async continueBuildRaw(requestParameters: ContinueBuildRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestQueuedBuild>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling continueBuild.');
        }

        if (requestParameters.buildKey === null || requestParameters.buildKey === undefined) {
            throw new runtime.RequiredError('buildKey','Required parameter requestParameters.buildKey was null or undefined when calling continueBuild.');
        }

        if (requestParameters.buildNumber === null || requestParameters.buildNumber === undefined) {
            throw new runtime.RequiredError('buildNumber','Required parameter requestParameters.buildNumber was null or undefined when calling continueBuild.');
        }

        const queryParameters: any = {};

        if (requestParameters.executeAllStages !== undefined) {
            queryParameters['executeAllStages'] = requestParameters.executeAllStages;
        }

        if (requestParameters.stage !== undefined) {
            queryParameters['stage'] = requestParameters.stage;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/queue/{projectKey}-{buildKey}-{buildNumber}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters.buildKey))).replace(`{${"buildNumber"}}`, encodeURIComponent(String(requestParameters.buildNumber))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Continue partially done build.  Effectively, this method adds build to the build queue, so is not guarantied that build would be executed immediately. Depending on currently executed builds and length of build queue, build may be executed when queue would be drained. Additional variables could be passed to this method only query parameters (variableName=variableValue). Variables defined in Bamboo as global variables or plan variables MUST be prefixed with bamboo.variable ie. bamboo.variable.myVariable=valueForMyVariable. When global or plan variables would be passed to this method, will override values valid for previous build execution (override).
     */
    async continueBuild(requestParameters: ContinueBuildRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestQueuedBuild> {
        const response = await this.continueBuildRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create new agent capability.
     */
    async createAgentCapabilityRaw(requestParameters: CreateAgentCapabilityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.agentId === null || requestParameters.agentId === undefined) {
            throw new runtime.RequiredError('agentId','Required parameter requestParameters.agentId was null or undefined when calling createAgentCapability.');
        }

        if (requestParameters.restCapability === null || requestParameters.restCapability === undefined) {
            throw new runtime.RequiredError('restCapability','Required parameter requestParameters.restCapability was null or undefined when calling createAgentCapability.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/agent/{agentId}/capability`.replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters.agentId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restCapability,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create new agent capability.
     */
    async createAgentCapability(requestParameters: CreateAgentCapabilityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createAgentCapabilityRaw(requestParameters, initOverrides);
    }

    /**
     * Create a single global variable.
     */
    async createGlobalVariableRaw(requestParameters: CreateGlobalVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestGlobalVariable>> {
        if (requestParameters.restGlobalVariable === null || requestParameters.restGlobalVariable === undefined) {
            throw new runtime.RequiredError('restGlobalVariable','Required parameter requestParameters.restGlobalVariable was null or undefined when calling createGlobalVariable.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/globalVariables`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restGlobalVariable,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a single global variable.
     */
    async createGlobalVariable(requestParameters: CreateGlobalVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestGlobalVariable> {
        const response = await this.createGlobalVariableRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a group.
     */
    async createGroupRaw(requestParameters: CreateGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestGroup>> {
        if (requestParameters.restGroup === null || requestParameters.restGroup === undefined) {
            throw new runtime.RequiredError('restGroup','Required parameter requestParameters.restGroup was null or undefined when calling createGroup.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/security/groups`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restGroup,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a group.
     */
    async createGroup(requestParameters: CreateGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestGroup> {
        const response = await this.createGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create elastic image configuration.
     */
    async createImageConfigurationRaw(requestParameters: CreateImageConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestElasticImageConfig>> {
        if (requestParameters.restElasticImageConfig === null || requestParameters.restElasticImageConfig === undefined) {
            throw new runtime.RequiredError('restElasticImageConfig','Required parameter requestParameters.restElasticImageConfig was null or undefined when calling createImageConfiguration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/elasticConfiguration`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restElasticImageConfig,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create elastic image configuration.
     */
    async createImageConfiguration(requestParameters: CreateImageConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestElasticImageConfig> {
        const response = await this.createImageConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create or update project variable.
     */
    async createOrUpdateVariableRaw(requestParameters: CreateOrUpdateVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestVariableDefinitionContext>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling createOrUpdateVariable.');
        }

        if (requestParameters.restVariable === null || requestParameters.restVariable === undefined) {
            throw new runtime.RequiredError('restVariable','Required parameter requestParameters.restVariable was null or undefined when calling createOrUpdateVariable.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/xml';

        const response = await this.request({
            path: `/api/latest/project/{projectKey}/variable`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restVariable,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create or update project variable.
     */
    async createOrUpdateVariable(requestParameters: CreateOrUpdateVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestVariableDefinitionContext> {
        const response = await this.createOrUpdateVariableRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create project.
     */
    async createProjectRaw(requestParameters: CreateProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestProject>> {
        if (requestParameters.restProject === null || requestParameters.restProject === undefined) {
            throw new runtime.RequiredError('restProject','Required parameter requestParameters.restProject was null or undefined when calling createProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/xml';

        const response = await this.request({
            path: `/api/latest/project`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restProject,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create project.
     */
    async createProject(requestParameters: CreateProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestProject> {
        const response = await this.createProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new quick filter with basic configuration, e.g. name or position on list. This method does not allow to configure quick filter\'s rules.
     */
    async createQuickFilterRaw(requestParameters: CreateQuickFilterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestQuickFilter>> {
        if (requestParameters.restQuickFilter === null || requestParameters.restQuickFilter === undefined) {
            throw new runtime.RequiredError('restQuickFilter','Required parameter requestParameters.restQuickFilter was null or undefined when calling createQuickFilter.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/quickFilter`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restQuickFilter,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create a new quick filter with basic configuration, e.g. name or position on list. This method does not allow to configure quick filter\'s rules.
     */
    async createQuickFilter(requestParameters: CreateQuickFilterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestQuickFilter> {
        const response = await this.createQuickFilterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create ephemeral template configuration.
     */
    async createTemplateConfigurationRaw(requestParameters: CreateTemplateConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestEphemeralAgentTemplate>> {
        if (requestParameters.restEphemeralAgentTemplate === null || requestParameters.restEphemeralAgentTemplate === undefined) {
            throw new runtime.RequiredError('restEphemeralAgentTemplate','Required parameter requestParameters.restEphemeralAgentTemplate was null or undefined when calling createTemplateConfiguration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/ephemeral/templateConfiguration`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restEphemeralAgentTemplate,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create ephemeral template configuration.
     */
    async createTemplateConfiguration(requestParameters: CreateTemplateConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestEphemeralAgentTemplate> {
        const response = await this.createTemplateConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create deployment version for given deployment project.
     */
    async createVersionRaw(requestParameters: CreateVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDeploymentVersion>> {
        if (requestParameters.deploymentProjectId === null || requestParameters.deploymentProjectId === undefined) {
            throw new runtime.RequiredError('deploymentProjectId','Required parameter requestParameters.deploymentProjectId was null or undefined when calling createVersion.');
        }

        if (requestParameters.restCreateVersionRequest === null || requestParameters.restCreateVersionRequest === undefined) {
            throw new runtime.RequiredError('restCreateVersionRequest','Required parameter requestParameters.restCreateVersionRequest was null or undefined when calling createVersion.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/deploy/project/{deploymentProjectId}/version`.replace(`{${"deploymentProjectId"}}`, encodeURIComponent(String(requestParameters.deploymentProjectId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restCreateVersionRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Create deployment version for given deployment project.
     */
    async createVersion(requestParameters: CreateVersionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDeploymentVersion> {
        const response = await this.createVersionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deactivates all quick filter for currently logged in user.
     */
    async deactivateAllFiltersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/quickFilter/deactivate`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deactivates all quick filter for currently logged in user.
     */
    async deactivateAllFilters(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deactivateAllFiltersRaw(initOverrides);
    }

    /**
     * Deactivates a quick filter for currently logged in user.
     */
    async deactivateFilterRaw(requestParameters: DeactivateFilterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deactivateFilter.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/quickFilter/{id}/deactivate`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deactivates a quick filter for currently logged in user.
     */
    async deactivateFilter(requestParameters: DeactivateFilterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deactivateFilterRaw(requestParameters, initOverrides);
    }

    /**
     * Remove build agent.
     */
    async deleteAgentRaw(requestParameters: DeleteAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.agentId === null || requestParameters.agentId === undefined) {
            throw new runtime.RequiredError('agentId','Required parameter requestParameters.agentId was null or undefined when calling deleteAgent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/agent/{agentId}`.replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters.agentId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove build agent.
     */
    async deleteAgent(requestParameters: DeleteAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAgentRaw(requestParameters, initOverrides);
    }

    /**
     * Remove build agent capability.
     */
    async deleteAgentCapabilityRaw(requestParameters: DeleteAgentCapabilityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.agentId === null || requestParameters.agentId === undefined) {
            throw new runtime.RequiredError('agentId','Required parameter requestParameters.agentId was null or undefined when calling deleteAgentCapability.');
        }

        if (requestParameters.capabilityKey === null || requestParameters.capabilityKey === undefined) {
            throw new runtime.RequiredError('capabilityKey','Required parameter requestParameters.capabilityKey was null or undefined when calling deleteAgentCapability.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/agent/{agentId}/capability/{capabilityKey}`.replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters.agentId))).replace(`{${"capabilityKey"}}`, encodeURIComponent(String(requestParameters.capabilityKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove build agent capability.
     */
    async deleteAgentCapability(requestParameters: DeleteAgentCapabilityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAgentCapabilityRaw(requestParameters, initOverrides);
    }

    /**
     * Remove all capabilities of build agent.
     */
    async deleteAllAgentCapabilitiesRaw(requestParameters: DeleteAllAgentCapabilitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.agentId === null || requestParameters.agentId === undefined) {
            throw new runtime.RequiredError('agentId','Required parameter requestParameters.agentId was null or undefined when calling deleteAllAgentCapabilities.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/agent/{agentId}/capability`.replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters.agentId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove all capabilities of build agent.
     */
    async deleteAllAgentCapabilities(requestParameters: DeleteAllAgentCapabilitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAllAgentCapabilitiesRaw(requestParameters, initOverrides);
    }

    /**
     * Remove ephemeral agent template capability.
     */
    async deleteCapabilityRaw(requestParameters: DeleteCapabilityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCapability.');
        }

        if (requestParameters.configurationId === null || requestParameters.configurationId === undefined) {
            throw new runtime.RequiredError('configurationId','Required parameter requestParameters.configurationId was null or undefined when calling deleteCapability.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/ephemeral/templateConfiguration/{configurationId}/capability/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"configurationId"}}`, encodeURIComponent(String(requestParameters.configurationId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove ephemeral agent template capability.
     */
    async deleteCapability(requestParameters: DeleteCapabilityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteCapabilityRaw(requestParameters, initOverrides);
    }

    /**
     * Delete elastic image configuration.
     */
    async deleteConfigurationRaw(requestParameters: DeleteConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.configurationId === null || requestParameters.configurationId === undefined) {
            throw new runtime.RequiredError('configurationId','Required parameter requestParameters.configurationId was null or undefined when calling deleteConfiguration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/elasticConfiguration/{configurationId}`.replace(`{${"configurationId"}}`, encodeURIComponent(String(requestParameters.configurationId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete elastic image configuration.
     */
    async deleteConfiguration(requestParameters: DeleteConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteConfigurationRaw(requestParameters, initOverrides);
    }

    /**
     * Delete deployment project.
     */
    async deleteDeploymentProjectRaw(requestParameters: DeleteDeploymentProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.deploymentProjectId === null || requestParameters.deploymentProjectId === undefined) {
            throw new runtime.RequiredError('deploymentProjectId','Required parameter requestParameters.deploymentProjectId was null or undefined when calling deleteDeploymentProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/project/{deploymentProjectId}`.replace(`{${"deploymentProjectId"}}`, encodeURIComponent(String(requestParameters.deploymentProjectId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete deployment project.
     */
    async deleteDeploymentProject(requestParameters: DeleteDeploymentProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteDeploymentProjectRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a global variable.
     */
    async deleteGlobalVariableRaw(requestParameters: DeleteGlobalVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.variableId === null || requestParameters.variableId === undefined) {
            throw new runtime.RequiredError('variableId','Required parameter requestParameters.variableId was null or undefined when calling deleteGlobalVariable.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/globalVariables/{variableId}`.replace(`{${"variableId"}}`, encodeURIComponent(String(requestParameters.variableId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a global variable.
     */
    async deleteGlobalVariable(requestParameters: DeleteGlobalVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteGlobalVariableRaw(requestParameters, initOverrides);
    }

    /**
     * Delete current IM Server configuration.
     */
    async deleteIMServerConfigurationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/config/imServer`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete current IM Server configuration.
     */
    async deleteIMServerConfiguration(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteIMServerConfigurationRaw(initOverrides);
    }

    /**
     * Delete current mail configuration.
     */
    async deleteMailConfigurationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/config/mailServer`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete current mail configuration.
     */
    async deleteMailConfiguration(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteMailConfigurationRaw(initOverrides);
    }

    /**
     * Marks project for deletion. Project will be deleted by a batch job.
     */
    async deleteProjectRaw(requestParameters: DeleteProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling deleteProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/project/{projectKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Marks project for deletion. Project will be deleted by a batch job.
     */
    async deleteProject(requestParameters: DeleteProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteProjectRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes shared project credentials specified by id.
     */
    async deleteProjectSharedCredentialsRaw(requestParameters: DeleteProjectSharedCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling deleteProjectSharedCredentials.');
        }

        if (requestParameters.sharedCredentialId === null || requestParameters.sharedCredentialId === undefined) {
            throw new runtime.RequiredError('sharedCredentialId','Required parameter requestParameters.sharedCredentialId was null or undefined when calling deleteProjectSharedCredentials.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/project/{projectKey}/sharedCredentials/{sharedCredentialId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"sharedCredentialId"}}`, encodeURIComponent(String(requestParameters.sharedCredentialId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes shared project credentials specified by id.
     */
    async deleteProjectSharedCredentials(requestParameters: DeleteProjectSharedCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteProjectSharedCredentialsRaw(requestParameters, initOverrides);
    }

    /**
     * Delete the project variable.
     */
    async deleteProjectVariableRaw(requestParameters: DeleteProjectVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling deleteProjectVariable.');
        }

        if (requestParameters.variableName === null || requestParameters.variableName === undefined) {
            throw new runtime.RequiredError('variableName','Required parameter requestParameters.variableName was null or undefined when calling deleteProjectVariable.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/project/{projectKey}/variable/{variableName}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"variableName"}}`, encodeURIComponent(String(requestParameters.variableName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete the project variable.
     */
    async deleteProjectVariable(requestParameters: DeleteProjectVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteProjectVariableRaw(requestParameters, initOverrides);
    }

    /**
     * Delete a quick filter.
     */
    async deleteQuickFilterRaw(requestParameters: DeleteQuickFilterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling deleteQuickFilter.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/quickFilter/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a quick filter.
     */
    async deleteQuickFilter(requestParameters: DeleteQuickFilterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteQuickFilterRaw(requestParameters, initOverrides);
    }

    /**
     * Remove approval to create plans in given deployment project by given repository.
     */
    async deleteRepositoryMappingRaw(requestParameters: DeleteRepositoryMappingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repositoryId === null || requestParameters.repositoryId === undefined) {
            throw new runtime.RequiredError('repositoryId','Required parameter requestParameters.repositoryId was null or undefined when calling deleteRepositoryMapping.');
        }

        if (requestParameters.deploymentProjectId === null || requestParameters.deploymentProjectId === undefined) {
            throw new runtime.RequiredError('deploymentProjectId','Required parameter requestParameters.deploymentProjectId was null or undefined when calling deleteRepositoryMapping.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/project/{deploymentProjectId}/repository/{repositoryId}`.replace(`{${"repositoryId"}}`, encodeURIComponent(String(requestParameters.repositoryId))).replace(`{${"deploymentProjectId"}}`, encodeURIComponent(String(requestParameters.deploymentProjectId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove approval to create plans in given deployment project by given repository.
     */
    async deleteRepositoryMapping(requestParameters: DeleteRepositoryMappingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRepositoryMappingRaw(requestParameters, initOverrides);
    }

    /**
     * Remove approval to create plans in given project by given repository.
     */
    async deleteRepositoryMapping1Raw(requestParameters: DeleteRepositoryMapping1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling deleteRepositoryMapping1.');
        }

        if (requestParameters.repositoryId === null || requestParameters.repositoryId === undefined) {
            throw new runtime.RequiredError('repositoryId','Required parameter requestParameters.repositoryId was null or undefined when calling deleteRepositoryMapping1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/project/{projectKey}/repository/{repositoryId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"repositoryId"}}`, encodeURIComponent(String(requestParameters.repositoryId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove approval to create plans in given project by given repository.
     */
    async deleteRepositoryMapping1(requestParameters: DeleteRepositoryMapping1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRepositoryMapping1Raw(requestParameters, initOverrides);
    }

    /**
     * Delete ephemeral template configuration.
     */
    async deleteTemplateConfigurationRaw(requestParameters: DeleteTemplateConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.configurationId === null || requestParameters.configurationId === undefined) {
            throw new runtime.RequiredError('configurationId','Required parameter requestParameters.configurationId was null or undefined when calling deleteTemplateConfiguration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/ephemeral/templateConfiguration/{configurationId}`.replace(`{${"configurationId"}}`, encodeURIComponent(String(requestParameters.configurationId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete ephemeral template configuration.
     */
    async deleteTemplateConfiguration(requestParameters: DeleteTemplateConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteTemplateConfigurationRaw(requestParameters, initOverrides);
    }

    /**
     * Disable an agent.
     */
    async disableAgentRaw(requestParameters: DisableAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAgent>> {
        if (requestParameters.agentId === null || requestParameters.agentId === undefined) {
            throw new runtime.RequiredError('agentId','Required parameter requestParameters.agentId was null or undefined when calling disableAgent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/agent/{agentId}/disable`.replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters.agentId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Disable an agent.
     */
    async disableAgent(requestParameters: DisableAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAgent> {
        const response = await this.disableAgentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update deployment project.
     */
    async editDeploymentProjectRaw(requestParameters: EditDeploymentProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDeploymentProject>> {
        if (requestParameters.deploymentProjectId === null || requestParameters.deploymentProjectId === undefined) {
            throw new runtime.RequiredError('deploymentProjectId','Required parameter requestParameters.deploymentProjectId was null or undefined when calling editDeploymentProject.');
        }

        if (requestParameters.restUpdateDeploymentProjectRequest === null || requestParameters.restUpdateDeploymentProjectRequest === undefined) {
            throw new runtime.RequiredError('restUpdateDeploymentProjectRequest','Required parameter requestParameters.restUpdateDeploymentProjectRequest was null or undefined when calling editDeploymentProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/deploy/project/{deploymentProjectId}`.replace(`{${"deploymentProjectId"}}`, encodeURIComponent(String(requestParameters.deploymentProjectId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restUpdateDeploymentProjectRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update deployment project.
     */
    async editDeploymentProject(requestParameters: EditDeploymentProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDeploymentProject> {
        const response = await this.editDeploymentProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Enable an agent.
     */
    async enableAgentRaw(requestParameters: EnableAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAgent>> {
        if (requestParameters.agentId === null || requestParameters.agentId === undefined) {
            throw new runtime.RequiredError('agentId','Required parameter requestParameters.agentId was null or undefined when calling enableAgent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/agent/{agentId}/enable`.replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters.agentId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Enable an agent.
     */
    async enableAgent(requestParameters: EnableAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAgent> {
        const response = await this.enableAgentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Enables access (i.e. allowing modifications) for all Bamboo projects by the Bamboo Specs code stored in this repository. Changes in Bamboo Specs detected will trigger execution of Specs and thus an update of corresponding entities (such as build plans or deployments).
     */
    async enableAllProjectsAccessRaw(requestParameters: EnableAllProjectsAccessRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repositoryId === null || requestParameters.repositoryId === undefined) {
            throw new runtime.RequiredError('repositoryId','Required parameter requestParameters.repositoryId was null or undefined when calling enableAllProjectsAccess.');
        }

        if (requestParameters.restEnableContainer === null || requestParameters.restEnableContainer === undefined) {
            throw new runtime.RequiredError('restEnableContainer','Required parameter requestParameters.restEnableContainer was null or undefined when calling enableAllProjectsAccess.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/repository/{repositoryId}/enableAllProjectsAccess`.replace(`{${"repositoryId"}}`, encodeURIComponent(String(requestParameters.repositoryId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restEnableContainer,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Enables access (i.e. allowing modifications) for all Bamboo projects by the Bamboo Specs code stored in this repository. Changes in Bamboo Specs detected will trigger execution of Specs and thus an update of corresponding entities (such as build plans or deployments).
     */
    async enableAllProjectsAccess(requestParameters: EnableAllProjectsAccessRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enableAllProjectsAccessRaw(requestParameters, initOverrides);
    }

    /**
     * Enables access (i.e. allowing usage) to all project\'s repositories by the Bamboo Specs code stored in this repository.
     */
    async enableAllRepositoriesAccessRaw(requestParameters: EnableAllRepositoriesAccessRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling enableAllRepositoriesAccess.');
        }

        if (requestParameters.repositoryId === null || requestParameters.repositoryId === undefined) {
            throw new runtime.RequiredError('repositoryId','Required parameter requestParameters.repositoryId was null or undefined when calling enableAllRepositoriesAccess.');
        }

        if (requestParameters.restEnableContainer === null || requestParameters.restEnableContainer === undefined) {
            throw new runtime.RequiredError('restEnableContainer','Required parameter requestParameters.restEnableContainer was null or undefined when calling enableAllRepositoriesAccess.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/xml';

        const response = await this.request({
            path: `/api/latest/project/{projectKey}/repository/{repositoryId}/enableAllRepositoriesAccess`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"repositoryId"}}`, encodeURIComponent(String(requestParameters.repositoryId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restEnableContainer,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Enables access (i.e. allowing usage) to all project\'s repositories by the Bamboo Specs code stored in this repository.
     */
    async enableAllRepositoriesAccess(requestParameters: EnableAllRepositoriesAccessRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enableAllRepositoriesAccessRaw(requestParameters, initOverrides);
    }

    /**
     * Enables access (i.e. allowing usage in plans or deployment projects) for all Bamboo linked repositories by the Bamboo Specs code stored in this repository.
     */
    async enableAllRepositoriesAccess1Raw(requestParameters: EnableAllRepositoriesAccess1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repositoryId === null || requestParameters.repositoryId === undefined) {
            throw new runtime.RequiredError('repositoryId','Required parameter requestParameters.repositoryId was null or undefined when calling enableAllRepositoriesAccess1.');
        }

        if (requestParameters.restEnableContainer === null || requestParameters.restEnableContainer === undefined) {
            throw new runtime.RequiredError('restEnableContainer','Required parameter requestParameters.restEnableContainer was null or undefined when calling enableAllRepositoriesAccess1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/repository/{repositoryId}/enableAllRepositoriesAccess`.replace(`{${"repositoryId"}}`, encodeURIComponent(String(requestParameters.repositoryId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restEnableContainer,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Enables access (i.e. allowing usage in plans or deployment projects) for all Bamboo linked repositories by the Bamboo Specs code stored in this repository.
     */
    async enableAllRepositoriesAccess1(requestParameters: EnableAllRepositoriesAccess1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enableAllRepositoriesAccess1Raw(requestParameters, initOverrides);
    }

    /**
     * Enables or disables detection of Bamboo Specs stored in the repository. If enabled, code changes detected in Bamboo Specs in new commits will trigger execution of Bamboo Specs and thus an update of corresponding entities (such as build plans, deployments or permissions).
     */
    async enableCiRaw(requestParameters: EnableCiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repositoryId === null || requestParameters.repositoryId === undefined) {
            throw new runtime.RequiredError('repositoryId','Required parameter requestParameters.repositoryId was null or undefined when calling enableCi.');
        }

        if (requestParameters.restEnableContainer === null || requestParameters.restEnableContainer === undefined) {
            throw new runtime.RequiredError('restEnableContainer','Required parameter requestParameters.restEnableContainer was null or undefined when calling enableCi.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/repository/{repositoryId}/enableCi`.replace(`{${"repositoryId"}}`, encodeURIComponent(String(requestParameters.repositoryId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restEnableContainer,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Enables or disables detection of Bamboo Specs stored in the repository. If enabled, code changes detected in Bamboo Specs in new commits will trigger execution of Bamboo Specs and thus an update of corresponding entities (such as build plans, deployments or permissions).
     */
    async enableCi(requestParameters: EnableCiRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enableCiRaw(requestParameters, initOverrides);
    }

    /**
     * Enables build and deployment project creation by the Bamboo Specs code stored in this repository.
     */
    async enableProjectCreationRaw(requestParameters: EnableProjectCreationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repositoryId === null || requestParameters.repositoryId === undefined) {
            throw new runtime.RequiredError('repositoryId','Required parameter requestParameters.repositoryId was null or undefined when calling enableProjectCreation.');
        }

        if (requestParameters.restEnableContainer === null || requestParameters.restEnableContainer === undefined) {
            throw new runtime.RequiredError('restEnableContainer','Required parameter requestParameters.restEnableContainer was null or undefined when calling enableProjectCreation.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/repository/{repositoryId}/enableProjectCreation`.replace(`{${"repositoryId"}}`, encodeURIComponent(String(requestParameters.repositoryId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restEnableContainer,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Enables build and deployment project creation by the Bamboo Specs code stored in this repository.
     */
    async enableProjectCreation(requestParameters: EnableProjectCreationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.enableProjectCreationRaw(requestParameters, initOverrides);
    }

    /**
     * Encrypts a given text based on the instance specific cipher. Encrypted data can be used i.a. in Repository-stored Specs. Feature can be enabled or disabled in Bamboo security configuration. Number of allowed requests per user is limited and can be modified in Bamboo security configuration.
     */
    async encryptRaw(requestParameters: EncryptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ManualEncryptionResponse>> {
        if (requestParameters.manualEncryptionRequest === null || requestParameters.manualEncryptionRequest === undefined) {
            throw new runtime.RequiredError('manualEncryptionRequest','Required parameter requestParameters.manualEncryptionRequest was null or undefined when calling encrypt.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/encrypt`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.manualEncryptionRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Encrypts a given text based on the instance specific cipher. Encrypted data can be used i.a. in Repository-stored Specs. Feature can be enabled or disabled in Bamboo security configuration. Number of allowed requests per user is limited and can be modified in Bamboo security configuration.
     */
    async encrypt(requestParameters: EncryptRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ManualEncryptionResponse> {
        const response = await this.encryptRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Export a deployment project to Bamboo Specs.
     */
    async exportDeploymentSpecRaw(requestParameters: ExportDeploymentSpecRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.deploymentProjectId === null || requestParameters.deploymentProjectId === undefined) {
            throw new runtime.RequiredError('deploymentProjectId','Required parameter requestParameters.deploymentProjectId was null or undefined when calling exportDeploymentSpec.');
        }

        const queryParameters: any = {};

        if (requestParameters._package !== undefined) {
            queryParameters['package'] = requestParameters._package;
        }

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/project/{deploymentProjectId}/specs`.replace(`{${"deploymentProjectId"}}`, encodeURIComponent(String(requestParameters.deploymentProjectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Export a deployment project to Bamboo Specs.
     */
    async exportDeploymentSpec(requestParameters: ExportDeploymentSpecRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.exportDeploymentSpecRaw(requestParameters, initOverrides);
    }

    /**
     * Export all of the plans for a project to Bamboo specs.
     */
    async exportProjectSpecsRaw(requestParameters: ExportProjectSpecsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling exportProjectSpecs.');
        }

        const queryParameters: any = {};

        if (requestParameters._package !== undefined) {
            queryParameters['package'] = requestParameters._package;
        }

        if (requestParameters.format !== undefined) {
            queryParameters['format'] = requestParameters.format;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/project/{projectKey}/specs`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Export all of the plans for a project to Bamboo specs.
     */
    async exportProjectSpecs(requestParameters: ExportProjectSpecsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.exportProjectSpecsRaw(requestParameters, initOverrides);
    }

    /**
     * Get list of all plans where user has admin permission and which override global expiry settings. If global expiry is not enabled it returns empty response.
     */
    async findPlansWithCustomExpirySettingsRaw(requestParameters: FindPlansWithCustomExpirySettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FindPlansWithCustomExpirySettings200Response>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/expiry/custom/plan`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get list of all plans where user has admin permission and which override global expiry settings. If global expiry is not enabled it returns empty response.
     */
    async findPlansWithCustomExpirySettings(requestParameters: FindPlansWithCustomExpirySettingsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FindPlansWithCustomExpirySettings200Response> {
        const response = await this.findPlansWithCustomExpirySettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for existing linked repositories by name.
     */
    async findRepositoryRaw(requestParameters: FindRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryList>> {
        const queryParameters: any = {};

        if (requestParameters.searchTerm !== undefined) {
            queryParameters['searchTerm'] = requestParameters.searchTerm;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/repository`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Search for existing linked repositories by name.
     */
    async findRepository(requestParameters: FindRepositoryRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryList> {
        const response = await this.findRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for usages of given repository.
     */
    async findUsageRaw(requestParameters: FindUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryUsageModel>> {
        if (requestParameters.repositoryId === null || requestParameters.repositoryId === undefined) {
            throw new runtime.RequiredError('repositoryId','Required parameter requestParameters.repositoryId was null or undefined when calling findUsage.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxPlans !== undefined) {
            queryParameters['max-plans'] = requestParameters.maxPlans;
        }

        if (requestParameters.maxEnvironments !== undefined) {
            queryParameters['max-environments'] = requestParameters.maxEnvironments;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/repository/{repositoryId}/usage`.replace(`{${"repositoryId"}}`, encodeURIComponent(String(requestParameters.repositoryId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Search for usages of given repository.
     */
    async findUsage(requestParameters: FindUsageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryUsageModel> {
        const response = await this.findUsageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves whether a given dark feature key is enabled for this instance.
     */
    async getRaw(requestParameters: GetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDarkFeature>> {
        if (requestParameters.key === null || requestParameters.key === undefined) {
            throw new runtime.RequiredError('key','Required parameter requestParameters.key was null or undefined when calling get.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/darkFeatures/{key}`.replace(`{${"key"}}`, encodeURIComponent(String(requestParameters.key))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves whether a given dark feature key is enabled for this instance.
     */
    async get(requestParameters: GetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDarkFeature> {
        const response = await this.getRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return active quick filters for currently logged in user.
     */
    async getActiveFiltersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestQuickFilter>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/quickFilter/active`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Return active quick filters for currently logged in user.
     */
    async getActiveFilters(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestQuickFilter>> {
        const response = await this.getActiveFiltersRaw(initOverrides);
        return await response.value();
    }

    /**
     * Provides a list of all agent authentication statuses.
     */
    async getAgentAuthenticationsRaw(requestParameters: GetAgentAuthenticationsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestRemoteAgentAuthentication>>> {
        const queryParameters: any = {};

        if (requestParameters.pending !== undefined) {
            queryParameters['pending'] = requestParameters.pending;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/agent/authentication`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Provides a list of all agent authentication statuses.
     */
    async getAgentAuthentications(requestParameters: GetAgentAuthenticationsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestRemoteAgentAuthentication>> {
        const response = await this.getAgentAuthenticationsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a build agent definition by id.
     */
    async getAgentByIdRaw(requestParameters: GetAgentByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAgent>> {
        if (requestParameters.agentId === null || requestParameters.agentId === undefined) {
            throw new runtime.RequiredError('agentId','Required parameter requestParameters.agentId was null or undefined when calling getAgentById.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/config/agents/{agentId}`.replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters.agentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a build agent definition by id.
     */
    async getAgentById(requestParameters: GetAgentByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAgent> {
        const response = await this.getAgentByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List agent\'s capabilities.
     */
    async getAgentCapabilitiesRaw(requestParameters: GetAgentCapabilitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestCapability>>> {
        if (requestParameters.agentId === null || requestParameters.agentId === undefined) {
            throw new runtime.RequiredError('agentId','Required parameter requestParameters.agentId was null or undefined when calling getAgentCapabilities.');
        }

        const queryParameters: any = {};

        if (requestParameters.includeShared !== undefined) {
            queryParameters['includeShared'] = requestParameters.includeShared;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/agent/{agentId}/capability`.replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters.agentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * List agent\'s capabilities.
     */
    async getAgentCapabilities(requestParameters: GetAgentCapabilitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestCapability>> {
        const response = await this.getAgentCapabilitiesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provides details of an agent.
     */
    async getAgentInformationRaw(requestParameters: GetAgentInformationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAgentInformation>> {
        if (requestParameters.agentId === null || requestParameters.agentId === undefined) {
            throw new runtime.RequiredError('agentId','Required parameter requestParameters.agentId was null or undefined when calling getAgentInformation.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResult !== undefined) {
            queryParameters['max-result'] = requestParameters.maxResult;
        }

        if (requestParameters.expand !== undefined) {
            queryParameters['expand'] = requestParameters.expand;
        }

        if (requestParameters.includeShared !== undefined) {
            queryParameters['includeShared'] = requestParameters.includeShared;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['start-index'] = requestParameters.startIndex;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/agent/{agentId}`.replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters.agentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Provides details of an agent.
     */
    async getAgentInformation(requestParameters: GetAgentInformationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAgentInformation> {
        const response = await this.getAgentInformationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve configuration of Agent-Local Artifact Handler.
     */
    async getAgentLocalArtifactHandlerRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestArtifactHandler>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/artifactHandlers/agentLocal`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve configuration of Agent-Local Artifact Handler.
     */
    async getAgentLocalArtifactHandler(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestArtifactHandler> {
        const response = await this.getAgentLocalArtifactHandlerRaw(initOverrides);
        return await response.value();
    }

    /**
     * Provides information about status of agent, if it\'s online or offline.
     */
    async getAgentStatusRaw(requestParameters: GetAgentStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.agentId === null || requestParameters.agentId === undefined) {
            throw new runtime.RequiredError('agentId','Required parameter requestParameters.agentId was null or undefined when calling getAgentStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/agent/{agentId}/status`.replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters.agentId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Provides information about status of agent, if it\'s online or offline.
     */
    async getAgentStatus(requestParameters: GetAgentStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getAgentStatusRaw(requestParameters, initOverrides);
    }

    /**
     * Return collection of all agents of all types.
     */
    async getAgentsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAgents200Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/config/agents`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Return collection of all agents of all types.
     */
    async getAgents(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAgents200Response> {
        const response = await this.getAgentsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Provides a list of agents.
     */
    async getAgents1Raw(requestParameters: GetAgents1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestBuildAgent>>> {
        const queryParameters: any = {};

        if (requestParameters.online !== undefined) {
            queryParameters['online'] = requestParameters.online;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/agent`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Provides a list of agents.
     */
    async getAgents1(requestParameters: GetAgents1Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestBuildAgent>> {
        const response = await this.getAgents1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a list of dark features that are enabled for all users.
     */
    async getAllRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestDarkFeature>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/darkFeatures`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves a list of dark features that are enabled for all users.
     */
    async getAll(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestDarkFeature>> {
        const response = await this.getAllRaw(initOverrides);
        return await response.value();
    }

    /**
     * Fetch all elastic image configurations.
     */
    async getAll1Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestElasticImageConfig>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/elasticConfiguration`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Fetch all elastic image configurations.
     */
    async getAll1(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestElasticImageConfig>> {
        const response = await this.getAll1Raw(initOverrides);
        return await response.value();
    }

    /**
     * Provides a list of capabilities for a select list in the UI.  Filterable and paginable.
     */
    async getAllCapabilitiesOnServerRaw(requestParameters: GetAllCapabilitiesOnServerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters.maxResult !== undefined) {
            queryParameters['max-result'] = requestParameters.maxResult;
        }

        if (requestParameters.searchTerm !== undefined) {
            queryParameters['searchTerm'] = requestParameters.searchTerm;
        }

        if (requestParameters.lastGroup !== undefined) {
            queryParameters['lastGroup'] = requestParameters.lastGroup;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['start-index'] = requestParameters.startIndex;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/capability/groupedListing`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Provides a list of capabilities for a select list in the UI.  Filterable and paginable.
     */
    async getAllCapabilitiesOnServer(requestParameters: GetAllCapabilitiesOnServerRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getAllCapabilitiesOnServerRaw(requestParameters, initOverrides);
    }

    /**
     * Get all deployment projects. This method fetch all deployment projects visible to user. It\'s not optimized for instances with large count of deployment projects and environments, use paged versions instead.
     */
    async getAllDeploymentProjectsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<DashboardProjectWithEnvironmentStatus>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/dashboard`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get all deployment projects. This method fetch all deployment projects visible to user. It\'s not optimized for instances with large count of deployment projects and environments, use paged versions instead.
     */
    async getAllDeploymentProjects(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<DashboardProjectWithEnvironmentStatus>> {
        const response = await this.getAllDeploymentProjectsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Find all deployment projects with environments. Returns only deployment projects and environments visible for user.
     */
    async getAllDeploymentProjects1Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestDeploymentProject>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/project/all`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find all deployment projects with environments. Returns only deployment projects and environments visible for user.
     */
    async getAllDeploymentProjects1(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestDeploymentProject>> {
        const response = await this.getAllDeploymentProjects1Raw(initOverrides);
        return await response.value();
    }

    /**
     * Provides list of available REST resources in Bamboo
     */
    async getAllServicesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestResources>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Provides list of available REST resources in Bamboo
     */
    async getAllServices(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestResources> {
        const response = await this.getAllServicesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve audit log settings.
     */
    async getAuditLogConfigurationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAuditLogConfiguration>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/config/auditLog`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve audit log settings.
     */
    async getAuditLogConfiguration(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAuditLogConfiguration> {
        const response = await this.getAuditLogConfigurationRaw(initOverrides);
        return await response.value();
    }

    /**
     * Fetch available reports list.
     */
    async getAvailableReportsRaw(requestParameters: GetAvailableReportsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestReports>> {
        const queryParameters: any = {};

        if (requestParameters.maxResult !== undefined) {
            queryParameters['max-result'] = requestParameters.maxResult;
        }

        if (requestParameters.expand !== undefined) {
            queryParameters['expand'] = requestParameters.expand;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['start-index'] = requestParameters.startIndex;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/chart/reports`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Fetch available reports list.
     */
    async getAvailableReports(requestParameters: GetAvailableReportsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestReports> {
        const response = await this.getAvailableReportsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve configuration of Bamboo Server Artifact Handler.
     */
    async getBambooRemoteArtifactHandlerRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SimpleRestArtifactHandler>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/artifactHandlers/bambooRemote`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve configuration of Bamboo Server Artifact Handler.
     */
    async getBambooRemoteArtifactHandler(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SimpleRestArtifactHandler> {
        const response = await this.getBambooRemoteArtifactHandlerRaw(initOverrides);
        return await response.value();
    }

    /**
     * Provide list of build results for specified plan\'s branch. Plan might be top level plan (projectKey-planKey) or job plan (projectKey-planKey-jobKey).
     */
    async getBranchHistoryRaw(requestParameters: GetBranchHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestResults>> {
        if (requestParameters.buildKey === null || requestParameters.buildKey === undefined) {
            throw new runtime.RequiredError('buildKey','Required parameter requestParameters.buildKey was null or undefined when calling getBranchHistory.');
        }

        if (requestParameters.branchName === null || requestParameters.branchName === undefined) {
            throw new runtime.RequiredError('branchName','Required parameter requestParameters.branchName was null or undefined when calling getBranchHistory.');
        }

        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getBranchHistory.');
        }

        const queryParameters: any = {};

        if (requestParameters.includeAllStates !== undefined) {
            queryParameters['includeAllStates'] = requestParameters.includeAllStates;
        }

        if (requestParameters.continuable !== undefined) {
            queryParameters['continuable'] = requestParameters.continuable;
        }

        if (requestParameters.issueKey !== undefined) {
            queryParameters['issueKey'] = requestParameters.issueKey;
        }

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max-results'] = requestParameters.maxResults;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['start-index'] = requestParameters.startIndex;
        }

        if (requestParameters.label !== undefined) {
            queryParameters['label'] = requestParameters.label;
        }

        if (requestParameters.buildstate !== undefined) {
            queryParameters['buildstate'] = requestParameters.buildstate;
        }

        if (requestParameters.favourite !== undefined) {
            queryParameters['favourite'] = requestParameters.favourite;
        }

        if (requestParameters.expand !== undefined) {
            queryParameters['expand'] = requestParameters.expand;
        }

        if (requestParameters.lifeCycleState !== undefined) {
            queryParameters['lifeCycleState'] = requestParameters.lifeCycleState;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/result/{projectKey}-{buildKey}/branch/{branchName}`.replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters.buildKey))).replace(`{${"branchName"}}`, encodeURIComponent(String(requestParameters.branchName))).replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Provide list of build results for specified plan\'s branch. Plan might be top level plan (projectKey-planKey) or job plan (projectKey-planKey-jobKey).
     */
    async getBranchHistory(requestParameters: GetBranchHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestResults> {
        const response = await this.getBranchHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get broken builds for user.
     */
    async getBrokenBuildsForUserRaw(requestParameters: GetBrokenBuildsForUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetBrokenBuildsForUser200Response>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getBrokenBuildsForUser.');
        }

        const queryParameters: any = {};

        if (requestParameters.showAllResponsible !== undefined) {
            queryParameters['showAllResponsible'] = requestParameters.showAllResponsible;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/responsibility/latest/brokenBuild/byUser/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get broken builds for user.
     */
    async getBrokenBuildsForUser(requestParameters: GetBrokenBuildsForUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetBrokenBuildsForUser200Response> {
        const response = await this.getBrokenBuildsForUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provide build result specified by projectKey-buildKey-buildNumber.
     */
    async getBuildRaw(requestParameters: GetBuildRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Result>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getBuild.');
        }

        if (requestParameters.buildKey === null || requestParameters.buildKey === undefined) {
            throw new runtime.RequiredError('buildKey','Required parameter requestParameters.buildKey was null or undefined when calling getBuild.');
        }

        if (requestParameters.buildNumber === null || requestParameters.buildNumber === undefined) {
            throw new runtime.RequiredError('buildNumber','Required parameter requestParameters.buildNumber was null or undefined when calling getBuild.');
        }

        const queryParameters: any = {};

        if (requestParameters.expand !== undefined) {
            queryParameters['expand'] = requestParameters.expand;
        }

        if (requestParameters.buildPositions !== undefined) {
            queryParameters['buildPositions'] = requestParameters.buildPositions;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/result/{projectKey}-{buildKey}-{buildNumber}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters.buildKey))).replace(`{${"buildNumber"}}`, encodeURIComponent(String(requestParameters.buildNumber))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Provide build result specified by projectKey-buildKey-buildNumber.
     */
    async getBuild(requestParameters: GetBuildRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Result> {
        const response = await this.getBuildRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provide build result specified by projectKey-buildKey-buildNumber.
     */
    async getBuildAliasRaw(requestParameters: GetBuildAliasRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Result>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getBuildAlias.');
        }

        if (requestParameters.buildKey === null || requestParameters.buildKey === undefined) {
            throw new runtime.RequiredError('buildKey','Required parameter requestParameters.buildKey was null or undefined when calling getBuildAlias.');
        }

        if (requestParameters.buildNumber === null || requestParameters.buildNumber === undefined) {
            throw new runtime.RequiredError('buildNumber','Required parameter requestParameters.buildNumber was null or undefined when calling getBuildAlias.');
        }

        const queryParameters: any = {};

        if (requestParameters.expand !== undefined) {
            queryParameters['expand'] = requestParameters.expand;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/result/{projectKey}-{buildKey}/{buildNumber}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters.buildKey))).replace(`{${"buildNumber"}}`, encodeURIComponent(String(requestParameters.buildNumber))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Provide build result specified by projectKey-buildKey-buildNumber.
     */
    async getBuildAlias(requestParameters: GetBuildAliasRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Result> {
        const response = await this.getBuildAliasRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provide list of comments for build result specified by projectKey-buildKey-buildNumber.
     */
    async getBuildCommentsRaw(requestParameters: GetBuildCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestComments>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getBuildComments.');
        }

        if (requestParameters.buildKey === null || requestParameters.buildKey === undefined) {
            throw new runtime.RequiredError('buildKey','Required parameter requestParameters.buildKey was null or undefined when calling getBuildComments.');
        }

        if (requestParameters.buildNumber === null || requestParameters.buildNumber === undefined) {
            throw new runtime.RequiredError('buildNumber','Required parameter requestParameters.buildNumber was null or undefined when calling getBuildComments.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/result/{projectKey}-{buildKey}-{buildNumber}/comment`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters.buildKey))).replace(`{${"buildNumber"}}`, encodeURIComponent(String(requestParameters.buildNumber))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Provide list of comments for build result specified by projectKey-buildKey-buildNumber.
     */
    async getBuildComments(requestParameters: GetBuildCommentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestComments> {
        const response = await this.getBuildCommentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve build concurrency settings.
     */
    async getBuildConcurrencyRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestBuildConcurrency>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/config/build/concurrency`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve build concurrency settings.
     */
    async getBuildConcurrency(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestBuildConcurrency> {
        const response = await this.getBuildConcurrencyRaw(initOverrides);
        return await response.value();
    }

    /**
     * Provide list of build results for specified plan. Plan might be top level plan (projectKey-planKey) or job plan (projectKey-planKey-jobKey).
     */
    async getBuildHistoryRaw(requestParameters: GetBuildHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestResults>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getBuildHistory.');
        }

        if (requestParameters.buildKey === null || requestParameters.buildKey === undefined) {
            throw new runtime.RequiredError('buildKey','Required parameter requestParameters.buildKey was null or undefined when calling getBuildHistory.');
        }

        const queryParameters: any = {};

        if (requestParameters.includeAllStates !== undefined) {
            queryParameters['includeAllStates'] = requestParameters.includeAllStates;
        }

        if (requestParameters.continuable !== undefined) {
            queryParameters['continuable'] = requestParameters.continuable;
        }

        if (requestParameters.expand !== undefined) {
            queryParameters['expand'] = requestParameters.expand;
        }

        if (requestParameters.issueKey !== undefined) {
            queryParameters['issueKey'] = requestParameters.issueKey;
        }

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max-results'] = requestParameters.maxResults;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['start-index'] = requestParameters.startIndex;
        }

        if (requestParameters.label !== undefined) {
            queryParameters['label'] = requestParameters.label;
        }

        if (requestParameters.buildstate !== undefined) {
            queryParameters['buildstate'] = requestParameters.buildstate;
        }

        if (requestParameters.favourite !== undefined) {
            queryParameters['favourite'] = requestParameters.favourite;
        }

        if (requestParameters.lifeCycleState !== undefined) {
            queryParameters['lifeCycleState'] = requestParameters.lifeCycleState;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/result/{projectKey}-{buildKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters.buildKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Provide list of build results for specified plan. Plan might be top level plan (projectKey-planKey) or job plan (projectKey-planKey-jobKey).
     */
    async getBuildHistory(requestParameters: GetBuildHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestResults> {
        const response = await this.getBuildHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provide list of labels for build result specified by projectKey-buildKey-buildNumber.
     */
    async getBuildLabelsRaw(requestParameters: GetBuildLabelsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestBuildLabels>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getBuildLabels.');
        }

        if (requestParameters.buildKey === null || requestParameters.buildKey === undefined) {
            throw new runtime.RequiredError('buildKey','Required parameter requestParameters.buildKey was null or undefined when calling getBuildLabels.');
        }

        if (requestParameters.buildNumber === null || requestParameters.buildNumber === undefined) {
            throw new runtime.RequiredError('buildNumber','Required parameter requestParameters.buildNumber was null or undefined when calling getBuildLabels.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/result/{projectKey}-{buildKey}-{buildNumber}/label`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters.buildKey))).replace(`{${"buildNumber"}}`, encodeURIComponent(String(requestParameters.buildNumber))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Provide list of labels for build result specified by projectKey-buildKey-buildNumber.
     */
    async getBuildLabels(requestParameters: GetBuildLabelsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestBuildLabels> {
        const response = await this.getBuildLabelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve build monitoring settings
     */
    async getBuildMonitoringRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestBuildMonitoring>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/config/build/monitoring`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve build monitoring settings
     */
    async getBuildMonitoring(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestBuildMonitoring> {
        const response = await this.getBuildMonitoringRaw(initOverrides);
        return await response.value();
    }

    /**
     * Provide list of build scheduled for execution and waiting in build queue.
     */
    async getBuildQueue1Raw(requestParameters: GetBuildQueue1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestQueuedBuilds>> {
        const queryParameters: any = {};

        if (requestParameters.maxResult !== undefined) {
            queryParameters['max-result'] = requestParameters.maxResult;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['start-index'] = requestParameters.startIndex;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/queue`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Provide list of build scheduled for execution and waiting in build queue.
     */
    async getBuildQueue1(requestParameters: GetBuildQueue1Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestQueuedBuilds> {
        const response = await this.getBuildQueue1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provide list of build results related to changeset id passed as parameter. List of results contains results from all plans related to this changeset.
     */
    async getBuildResultsForChangesetRaw(requestParameters: GetBuildResultsForChangesetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestResults>> {
        if (requestParameters.csid === null || requestParameters.csid === undefined) {
            throw new runtime.RequiredError('csid','Required parameter requestParameters.csid was null or undefined when calling getBuildResultsForChangeset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/result/byChangeset/{csid}`.replace(`{${"csid"}}`, encodeURIComponent(String(requestParameters.csid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Provide list of build results related to changeset id passed as parameter. List of results contains results from all plans related to this changeset.
     */
    async getBuildResultsForChangeset(requestParameters: GetBuildResultsForChangesetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestResults> {
        const response = await this.getBuildResultsForChangesetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provide list of build results related to changeset id passed as parameter. List of results contains results from all plans which have repositories checked out with this changeset.
     */
    async getBuildResultsForCheckoutChangesetRaw(requestParameters: GetBuildResultsForCheckoutChangesetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestResults>> {
        if (requestParameters.csid === null || requestParameters.csid === undefined) {
            throw new runtime.RequiredError('csid','Required parameter requestParameters.csid was null or undefined when calling getBuildResultsForCheckoutChangeset.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/result/byCheckoutChangeset/{csid}`.replace(`{${"csid"}}`, encodeURIComponent(String(requestParameters.csid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Provide list of build results related to changeset id passed as parameter. List of results contains results from all plans which have repositories checked out with this changeset.
     */
    async getBuildResultsForCheckoutChangeset(requestParameters: GetBuildResultsForCheckoutChangesetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestResults> {
        const response = await this.getBuildResultsForCheckoutChangesetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch page of ephemeral agent template capabilities.
     */
    async getCapabilitiesRaw(requestParameters: GetCapabilitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestEphemeralAgentTemplate>>> {
        if (requestParameters.configurationId === null || requestParameters.configurationId === undefined) {
            throw new runtime.RequiredError('configurationId','Required parameter requestParameters.configurationId was null or undefined when calling getCapabilities.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/ephemeral/templateConfiguration/{configurationId}/capability`.replace(`{${"configurationId"}}`, encodeURIComponent(String(requestParameters.configurationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Fetch page of ephemeral agent template capabilities.
     */
    async getCapabilities(requestParameters: GetCapabilitiesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestEphemeralAgentTemplate>> {
        const response = await this.getCapabilitiesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Clone an existing Plan into a new one, possibly into different project.
     */
    async getCloneRaw(requestParameters: GetCloneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestPlan>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getClone.');
        }

        if (requestParameters.buildKey === null || requestParameters.buildKey === undefined) {
            throw new runtime.RequiredError('buildKey','Required parameter requestParameters.buildKey was null or undefined when calling getClone.');
        }

        if (requestParameters.toBuildKey === null || requestParameters.toBuildKey === undefined) {
            throw new runtime.RequiredError('toBuildKey','Required parameter requestParameters.toBuildKey was null or undefined when calling getClone.');
        }

        if (requestParameters.toProjectKey === null || requestParameters.toProjectKey === undefined) {
            throw new runtime.RequiredError('toProjectKey','Required parameter requestParameters.toProjectKey was null or undefined when calling getClone.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/clone/{projectKey}-{buildKey}:{toProjectKey}-{toBuildKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters.buildKey))).replace(`{${"toBuildKey"}}`, encodeURIComponent(String(requestParameters.toBuildKey))).replace(`{${"toProjectKey"}}`, encodeURIComponent(String(requestParameters.toProjectKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Clone an existing Plan into a new one, possibly into different project.
     */
    async getClone(requestParameters: GetCloneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestPlan> {
        const response = await this.getCloneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves ephemeral agents configuration.
     */
    async getConfigurationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EphemeralAgentsConfigurationDTO>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/ephemeral/config`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves ephemeral agents configuration.
     */
    async getConfiguration(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EphemeralAgentsConfigurationDTO> {
        const response = await this.getConfigurationRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieves global build and deployment expiry configuration for this Bamboo instance.
     */
    async getConfiguration1Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestCombinedExpiryConfiguration>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/expiry/configuration`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves global build and deployment expiry configuration for this Bamboo instance.
     */
    async getConfiguration1(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestCombinedExpiryConfiguration> {
        const response = await this.getConfiguration1Raw(initOverrides);
        return await response.value();
    }

    /**
     * Elastic image configuration details.
     */
    async getConfiguration2Raw(requestParameters: GetConfiguration2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestElasticImageConfig>> {
        if (requestParameters.configurationId === null || requestParameters.configurationId === undefined) {
            throw new runtime.RequiredError('configurationId','Required parameter requestParameters.configurationId was null or undefined when calling getConfiguration2.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/elasticConfiguration/{configurationId}`.replace(`{${"configurationId"}}`, encodeURIComponent(String(requestParameters.configurationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Elastic image configuration details.
     */
    async getConfiguration2(requestParameters: GetConfiguration2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestElasticImageConfig> {
        const response = await this.getConfiguration2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch current user details
     */
    async getCurrentUserRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserBean>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/currentUser`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Fetch current user details
     */
    async getCurrentUser(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserBean> {
        const response = await this.getCurrentUserRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get deployment version name preview.
     */
    async getDeploymentNamingPreviewRaw(requestParameters: GetDeploymentNamingPreviewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestNamingPreview>> {
        if (requestParameters.deploymentProjectId === null || requestParameters.deploymentProjectId === undefined) {
            throw new runtime.RequiredError('deploymentProjectId','Required parameter requestParameters.deploymentProjectId was null or undefined when calling getDeploymentNamingPreview.');
        }

        if (requestParameters.nextVersionName === null || requestParameters.nextVersionName === undefined) {
            throw new runtime.RequiredError('nextVersionName','Required parameter requestParameters.nextVersionName was null or undefined when calling getDeploymentNamingPreview.');
        }

        const queryParameters: any = {};

        if (requestParameters.nextVersionName !== undefined) {
            queryParameters['nextVersionName'] = requestParameters.nextVersionName;
        }

        if (requestParameters.incrementableVariables !== undefined) {
            queryParameters['incrementableVariables'] = requestParameters.incrementableVariables;
        }

        if (requestParameters.incrementNumbers !== undefined) {
            queryParameters['incrementNumbers'] = requestParameters.incrementNumbers;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/projectVersioning/{deploymentProjectId}/namingPreview`.replace(`{${"deploymentProjectId"}}`, encodeURIComponent(String(requestParameters.deploymentProjectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get deployment version name preview.
     */
    async getDeploymentNamingPreview(requestParameters: GetDeploymentNamingPreviewRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestNamingPreview> {
        const response = await this.getDeploymentNamingPreviewRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get deployment project environments with deployment status. It\'s not optimized for instances with large count of deployment projects and environments, use paged versions instead.
     */
    async getDeploymentProjectRaw(requestParameters: GetDeploymentProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<DashboardProjectWithEnvironmentStatus>>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling getDeploymentProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/dashboard/{projectId}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get deployment project environments with deployment status. It\'s not optimized for instances with large count of deployment projects and environments, use paged versions instead.
     */
    async getDeploymentProject(requestParameters: GetDeploymentProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<DashboardProjectWithEnvironmentStatus>> {
        const response = await this.getDeploymentProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get deployment project by id.
     */
    async getDeploymentProject1Raw(requestParameters: GetDeploymentProject1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDeploymentProject>> {
        if (requestParameters.deploymentProjectId === null || requestParameters.deploymentProjectId === undefined) {
            throw new runtime.RequiredError('deploymentProjectId','Required parameter requestParameters.deploymentProjectId was null or undefined when calling getDeploymentProject1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/project/{deploymentProjectId}`.replace(`{${"deploymentProjectId"}}`, encodeURIComponent(String(requestParameters.deploymentProjectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get deployment project by id.
     */
    async getDeploymentProject1(requestParameters: GetDeploymentProject1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDeploymentProject> {
        const response = await this.getDeploymentProject1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get variables associated with deployment project.
     */
    async getDeploymentProjectVariablesRaw(requestParameters: GetDeploymentProjectVariablesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VersionVariables>> {
        if (requestParameters.deploymentProjectId === null || requestParameters.deploymentProjectId === undefined) {
            throw new runtime.RequiredError('deploymentProjectId','Required parameter requestParameters.deploymentProjectId was null or undefined when calling getDeploymentProjectVariables.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/projectVersioning/{deploymentProjectId}/variables`.replace(`{${"deploymentProjectId"}}`, encodeURIComponent(String(requestParameters.deploymentProjectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get variables associated with deployment project.
     */
    async getDeploymentProjectVariables(requestParameters: GetDeploymentProjectVariablesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VersionVariables> {
        const response = await this.getDeploymentProjectVariablesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get list of deployment versions.
     */
    async getDeploymentProjectVersionsRaw(requestParameters: GetDeploymentProjectVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters.deploymentProjectId === null || requestParameters.deploymentProjectId === undefined) {
            throw new runtime.RequiredError('deploymentProjectId','Required parameter requestParameters.deploymentProjectId was null or undefined when calling getDeploymentProjectVersions.');
        }

        const queryParameters: any = {};

        if (requestParameters.branchKey !== undefined) {
            queryParameters['branchKey'] = requestParameters.branchKey;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/project/{deploymentProjectId}/versions`.replace(`{${"deploymentProjectId"}}`, encodeURIComponent(String(requestParameters.deploymentProjectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.TextApiResponse(response) as any;
    }

    /**
     * Get list of deployment versions.
     */
    async getDeploymentProjectVersions(requestParameters: GetDeploymentProjectVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getDeploymentProjectVersionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get paginated deployment projects with environments list.
     */
    async getDeploymentProjectsRaw(requestParameters: GetDeploymentProjectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetDeploymentProjects200Response>> {
        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/dashboard/paginate`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get paginated deployment projects with environments list.
     */
    async getDeploymentProjects(requestParameters: GetDeploymentProjectsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetDeploymentProjects200Response> {
        const response = await this.getDeploymentProjectsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get list of deployment projects for a build plan.
     */
    async getDeploymentProjectsForPlanRaw(requestParameters: GetDeploymentProjectsForPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestLinkedDeploymentProject>>> {
        if (requestParameters.planKey === null || requestParameters.planKey === undefined) {
            throw new runtime.RequiredError('planKey','Required parameter requestParameters.planKey was null or undefined when calling getDeploymentProjectsForPlan.');
        }

        const queryParameters: any = {};

        if (requestParameters.planKey !== undefined) {
            queryParameters['planKey'] = requestParameters.planKey;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/project/forPlan`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get list of deployment projects for a build plan.
     */
    async getDeploymentProjectsForPlan(requestParameters: GetDeploymentProjectsForPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestLinkedDeploymentProject>> {
        const response = await this.getDeploymentProjectsForPlanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get result of version deployment to environment.
     */
    async getDeploymentResultRaw(requestParameters: GetDeploymentResultRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDeploymentResult>> {
        if (requestParameters.deploymentResultId === null || requestParameters.deploymentResultId === undefined) {
            throw new runtime.RequiredError('deploymentResultId','Required parameter requestParameters.deploymentResultId was null or undefined when calling getDeploymentResult.');
        }

        const queryParameters: any = {};

        if (requestParameters.includeLogs !== undefined) {
            queryParameters['includeLogs'] = requestParameters.includeLogs;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/result/{deploymentResultId}`.replace(`{${"deploymentResultId"}}`, encodeURIComponent(String(requestParameters.deploymentResultId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get result of version deployment to environment.
     */
    async getDeploymentResult(requestParameters: GetDeploymentResultRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDeploymentResult> {
        const response = await this.getDeploymentResultRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get environment latest release info.
     */
    async getEnvironmentStatutesRaw(requestParameters: GetEnvironmentStatutesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestEnvironmentStatusForDashboard>>> {
        if (requestParameters.environmentIds === null || requestParameters.environmentIds === undefined) {
            throw new runtime.RequiredError('environmentIds','Required parameter requestParameters.environmentIds was null or undefined when calling getEnvironmentStatutes.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/deploy/dashboard/status`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.environmentIds,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get environment latest release info.
     */
    async getEnvironmentStatutes(requestParameters: GetEnvironmentStatutesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestEnvironmentStatusForDashboard>> {
        const response = await this.getEnvironmentStatutesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets either pod or container related logs.
     */
    async getEphemeralAgentPodLogsRaw(requestParameters: GetEphemeralAgentPodLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetEphemeralAgentPodLogs200Response>> {
        if (requestParameters.pod === null || requestParameters.pod === undefined) {
            throw new runtime.RequiredError('pod','Required parameter requestParameters.pod was null or undefined when calling getEphemeralAgentPodLogs.');
        }

        const queryParameters: any = {};

        if (requestParameters.containerName !== undefined) {
            queryParameters['containerName'] = requestParameters.containerName;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.afterTimestamp !== undefined) {
            queryParameters['afterTimestamp'] = requestParameters.afterTimestamp;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/ephemeral/pod/{pod}/logs`.replace(`{${"pod"}}`, encodeURIComponent(String(requestParameters.pod))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets either pod or container related logs.
     */
    async getEphemeralAgentPodLogs(requestParameters: GetEphemeralAgentPodLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetEphemeralAgentPodLogs200Response> {
        const response = await this.getEphemeralAgentPodLogsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets either pod or container all logs in the raw, plain text form.
     */
    async getEphemeralAgentPodRawLogsRaw(requestParameters: GetEphemeralAgentPodRawLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetEphemeralAgentPodRawLogs200Response>> {
        if (requestParameters.pod === null || requestParameters.pod === undefined) {
            throw new runtime.RequiredError('pod','Required parameter requestParameters.pod was null or undefined when calling getEphemeralAgentPodRawLogs.');
        }

        const queryParameters: any = {};

        if (requestParameters.containerName !== undefined) {
            queryParameters['containerName'] = requestParameters.containerName;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/ephemeral/pod/{pod}/logs/raw`.replace(`{${"pod"}}`, encodeURIComponent(String(requestParameters.pod))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets either pod or container all logs in the raw, plain text form.
     */
    async getEphemeralAgentPodRawLogs(requestParameters: GetEphemeralAgentPodRawLogsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetEphemeralAgentPodRawLogs200Response> {
        const response = await this.getEphemeralAgentPodRawLogsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Plan\'s favicon which depends on last build result.
     */
    async getFaviconForPlanRaw(requestParameters: GetFaviconForPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestFavicon>> {
        if (requestParameters.planKey === null || requestParameters.planKey === undefined) {
            throw new runtime.RequiredError('planKey','Required parameter requestParameters.planKey was null or undefined when calling getFaviconForPlan.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/plan/favicon/{planKey}`.replace(`{${"planKey"}}`, encodeURIComponent(String(requestParameters.planKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Plan\'s favicon which depends on last build result.
     */
    async getFaviconForPlan(requestParameters: GetFaviconForPlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestFavicon> {
        const response = await this.getFaviconForPlanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves whether a given dark feature key is enabled for a given user. A dark feature is enabled for a user if its either enabled for this instance or for the specific user.
     */
    async getForUserRaw(requestParameters: GetForUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestUserDarkFeature>> {
        if (requestParameters.userName === null || requestParameters.userName === undefined) {
            throw new runtime.RequiredError('userName','Required parameter requestParameters.userName was null or undefined when calling getForUser.');
        }

        if (requestParameters.key === null || requestParameters.key === undefined) {
            throw new runtime.RequiredError('key','Required parameter requestParameters.key was null or undefined when calling getForUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/darkFeatures/{key}/user/{userName}`.replace(`{${"userName"}}`, encodeURIComponent(String(requestParameters.userName))).replace(`{${"key"}}`, encodeURIComponent(String(requestParameters.key))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves whether a given dark feature key is enabled for a given user. A dark feature is enabled for a user if its either enabled for this instance or for the specific user.
     */
    async getForUser(requestParameters: GetForUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestUserDarkFeature> {
        const response = await this.getForUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve Bamboo server general configurations.
     */
    async getGeneralConfigurationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestGeneralConfiguration>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/config/general`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve Bamboo server general configurations.
     */
    async getGeneralConfiguration(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestGeneralConfiguration> {
        const response = await this.getGeneralConfigurationRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a global variable definition. Value will be encrypted if variable name contains key word password.
     */
    async getGlobalVariableRaw(requestParameters: GetGlobalVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestGlobalVariable>> {
        if (requestParameters.variableId === null || requestParameters.variableId === undefined) {
            throw new runtime.RequiredError('variableId','Required parameter requestParameters.variableId was null or undefined when calling getGlobalVariable.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/globalVariables/{variableId}`.replace(`{${"variableId"}}`, encodeURIComponent(String(requestParameters.variableId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a global variable definition. Value will be encrypted if variable name contains key word password.
     */
    async getGlobalVariable(requestParameters: GetGlobalVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestGlobalVariable> {
        const response = await this.getGlobalVariableRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return collection of all global variables. Value of variables that contain password in name will be encrypted with salted hash.
     */
    async getGlobalVariablesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestGlobalVariables>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/globalVariables`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Return collection of all global variables. Value of variables that contain password in name will be encrypted with salted hash.
     */
    async getGlobalVariables(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestGlobalVariables> {
        const response = await this.getGlobalVariablesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a list of groups in Bamboo. The list can be filtered by some attributes, e.g. name. Name is mandatory. Since name is unique, the result only contains 0 or 1 entry.
     */
    async getGroupRaw(requestParameters: GetGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestGroup>>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getGroup.');
        }

        const queryParameters: any = {};

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/security/groups`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve a list of groups in Bamboo. The list can be filtered by some attributes, e.g. name. Name is mandatory. Since name is unique, the result only contains 0 or 1 entry.
     */
    async getGroup(requestParameters: GetGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestGroup>> {
        const response = await this.getGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get instant message server configuration.
     */
    async getIMServerConfigRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestIMServerConfiguration>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/config/imServer`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get instant message server configuration.
     */
    async getIMServerConfig(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestIMServerConfiguration> {
        const response = await this.getIMServerConfigRaw(initOverrides);
        return await response.value();
    }

    /**
     * Chart url.
     */
    async getImageUrlRaw(requestParameters: GetImageUrlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestChart>> {
        const queryParameters: any = {};

        if (requestParameters.buildKeys !== undefined) {
            queryParameters['buildKeys'] = requestParameters.buildKeys;
        }

        if (requestParameters.reportKey !== undefined) {
            queryParameters['reportKey'] = requestParameters.reportKey;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/chart`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Chart url.
     */
    async getImageUrl(requestParameters: GetImageUrlRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestChart> {
        const response = await this.getImageUrlRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Bamboo instance details.
     */
    async getInfoRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestInfo>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/info`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Bamboo instance details.
     */
    async getInfo(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestInfo> {
        const response = await this.getInfoRaw(initOverrides);
        return await response.value();
    }

    /**
     * Obtain logs from an EC2 instance. Note that this method will return the console output of the instance, not Bamboo agent logs.
     */
    async getInstanceLogRaw(requestParameters: GetInstanceLogRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestElasticInstanceLog>> {
        if (requestParameters.instanceId === null || requestParameters.instanceId === undefined) {
            throw new runtime.RequiredError('instanceId','Required parameter requestParameters.instanceId was null or undefined when calling getInstanceLog.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/elasticInstances/instance/{instanceId}/logs`.replace(`{${"instanceId"}}`, encodeURIComponent(String(requestParameters.instanceId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Obtain logs from an EC2 instance. Note that this method will return the console output of the instance, not Bamboo agent logs.
     */
    async getInstanceLog(requestParameters: GetInstanceLogRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestElasticInstanceLog> {
        const response = await this.getInstanceLogRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all deployment projects associated with Jira issue key
     */
    async getJiraIssueStatusForProjectRaw(requestParameters: GetJiraIssueStatusForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestJiraIssueRelatedDeploymentProjects>> {
        if (requestParameters.issueKey === null || requestParameters.issueKey === undefined) {
            throw new runtime.RequiredError('issueKey','Required parameter requestParameters.issueKey was null or undefined when calling getJiraIssueStatusForProject.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/issue-status/{issueKey}`.replace(`{${"issueKey"}}`, encodeURIComponent(String(requestParameters.issueKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get all deployment projects associated with Jira issue key
     */
    async getJiraIssueStatusForProject(requestParameters: GetJiraIssueStatusForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestJiraIssueRelatedDeploymentProjects> {
        const response = await this.getJiraIssueStatusForProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get deployment project environments and versions associated with Jira issue
     */
    async getJiraIssueStatusForProject1Raw(requestParameters: GetJiraIssueStatusForProject1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDeploymentProjectStatusForJiraIssue>> {
        if (requestParameters.issueKey === null || requestParameters.issueKey === undefined) {
            throw new runtime.RequiredError('issueKey','Required parameter requestParameters.issueKey was null or undefined when calling getJiraIssueStatusForProject1.');
        }

        if (requestParameters.deploymentProjectId === null || requestParameters.deploymentProjectId === undefined) {
            throw new runtime.RequiredError('deploymentProjectId','Required parameter requestParameters.deploymentProjectId was null or undefined when calling getJiraIssueStatusForProject1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/issue-status/{issueKey}/{deploymentProjectId}`.replace(`{${"issueKey"}}`, encodeURIComponent(String(requestParameters.issueKey))).replace(`{${"deploymentProjectId"}}`, encodeURIComponent(String(requestParameters.deploymentProjectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get deployment project environments and versions associated with Jira issue
     */
    async getJiraIssueStatusForProject1(requestParameters: GetJiraIssueStatusForProject1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDeploymentProjectStatusForJiraIssue> {
        const response = await this.getJiraIssueStatusForProject1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets the collection of jobs currently scheduled to run.
     */
    async getJobsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestScheduledJob>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/scheduler/jobs`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets the collection of jobs currently scheduled to run.
     */
    async getJobs(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestScheduledJob>> {
        const response = await this.getJobsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Provide list of the latest build results for top level plans visible for users.
     */
    async getLatestBuildResultsRaw(requestParameters: GetLatestBuildResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestResults>> {
        const queryParameters: any = {};

        if (requestParameters.includeAllStates !== undefined) {
            queryParameters['includeAllStates'] = requestParameters.includeAllStates;
        }

        if (requestParameters.continuable !== undefined) {
            queryParameters['continuable'] = requestParameters.continuable;
        }

        if (requestParameters.expand !== undefined) {
            queryParameters['expand'] = requestParameters.expand;
        }

        if (requestParameters.issueKey !== undefined) {
            queryParameters['issueKey'] = requestParameters.issueKey;
        }

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max-results'] = requestParameters.maxResults;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['start-index'] = requestParameters.startIndex;
        }

        if (requestParameters.label !== undefined) {
            queryParameters['label'] = requestParameters.label;
        }

        if (requestParameters.buildstate !== undefined) {
            queryParameters['buildstate'] = requestParameters.buildstate;
        }

        if (requestParameters.favourite !== undefined) {
            queryParameters['favourite'] = requestParameters.favourite;
        }

        if (requestParameters.lifeCycleState !== undefined) {
            queryParameters['lifeCycleState'] = requestParameters.lifeCycleState;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/result`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Provide list of the latest build results for top level plans visible for users.
     */
    async getLatestBuildResults(requestParameters: GetLatestBuildResultsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestResults> {
        const response = await this.getLatestBuildResultsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Provide list of latest build results for top level plans for specified project. List of results is limited to plans visible for user.
     */
    async getLatestBuildResultsForProjectRaw(requestParameters: GetLatestBuildResultsForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestResults>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getLatestBuildResultsForProject.');
        }

        const queryParameters: any = {};

        if (requestParameters.includeAllStates !== undefined) {
            queryParameters['includeAllStates'] = requestParameters.includeAllStates;
        }

        if (requestParameters.continuable !== undefined) {
            queryParameters['continuable'] = requestParameters.continuable;
        }

        if (requestParameters.expand !== undefined) {
            queryParameters['expand'] = requestParameters.expand;
        }

        if (requestParameters.issueKey !== undefined) {
            queryParameters['issueKey'] = requestParameters.issueKey;
        }

        if (requestParameters.maxResults !== undefined) {
            queryParameters['max-results'] = requestParameters.maxResults;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['start-index'] = requestParameters.startIndex;
        }

        if (requestParameters.label !== undefined) {
            queryParameters['label'] = requestParameters.label;
        }

        if (requestParameters.buildstate !== undefined) {
            queryParameters['buildstate'] = requestParameters.buildstate;
        }

        if (requestParameters.favourite !== undefined) {
            queryParameters['favourite'] = requestParameters.favourite;
        }

        if (requestParameters.lifeCycleState !== undefined) {
            queryParameters['lifeCycleState'] = requestParameters.lifeCycleState;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/result/{projectKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Provide list of latest build results for top level plans for specified project. List of results is limited to plans visible for user.
     */
    async getLatestBuildResultsForProject(requestParameters: GetLatestBuildResultsForProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestResults> {
        const response = await this.getLatestBuildResultsForProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get current status of deployment version.
     */
    async getLatestVersionStatusRaw(requestParameters: GetLatestVersionStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDeploymentVersionStatus>> {
        if (requestParameters.deploymentVersionId === null || requestParameters.deploymentVersionId === undefined) {
            throw new runtime.RequiredError('deploymentVersionId','Required parameter requestParameters.deploymentVersionId was null or undefined when calling getLatestVersionStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/version/{deploymentVersionId}/status`.replace(`{${"deploymentVersionId"}}`, encodeURIComponent(String(requestParameters.deploymentVersionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get current status of deployment version.
     */
    async getLatestVersionStatus(requestParameters: GetLatestVersionStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDeploymentVersionStatus> {
        const response = await this.getLatestVersionStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the current mail server configuration.
     */
    async getMailConfigurationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMailConfiguration>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/config/mailServer`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the current mail server configuration.
     */
    async getMailConfiguration(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMailConfiguration> {
        const response = await this.getMailConfigurationRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get broken builds for logged in user.
     */
    async getMyBrokenBuildsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetBrokenBuildsForUser200Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/responsibility/latest/brokenBuild/myBrokenBuilds`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get broken builds for logged in user.
     */
    async getMyBrokenBuilds(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetBrokenBuildsForUser200Response> {
        const response = await this.getMyBrokenBuildsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get next deployment version name.
     */
    async getNextDeploymentVersionsRaw(requestParameters: GetNextDeploymentVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestNamingPreview>> {
        if (requestParameters.deploymentProjectId === null || requestParameters.deploymentProjectId === undefined) {
            throw new runtime.RequiredError('deploymentProjectId','Required parameter requestParameters.deploymentProjectId was null or undefined when calling getNextDeploymentVersions.');
        }

        const queryParameters: any = {};

        if (requestParameters.resultKey !== undefined) {
            queryParameters['resultKey'] = requestParameters.resultKey;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/projectVersioning/{deploymentProjectId}/nextVersion`.replace(`{${"deploymentProjectId"}}`, encodeURIComponent(String(requestParameters.deploymentProjectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get next deployment version name.
     */
    async getNextDeploymentVersions(requestParameters: GetNextDeploymentVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestNamingPreview> {
        const response = await this.getNextDeploymentVersionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get nodes status.
     */
    async getNodesStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestServerNodesInfo>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/server/nodes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get nodes status.
     */
    async getNodesStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestServerNodesInfo> {
        const response = await this.getNodesStatusRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get deployment project environments.
     */
    async getPaginateDeploymentProjectRaw(requestParameters: GetPaginateDeploymentProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetDeploymentProjects200Response>> {
        if (requestParameters.projectId === null || requestParameters.projectId === undefined) {
            throw new runtime.RequiredError('projectId','Required parameter requestParameters.projectId was null or undefined when calling getPaginateDeploymentProject.');
        }

        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/dashboard/paginate/{projectId}`.replace(`{${"projectId"}}`, encodeURIComponent(String(requestParameters.projectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get deployment project environments.
     */
    async getPaginateDeploymentProject(requestParameters: GetPaginateDeploymentProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetDeploymentProjects200Response> {
        const response = await this.getPaginateDeploymentProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves paginated project repositories specified by the project key.
     */
    async getPaginatedProjectRepositoriesRaw(requestParameters: GetPaginatedProjectRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetPaginatedProjectRepositories200Response>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getPaginatedProjectRepositories.');
        }

        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/project/{projectKey}/repositories`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves paginated project repositories specified by the project key.
     */
    async getPaginatedProjectRepositories(requestParameters: GetPaginatedProjectRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetPaginatedProjectRepositories200Response> {
        const response = await this.getPaginatedProjectRepositoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves paginated shared credentials for the project specified by the project key.
     */
    async getPaginatedProjectSharedCredentialsRaw(requestParameters: GetPaginatedProjectSharedCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetPaginatedProjectSharedCredentials200Response>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getPaginatedProjectSharedCredentials.');
        }

        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/project/{projectKey}/sharedCredentials`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves paginated shared credentials for the project specified by the project key.
     */
    async getPaginatedProjectSharedCredentials(requestParameters: GetPaginatedProjectSharedCredentialsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetPaginatedProjectSharedCredentials200Response> {
        const response = await this.getPaginatedProjectSharedCredentialsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get plan summary.
     */
    async getPlanSummaryRaw(requestParameters: GetPlanSummaryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestChart>> {
        const queryParameters: any = {};

        if (requestParameters.buildKeys !== undefined) {
            queryParameters['buildKeys'] = requestParameters.buildKeys;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/chart/planSummary`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get plan summary.
     */
    async getPlanSummary(requestParameters: GetPlanSummaryRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestChart> {
        const response = await this.getPlanSummaryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information for project specified as project key.  - plans - list of plans for project  - plans.plan - list of plans with plan details (only plans visible - READ permission for user)  - plans.plan.actions - list of plans with plan details and actions available for user for plan  
     */
    async getProjectRaw(requestParameters: GetProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestProject>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getProject.');
        }

        const queryParameters: any = {};

        if (requestParameters.expand !== undefined) {
            queryParameters['expand'] = requestParameters.expand;
        }

        if (requestParameters.showEmpty !== undefined) {
            queryParameters['showEmpty'] = requestParameters.showEmpty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/project/{projectKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get information for project specified as project key.  - plans - list of plans for project  - plans.plan - list of plans with plan details (only plans visible - READ permission for user)  - plans.plan.actions - list of plans with plan details and actions available for user for plan  
     */
    async getProject(requestParameters: GetProjectRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestProject> {
        const response = await this.getProjectRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the project variable by given name.
     */
    async getProjectVariableRaw(requestParameters: GetProjectVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestVariable>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getProjectVariable.');
        }

        if (requestParameters.variableName === null || requestParameters.variableName === undefined) {
            throw new runtime.RequiredError('variableName','Required parameter requestParameters.variableName was null or undefined when calling getProjectVariable.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/project/{projectKey}/variable/{variableName}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"variableName"}}`, encodeURIComponent(String(requestParameters.variableName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the project variable by given name.
     */
    async getProjectVariable(requestParameters: GetProjectVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestVariable> {
        const response = await this.getProjectVariableRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the list of all variables for a project.
     */
    async getProjectVariablesRaw(requestParameters: GetProjectVariablesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestVariable>>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getProjectVariables.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/project/{projectKey}/variables`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the list of all variables for a project.
     */
    async getProjectVariables(requestParameters: GetProjectVariablesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestVariable>> {
        const response = await this.getProjectVariablesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all projects defined in Bamboo. Projects without any plan are not listed by default, unless _showEmpty_ query param is set to true.  - projects - list of projects projects.project - list of projects with project details  - projects.project.plans - list of project details and plans for project  - projects.project.plans.plan - list of project details and plans for project with plan details
     */
    async getProjectsRaw(requestParameters: GetProjectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestProjects>> {
        const queryParameters: any = {};

        if (requestParameters.expand !== undefined) {
            queryParameters['expand'] = requestParameters.expand;
        }

        if (requestParameters.showEmpty !== undefined) {
            queryParameters['showEmpty'] = requestParameters.showEmpty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/project`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * List all projects defined in Bamboo. Projects without any plan are not listed by default, unless _showEmpty_ query param is set to true.  - projects - list of projects projects.project - list of projects with project details  - projects.project.plans - list of project details and plans for project  - projects.project.plans.plan - list of project details and plans for project with plan details
     */
    async getProjects(requestParameters: GetProjectsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestProjects> {
        const response = await this.getProjectsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve Bamboo quarantine settings.
     */
    async getQuarantineSettingsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestQuarantineConfig>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/config/quarantine`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve Bamboo quarantine settings.
     */
    async getQuarantineSettings(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestQuarantineConfig> {
        const response = await this.getQuarantineSettingsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get a single quick filter by id.
     */
    async getQuickFilterRaw(requestParameters: GetQuickFilterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestQuickFilter>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling getQuickFilter.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/quickFilter/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get a single quick filter by id.
     */
    async getQuickFilter(requestParameters: GetQuickFilterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestQuickFilter> {
        const response = await this.getQuickFilterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Obtain a list of quick filters defined for this Bamboo instance.
     */
    async getQuickFiltersRaw(requestParameters: GetQuickFiltersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestQuickFilter>>> {
        const queryParameters: any = {};

        if (requestParameters.configured !== undefined) {
            queryParameters['configured'] = requestParameters.configured;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/quickFilter`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Obtain a list of quick filters defined for this Bamboo instance.
     */
    async getQuickFilters(requestParameters: GetQuickFiltersRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestQuickFilter>> {
        const response = await this.getQuickFiltersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Kicks off a reindex.  Requires system admin permissions to perform this reindex.
     */
    async getReindexInfoRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReindexBean>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/reindex`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Kicks off a reindex.  Requires system admin permissions to perform this reindex.
     */
    async getReindexInfo(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReindexBean> {
        const response = await this.getReindexInfoRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve the remote agent configuration
     */
    async getRemoteAgentConfigurationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRemoteAgentConfiguration>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/config/remoteAgentSupport`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve the remote agent configuration
     */
    async getRemoteAgentConfiguration(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRemoteAgentConfiguration> {
        const response = await this.getRemoteAgentConfigurationRaw(initOverrides);
        return await response.value();
    }

    /**
     * Provides a list of all remote agent authentication statuses.
     */
    async getRemoteAgentsRaw(requestParameters: GetRemoteAgentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestBuildAgent>>> {
        const queryParameters: any = {};

        if (requestParameters.online !== undefined) {
            queryParameters['online'] = requestParameters.online;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/agent/remote`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Provides a list of all remote agent authentication statuses.
     */
    async getRemoteAgents(requestParameters: GetRemoteAgentsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestBuildAgent>> {
        const response = await this.getRemoteAgentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get responsible users for broken build result or plan.
     */
    async getResponsibleForPlanResultRaw(requestParameters: GetResponsibleForPlanResultRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling getResponsibleForPlanResult.');
        }

        if (requestParameters.planResultKeyOrPlanKey === null || requestParameters.planResultKeyOrPlanKey === undefined) {
            throw new runtime.RequiredError('planResultKeyOrPlanKey','Required parameter requestParameters.planResultKeyOrPlanKey was null or undefined when calling getResponsibleForPlanResult.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/responsibility/latest/brokenBuild/{planResultKeyOrPlanKey}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"planResultKeyOrPlanKey"}}`, encodeURIComponent(String(requestParameters.planResultKeyOrPlanKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get responsible users for broken build result or plan.
     */
    async getResponsibleForPlanResult(requestParameters: GetResponsibleForPlanResultRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getResponsibleForPlanResultRaw(requestParameters, initOverrides);
    }

    /**
     * Retrieves the current elastic configuration.
     */
    async getRestElasticConfigurationRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestElasticConfiguration>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/elastic/config`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves the current elastic configuration.
     */
    async getRestElasticConfiguration(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestElasticConfiguration> {
        const response = await this.getRestElasticConfigurationRaw(initOverrides);
        return await response.value();
    }

    /**
     * Provide runtime information for currently executing build result. The key difference to other methods is that method is optimized to provide information available in memory only, so no database calls are made. The information provided is not as wide as for finished results, but the call is optimized for speed.
     */
    async getResultStatusRaw(requestParameters: GetResultStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestResultStatus>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling getResultStatus.');
        }

        if (requestParameters.buildKey === null || requestParameters.buildKey === undefined) {
            throw new runtime.RequiredError('buildKey','Required parameter requestParameters.buildKey was null or undefined when calling getResultStatus.');
        }

        if (requestParameters.buildNumber === null || requestParameters.buildNumber === undefined) {
            throw new runtime.RequiredError('buildNumber','Required parameter requestParameters.buildNumber was null or undefined when calling getResultStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/result/status/{projectKey}-{buildKey}-{buildNumber}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters.buildKey))).replace(`{${"buildNumber"}}`, encodeURIComponent(String(requestParameters.buildNumber))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Provide runtime information for currently executing build result. The key difference to other methods is that method is optimized to provide information available in memory only, so no database calls are made. The information provided is not as wide as for finished results, but the call is optimized for speed.
     */
    async getResultStatus(requestParameters: GetResultStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestResultStatus> {
        const response = await this.getResultStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch list of RSS repositories which can use given repository by RSS code.
     */
    async getRssRepositoriesAllowedToAccessRepositoryRaw(requestParameters: GetRssRepositoriesAllowedToAccessRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestRepository>>> {
        if (requestParameters.repositoryId === null || requestParameters.repositoryId === undefined) {
            throw new runtime.RequiredError('repositoryId','Required parameter requestParameters.repositoryId was null or undefined when calling getRssRepositoriesAllowedToAccessRepository.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/repository/{repositoryId}/rssrepository`.replace(`{${"repositoryId"}}`, encodeURIComponent(String(requestParameters.repositoryId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Fetch list of RSS repositories which can use given repository by RSS code.
     */
    async getRssRepositoriesAllowedToAccessRepository(requestParameters: GetRssRepositoriesAllowedToAccessRepositoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestRepository>> {
        const response = await this.getRssRepositoriesAllowedToAccessRepositoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve configuration of S3 Artifact Handler.
     */
    async getS3ArtifactHandlerRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestArtifactHandler>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/artifactHandlers/s3`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve configuration of S3 Artifact Handler.
     */
    async getS3ArtifactHandler(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestArtifactHandler> {
        const response = await this.getS3ArtifactHandlerRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve security settings.
     */
    async getSecuritySettingsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestSecuritySettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/security/settings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve security settings.
     */
    async getSecuritySettings(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestSecuritySettings> {
        const response = await this.getSecuritySettingsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve configuration of SFTP Artifact Handler.
     */
    async getSftpArtifactHandlerRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SimpleRestArtifactHandler>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/artifactHandlers/sftp`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieve configuration of SFTP Artifact Handler.
     */
    async getSftpArtifactHandler(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SimpleRestArtifactHandler> {
        const response = await this.getSftpArtifactHandlerRaw(initOverrides);
        return await response.value();
    }

    /**
     * Resource providing status of RSS processing for a given repository and optional branch.
     */
    async getSpecsDetectionStatusRaw(requestParameters: GetSpecsDetectionStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestVcsLocationSpecsStatus>> {
        if (requestParameters.repositoryId === null || requestParameters.repositoryId === undefined) {
            throw new runtime.RequiredError('repositoryId','Required parameter requestParameters.repositoryId was null or undefined when calling getSpecsDetectionStatus.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResult !== undefined) {
            queryParameters['max-result'] = requestParameters.maxResult;
        }

        if (requestParameters.branch !== undefined) {
            queryParameters['branch'] = requestParameters.branch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/repository/{repositoryId}/scan/status`.replace(`{${"repositoryId"}}`, encodeURIComponent(String(requestParameters.repositoryId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Resource providing status of RSS processing for a given repository and optional branch.
     */
    async getSpecsDetectionStatus(requestParameters: GetSpecsDetectionStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestVcsLocationSpecsStatus> {
        const response = await this.getSpecsDetectionStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves build and deployment expiry status.
     */
    async getStatusRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestCombinedExpiryStatus>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/expiry/status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Retrieves build and deployment expiry status.
     */
    async getStatus(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestCombinedExpiryStatus> {
        const response = await this.getStatusRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get server status.
     */
    async getStatus1Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestServerStatusInfo>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/server`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get server status.
     */
    async getStatus1(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestServerStatusInfo> {
        const response = await this.getStatus1Raw(initOverrides);
        return await response.value();
    }

    /**
     * Returns the current status of the server. This endpoint enables a basic status check on the status of a Bamboo instance. <p> The status endpoint will be responsive as long as the Bamboo REST plugin will be running. In other words, this endpoint does depend on the instance health and might not answer as a result of a failure or when Bamboo is still starting.
     */
    async getStatus2Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAnonymousServerStatusInfo>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns the current status of the server. This endpoint enables a basic status check on the status of a Bamboo instance. <p> The status endpoint will be responsive as long as the Bamboo REST plugin will be running. In other words, this endpoint does depend on the instance health and might not answer as a result of a failure or when Bamboo is still starting.
     */
    async getStatus2(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAnonymousServerStatusInfo> {
        const response = await this.getStatus2Raw(initOverrides);
        return await response.value();
    }

    /**
     * Gets ephemeral template configuration details.
     */
    async getTemplateConfigurationRaw(requestParameters: GetTemplateConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestEphemeralAgentTemplate>> {
        if (requestParameters.configurationId === null || requestParameters.configurationId === undefined) {
            throw new runtime.RequiredError('configurationId','Required parameter requestParameters.configurationId was null or undefined when calling getTemplateConfiguration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/ephemeral/templateConfiguration/{configurationId}`.replace(`{${"configurationId"}}`, encodeURIComponent(String(requestParameters.configurationId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Gets ephemeral template configuration details.
     */
    async getTemplateConfiguration(requestParameters: GetTemplateConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestEphemeralAgentTemplate> {
        const response = await this.getTemplateConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch page of ephemeral templates.
     */
    async getTemplateConfigurationsPageRaw(requestParameters: GetTemplateConfigurationsPageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestEphemeralAgentTemplate>>> {
        const queryParameters: any = {};

        if (requestParameters.filter !== undefined) {
            queryParameters['filter'] = requestParameters.filter;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/ephemeral/templateConfiguration`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Fetch page of ephemeral templates.
     */
    async getTemplateConfigurationsPage(requestParameters: GetTemplateConfigurationsPageRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestEphemeralAgentTemplate>> {
        const response = await this.getTemplateConfigurationsPageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Extract variables value from version name.
     */
    async getVariablesFromNameRaw(requestParameters: GetVariablesFromNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.deploymentProjectId === null || requestParameters.deploymentProjectId === undefined) {
            throw new runtime.RequiredError('deploymentProjectId','Required parameter requestParameters.deploymentProjectId was null or undefined when calling getVariablesFromName.');
        }

        if (requestParameters.nextVersionName === null || requestParameters.nextVersionName === undefined) {
            throw new runtime.RequiredError('nextVersionName','Required parameter requestParameters.nextVersionName was null or undefined when calling getVariablesFromName.');
        }

        const queryParameters: any = {};

        if (requestParameters.nextVersionName !== undefined) {
            queryParameters['nextVersionName'] = requestParameters.nextVersionName;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/projectVersioning/{deploymentProjectId}/parseVariables`.replace(`{${"deploymentProjectId"}}`, encodeURIComponent(String(requestParameters.deploymentProjectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Extract variables value from version name.
     */
    async getVariablesFromName(requestParameters: GetVariablesFromNameRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.getVariablesFromNameRaw(requestParameters, initOverrides);
    }

    /**
     * Get associated build result of deployment version.
     */
    async getVersionAndPlanResultRaw(requestParameters: GetVersionAndPlanResultRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDeploymentVersionAndPlanResult>> {
        if (requestParameters.deploymentVersionId === null || requestParameters.deploymentVersionId === undefined) {
            throw new runtime.RequiredError('deploymentVersionId','Required parameter requestParameters.deploymentVersionId was null or undefined when calling getVersionAndPlanResult.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/version/{deploymentVersionId}/build-result`.replace(`{${"deploymentVersionId"}}`, encodeURIComponent(String(requestParameters.deploymentVersionId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Get associated build result of deployment version.
     */
    async getVersionAndPlanResult(requestParameters: GetVersionAndPlanResultRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDeploymentVersionAndPlanResult> {
        const response = await this.getVersionAndPlanResultRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return visible quick filters for currently logged in user.
     */
    async getVisibleFiltersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestQuickFilter>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/quickFilter/visible`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Return visible quick filters for currently logged in user.
     */
    async getVisibleFilters(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestQuickFilter>> {
        const response = await this.getVisibleFiltersRaw(initOverrides);
        return await response.value();
    }

    /**
     * Grant repository with RSS code to use target repository in build plans and deployments. If permission is not granted RSS import will fail when code tries to use target repository.
     */
    async grantRssRepositoryAccessRaw(requestParameters: GrantRssRepositoryAccessRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryMinimal>> {
        if (requestParameters.repositoryId === null || requestParameters.repositoryId === undefined) {
            throw new runtime.RequiredError('repositoryId','Required parameter requestParameters.repositoryId was null or undefined when calling grantRssRepositoryAccess.');
        }

        if (requestParameters.restIdContainer === null || requestParameters.restIdContainer === undefined) {
            throw new runtime.RequiredError('restIdContainer','Required parameter requestParameters.restIdContainer was null or undefined when calling grantRssRepositoryAccess.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/repository/{repositoryId}/rssrepository`.replace(`{${"repositoryId"}}`, encodeURIComponent(String(requestParameters.repositoryId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restIdContainer,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Grant repository with RSS code to use target repository in build plans and deployments. If permission is not granted RSS import will fail when code tries to use target repository.
     */
    async grantRssRepositoryAccess(requestParameters: GrantRssRepositoryAccessRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryMinimal> {
        const response = await this.grantRssRepositoryAccessRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List of repositories which granted to create/edit environment in given deployment project by Repository stored Bamboo Specs.
     */
    async listAssignedRepositoriesRaw(requestParameters: ListAssignedRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestRepository>>> {
        if (requestParameters.deploymentProjectId === null || requestParameters.deploymentProjectId === undefined) {
            throw new runtime.RequiredError('deploymentProjectId','Required parameter requestParameters.deploymentProjectId was null or undefined when calling listAssignedRepositories.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/project/{deploymentProjectId}/repository`.replace(`{${"deploymentProjectId"}}`, encodeURIComponent(String(requestParameters.deploymentProjectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * List of repositories which granted to create/edit environment in given deployment project by Repository stored Bamboo Specs.
     */
    async listAssignedRepositories(requestParameters: ListAssignedRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestRepository>> {
        const response = await this.listAssignedRepositoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Fetch list of repositories which granted to create plan in given project by Repository stored Bamboo Specs.
     */
    async listAssignedRepositories1Raw(requestParameters: ListAssignedRepositories1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<RestRepository>>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling listAssignedRepositories1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/project/{projectKey}/repository`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Fetch list of repositories which granted to create plan in given project by Repository stored Bamboo Specs.
     */
    async listAssignedRepositories1(requestParameters: ListAssignedRepositories1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<RestRepository>> {
        const response = await this.listAssignedRepositories1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Pauses the server.
     */
    async pauseRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestServerStatusInfo>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/server/pause`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Pauses the server.
     */
    async pause(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestServerStatusInfo> {
        const response = await this.pauseRaw(initOverrides);
        return await response.value();
    }

    /**
     * Prepare server for restarting: suspend change detection, stop indexing, stop ec2 instance ordering etc.
     */
    async prepareForRestartRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestServerStatusInfo>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/server/prepareForRestart`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Prepare server for restarting: suspend change detection, stop indexing, stop ec2 instance ordering etc.
     */
    async prepareForRestart(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestServerStatusInfo> {
        const response = await this.prepareForRestartRaw(initOverrides);
        return await response.value();
    }

    /**
     * Enable or disable a dark feature for a given user.
     */
    async putRaw(requestParameters: PutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestUserDarkFeature>> {
        if (requestParameters.userName === null || requestParameters.userName === undefined) {
            throw new runtime.RequiredError('userName','Required parameter requestParameters.userName was null or undefined when calling put.');
        }

        if (requestParameters.key === null || requestParameters.key === undefined) {
            throw new runtime.RequiredError('key','Required parameter requestParameters.key was null or undefined when calling put.');
        }

        if (requestParameters.restDarkFeature === null || requestParameters.restDarkFeature === undefined) {
            throw new runtime.RequiredError('restDarkFeature','Required parameter requestParameters.restDarkFeature was null or undefined when calling put.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/darkFeatures/{key}/user/{userName}`.replace(`{${"userName"}}`, encodeURIComponent(String(requestParameters.userName))).replace(`{${"key"}}`, encodeURIComponent(String(requestParameters.key))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restDarkFeature,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Enable or disable a dark feature for a given user.
     */
    async put(requestParameters: PutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestUserDarkFeature> {
        const response = await this.putRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Enable or disable a dark feature for all users of this instance.
     */
    async put1Raw(requestParameters: Put1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDarkFeature>> {
        if (requestParameters.key === null || requestParameters.key === undefined) {
            throw new runtime.RequiredError('key','Required parameter requestParameters.key was null or undefined when calling put1.');
        }

        if (requestParameters.restDarkFeature === null || requestParameters.restDarkFeature === undefined) {
            throw new runtime.RequiredError('restDarkFeature','Required parameter requestParameters.restDarkFeature was null or undefined when calling put1.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/darkFeatures/{key}`.replace(`{${"key"}}`, encodeURIComponent(String(requestParameters.key))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restDarkFeature,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Enable or disable a dark feature for all users of this instance.
     */
    async put1(requestParameters: Put1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDarkFeature> {
        const response = await this.put1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Kicks off a reindex.  Requires system admin permissions to perform this operation.
     */
    async reindexRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReindexBean>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/reindex`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Kicks off a reindex.  Requires system admin permissions to perform this operation.
     */
    async reindex(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReindexBean> {
        const response = await this.reindexRaw(initOverrides);
        return await response.value();
    }

    /**
     * Removes a comment from a build result.
     */
    async removeBuildCommentRaw(requestParameters: RemoveBuildCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling removeBuildComment.');
        }

        if (requestParameters.buildKey === null || requestParameters.buildKey === undefined) {
            throw new runtime.RequiredError('buildKey','Required parameter requestParameters.buildKey was null or undefined when calling removeBuildComment.');
        }

        if (requestParameters.commentId === null || requestParameters.commentId === undefined) {
            throw new runtime.RequiredError('commentId','Required parameter requestParameters.commentId was null or undefined when calling removeBuildComment.');
        }

        if (requestParameters.buildNumber === null || requestParameters.buildNumber === undefined) {
            throw new runtime.RequiredError('buildNumber','Required parameter requestParameters.buildNumber was null or undefined when calling removeBuildComment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/result/{projectKey}-{buildKey}-{buildNumber}/comment/{commentId}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters.buildKey))).replace(`{${"commentId"}}`, encodeURIComponent(String(requestParameters.commentId))).replace(`{${"buildNumber"}}`, encodeURIComponent(String(requestParameters.buildNumber))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Removes a comment from a build result.
     */
    async removeBuildComment(requestParameters: RemoveBuildCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeBuildCommentRaw(requestParameters, initOverrides);
    }

    /**
     * Removes label from build result specified by projectKey-buildKey-buildNumber.
     */
    async removeBuildLabelRaw(requestParameters: RemoveBuildLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling removeBuildLabel.');
        }

        if (requestParameters.buildKey === null || requestParameters.buildKey === undefined) {
            throw new runtime.RequiredError('buildKey','Required parameter requestParameters.buildKey was null or undefined when calling removeBuildLabel.');
        }

        if (requestParameters.labelName === null || requestParameters.labelName === undefined) {
            throw new runtime.RequiredError('labelName','Required parameter requestParameters.labelName was null or undefined when calling removeBuildLabel.');
        }

        if (requestParameters.buildNumber === null || requestParameters.buildNumber === undefined) {
            throw new runtime.RequiredError('buildNumber','Required parameter requestParameters.buildNumber was null or undefined when calling removeBuildLabel.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/result/{projectKey}-{buildKey}-{buildNumber}/label/{labelName}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters.buildKey))).replace(`{${"labelName"}}`, encodeURIComponent(String(requestParameters.labelName))).replace(`{${"buildNumber"}}`, encodeURIComponent(String(requestParameters.buildNumber))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Removes label from build result specified by projectKey-buildKey-buildNumber.
     */
    async removeBuildLabel(requestParameters: RemoveBuildLabelRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeBuildLabelRaw(requestParameters, initOverrides);
    }

    /**
     * Delete custom plan expiry settings.
     */
    async removePlanCustomExpirySettingsRaw(requestParameters: RemovePlanCustomExpirySettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.planKey === null || requestParameters.planKey === undefined) {
            throw new runtime.RequiredError('planKey','Required parameter requestParameters.planKey was null or undefined when calling removePlanCustomExpirySettings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/admin/expiry/custom/plan/{planKey}`.replace(`{${"planKey"}}`, encodeURIComponent(String(requestParameters.planKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete custom plan expiry settings.
     */
    async removePlanCustomExpirySettings(requestParameters: RemovePlanCustomExpirySettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removePlanCustomExpirySettingsRaw(requestParameters, initOverrides);
    }

    /**
     * Remove user\'s responsibility from broken build.
     */
    async removeResponsibleRaw(requestParameters: RemoveResponsibleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling removeResponsible.');
        }

        if (requestParameters.planResultKeyOrPlanKey === null || requestParameters.planResultKeyOrPlanKey === undefined) {
            throw new runtime.RequiredError('planResultKeyOrPlanKey','Required parameter requestParameters.planResultKeyOrPlanKey was null or undefined when calling removeResponsible.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/responsibility/latest/brokenBuild/{planResultKeyOrPlanKey}/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"planResultKeyOrPlanKey"}}`, encodeURIComponent(String(requestParameters.planResultKeyOrPlanKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove user\'s responsibility from broken build.
     */
    async removeResponsible(requestParameters: RemoveResponsibleRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeResponsibleRaw(requestParameters, initOverrides);
    }

    /**
     * Resumes the server.
     */
    async resumeRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestServerStatusInfo>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/server/resume`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Resumes the server.
     */
    async resume(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestServerStatusInfo> {
        const response = await this.resumeRaw(initOverrides);
        return await response.value();
    }

    /**
     * Revoke access of RSS code stored in repository defined by repositoryId from repository defined by targetRepositoryId. Use this method when need to prevent usage of target repository by RSS code stored in repository referenced by repositoryId.
     */
    async revokePermissionToUseRepositoryByRssRepoRaw(requestParameters: RevokePermissionToUseRepositoryByRssRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repositoryId === null || requestParameters.repositoryId === undefined) {
            throw new runtime.RequiredError('repositoryId','Required parameter requestParameters.repositoryId was null or undefined when calling revokePermissionToUseRepositoryByRssRepo.');
        }

        if (requestParameters.targetRepositoryId === null || requestParameters.targetRepositoryId === undefined) {
            throw new runtime.RequiredError('targetRepositoryId','Required parameter requestParameters.targetRepositoryId was null or undefined when calling revokePermissionToUseRepositoryByRssRepo.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/repository/{targetRepositoryId}/rssrepository/{repositoryId}`.replace(`{${"repositoryId"}}`, encodeURIComponent(String(requestParameters.repositoryId))).replace(`{${"targetRepositoryId"}}`, encodeURIComponent(String(requestParameters.targetRepositoryId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Revoke access of RSS code stored in repository defined by repositoryId from repository defined by targetRepositoryId. Use this method when need to prevent usage of target repository by RSS code stored in repository referenced by repositoryId.
     */
    async revokePermissionToUseRepositoryByRssRepo(requestParameters: RevokePermissionToUseRepositoryByRssRepoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.revokePermissionToUseRepositoryByRssRepoRaw(requestParameters, initOverrides);
    }

    /**
     * Executes build and deployment expiry process. Will only start each process if it\'s not currently running.
     */
    async runRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RunExpiryResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/admin/latest/expiry/run`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Executes build and deployment expiry process. Will only start each process if it\'s not currently running.
     */
    async run(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RunExpiryResponse> {
        const response = await this.runRaw(initOverrides);
        return await response.value();
    }

    /**
     * Modify ephemeral agents configuration.
     */
    async saveConfigurationRaw(requestParameters: SaveConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EphemeralAgentsConfigurationDTO>> {
        if (requestParameters.ephemeralAgentsConfigurationDTO === null || requestParameters.ephemeralAgentsConfigurationDTO === undefined) {
            throw new runtime.RequiredError('ephemeralAgentsConfigurationDTO','Required parameter requestParameters.ephemeralAgentsConfigurationDTO was null or undefined when calling saveConfiguration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/ephemeral/config`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.ephemeralAgentsConfigurationDTO,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Modify ephemeral agents configuration.
     */
    async saveConfiguration(requestParameters: SaveConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EphemeralAgentsConfigurationDTO> {
        const response = await this.saveConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Performs a starts with search against projects, plans, plan branches, deployment projects
     */
    async searchRaw(requestParameters: SearchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<JsonSearchResultsList>> {
        const queryParameters: any = {};

        if (requestParameters.searchTerm !== undefined) {
            queryParameters['searchTerm'] = requestParameters.searchTerm;
        }

        if (requestParameters.searchEntity !== undefined) {
            queryParameters['searchEntity'] = requestParameters.searchEntity;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/quicksearch`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Performs a starts with search against projects, plans, plan branches, deployment projects
     */
    async search(requestParameters: SearchRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<JsonSearchResultsList> {
        const response = await this.searchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * A starts-with search of authors based on their author name.
     */
    async searchAuthorsRaw(requestParameters: SearchAuthorsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchResultsList>> {
        if (requestParameters.searchTerm === null || requestParameters.searchTerm === undefined) {
            throw new runtime.RequiredError('searchTerm','Required parameter requestParameters.searchTerm was null or undefined when calling searchAuthors.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResult !== undefined) {
            queryParameters['max-result'] = requestParameters.maxResult;
        }

        if (requestParameters.unlinkedOnly !== undefined) {
            queryParameters['unlinkedOnly'] = requestParameters.unlinkedOnly;
        }

        if (requestParameters.searchTerm !== undefined) {
            queryParameters['searchTerm'] = requestParameters.searchTerm;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['start-index'] = requestParameters.startIndex;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/search/authors`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * A starts-with search of authors based on their author name.
     */
    async searchAuthors(requestParameters: SearchAuthorsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchResultsList> {
        const response = await this.searchAuthorsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for linked repositories which can be granted to create/modify environment by Repository stored Bamboo Specs in given deployment project.
     */
    async searchAvailableRepositoriesRaw(requestParameters: SearchAvailableRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryList>> {
        if (requestParameters.deploymentProjectId === null || requestParameters.deploymentProjectId === undefined) {
            throw new runtime.RequiredError('deploymentProjectId','Required parameter requestParameters.deploymentProjectId was null or undefined when calling searchAvailableRepositories.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResult !== undefined) {
            queryParameters['max-result'] = requestParameters.maxResult;
        }

        if (requestParameters.searchTerm !== undefined) {
            queryParameters['searchTerm'] = requestParameters.searchTerm;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['start-index'] = requestParameters.startIndex;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/project/{deploymentProjectId}/repository/search`.replace(`{${"deploymentProjectId"}}`, encodeURIComponent(String(requestParameters.deploymentProjectId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Search for linked repositories which can be granted to create/modify environment by Repository stored Bamboo Specs in given deployment project.
     */
    async searchAvailableRepositories(requestParameters: SearchAvailableRepositoriesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryList> {
        const response = await this.searchAvailableRepositoriesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for linked repositories which can be granted to create plans by Repository stored Bamboo Specs in given project
     */
    async searchAvailableRepositories1Raw(requestParameters: SearchAvailableRepositories1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryList>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling searchAvailableRepositories1.');
        }

        const queryParameters: any = {};

        if (requestParameters.searchTerm !== undefined) {
            queryParameters['searchTerm'] = requestParameters.searchTerm;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/project/{projectKey}/repository/search`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Search for linked repositories which can be granted to create plans by Repository stored Bamboo Specs in given project
     */
    async searchAvailableRepositories1(requestParameters: SearchAvailableRepositories1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryList> {
        const response = await this.searchAvailableRepositories1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for existing linked repositories which can be granted to use given repository by RSS.
     */
    async searchAvailableRepositories2Raw(requestParameters: SearchAvailableRepositories2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryList>> {
        if (requestParameters.repositoryId === null || requestParameters.repositoryId === undefined) {
            throw new runtime.RequiredError('repositoryId','Required parameter requestParameters.repositoryId was null or undefined when calling searchAvailableRepositories2.');
        }

        const queryParameters: any = {};

        if (requestParameters.searchTerm !== undefined) {
            queryParameters['searchTerm'] = requestParameters.searchTerm;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/repository/{repositoryId}/rssrepository/search`.replace(`{${"repositoryId"}}`, encodeURIComponent(String(requestParameters.repositoryId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Search for existing linked repositories which can be granted to use given repository by RSS.
     */
    async searchAvailableRepositories2(requestParameters: SearchAvailableRepositories2Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryList> {
        const response = await this.searchAvailableRepositories2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Performs a \"starts with\" search against full plan branch name and full plan branch key. Branches are restricted to \"masterPlanKey\" plan.
     */
    async searchBranchesRaw(requestParameters: SearchBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchResultsList>> {
        if (requestParameters.masterPlanKey === null || requestParameters.masterPlanKey === undefined) {
            throw new runtime.RequiredError('masterPlanKey','Required parameter requestParameters.masterPlanKey was null or undefined when calling searchBranches.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResult !== undefined) {
            queryParameters['max-result'] = requestParameters.maxResult;
        }

        if (requestParameters.searchTerm !== undefined) {
            queryParameters['searchTerm'] = requestParameters.searchTerm;
        }

        if (requestParameters.includeMasterBranch !== undefined) {
            queryParameters['includeMasterBranch'] = requestParameters.includeMasterBranch;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['start-index'] = requestParameters.startIndex;
        }

        if (requestParameters.branchNameOnly !== undefined) {
            queryParameters['branchNameOnly'] = requestParameters.branchNameOnly;
        }

        if (requestParameters.fuzzy !== undefined) {
            queryParameters['fuzzy'] = requestParameters.fuzzy;
        }

        if (requestParameters.masterPlanKey !== undefined) {
            queryParameters['masterPlanKey'] = requestParameters.masterPlanKey;
        }

        if (requestParameters.releasedInDeployment !== undefined) {
            queryParameters['releasedInDeployment'] = requestParameters.releasedInDeployment;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/search/branches`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Performs a \"starts with\" search against full plan branch name and full plan branch key. Branches are restricted to \"masterPlanKey\" plan.
     */
    async searchBranches(requestParameters: SearchBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchResultsList> {
        const response = await this.searchBranchesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Performs a contains search against deployment project name.
     */
    async searchDeploymentsRaw(requestParameters: SearchDeploymentsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchResultsList>> {
        const queryParameters: any = {};

        if (requestParameters.maxResult !== undefined) {
            queryParameters['max-result'] = requestParameters.maxResult;
        }

        if (requestParameters.searchTerm !== undefined) {
            queryParameters['searchTerm'] = requestParameters.searchTerm;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['start-index'] = requestParameters.startIndex;
        }

        if (requestParameters.permission !== undefined) {
            queryParameters['permission'] = requestParameters.permission;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/search/deployments`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Performs a contains search against deployment project name.
     */
    async searchDeployments(requestParameters: SearchDeploymentsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchResultsList> {
        const response = await this.searchDeploymentsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for available plan child dependencies
     */
    async searchForAvailablePlanChildDependenciesRaw(requestParameters: SearchForAvailablePlanChildDependenciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDependencies>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling searchForAvailablePlanChildDependencies.');
        }

        if (requestParameters.searchTerm === null || requestParameters.searchTerm === undefined) {
            throw new runtime.RequiredError('searchTerm','Required parameter requestParameters.searchTerm was null or undefined when calling searchForAvailablePlanChildDependencies.');
        }

        if (requestParameters.buildKey === null || requestParameters.buildKey === undefined) {
            throw new runtime.RequiredError('buildKey','Required parameter requestParameters.buildKey was null or undefined when calling searchForAvailablePlanChildDependencies.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResult !== undefined) {
            queryParameters['max-result'] = requestParameters.maxResult;
        }

        if (requestParameters.searchTerm !== undefined) {
            queryParameters['searchTerm'] = requestParameters.searchTerm;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['start-index'] = requestParameters.startIndex;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/dependency/search/{projectKey}-{buildKey}/child`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters.buildKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Search for available plan child dependencies
     */
    async searchForAvailablePlanChildDependencies(requestParameters: SearchForAvailablePlanChildDependenciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDependencies> {
        const response = await this.searchForAvailablePlanChildDependenciesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for available plan parent dependencies
     */
    async searchForAvailablePlanParentDependenciesRaw(requestParameters: SearchForAvailablePlanParentDependenciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDependencies>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling searchForAvailablePlanParentDependencies.');
        }

        if (requestParameters.searchTerm === null || requestParameters.searchTerm === undefined) {
            throw new runtime.RequiredError('searchTerm','Required parameter requestParameters.searchTerm was null or undefined when calling searchForAvailablePlanParentDependencies.');
        }

        if (requestParameters.buildKey === null || requestParameters.buildKey === undefined) {
            throw new runtime.RequiredError('buildKey','Required parameter requestParameters.buildKey was null or undefined when calling searchForAvailablePlanParentDependencies.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResult !== undefined) {
            queryParameters['max-result'] = requestParameters.maxResult;
        }

        if (requestParameters.searchTerm !== undefined) {
            queryParameters['searchTerm'] = requestParameters.searchTerm;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['start-index'] = requestParameters.startIndex;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/dependency/search/{projectKey}-{buildKey}/parent`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters.buildKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Search for available plan parent dependencies
     */
    async searchForAvailablePlanParentDependencies(requestParameters: SearchForAvailablePlanParentDependenciesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDependencies> {
        const response = await this.searchForAvailablePlanParentDependenciesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Performs a \"starts with\" search against full job name and full job key.
     */
    async searchJobsRaw(requestParameters: SearchJobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchResultsList>> {
        if (requestParameters.planKey === null || requestParameters.planKey === undefined) {
            throw new runtime.RequiredError('planKey','Required parameter requestParameters.planKey was null or undefined when calling searchJobs.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResult !== undefined) {
            queryParameters['max-result'] = requestParameters.maxResult;
        }

        if (requestParameters.searchTerm !== undefined) {
            queryParameters['searchTerm'] = requestParameters.searchTerm;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['start-index'] = requestParameters.startIndex;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/search/jobs/{planKey}`.replace(`{${"planKey"}}`, encodeURIComponent(String(requestParameters.planKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Performs a \"starts with\" search against full job name and full job key.
     */
    async searchJobs(requestParameters: SearchJobsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchResultsList> {
        const response = await this.searchJobsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Performs a \"starts with\" search against full plan name and full plan key.  Use \"type\" argument to filter by plan type by default will return TopLevelPlans
     */
    async searchPlansRaw(requestParameters: SearchPlansRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchResultsList>> {
        const queryParameters: any = {};

        if (requestParameters.maxResult !== undefined) {
            queryParameters['max-result'] = requestParameters.maxResult;
        }

        if (requestParameters.searchTerm !== undefined) {
            queryParameters['searchTerm'] = requestParameters.searchTerm;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['start-index'] = requestParameters.startIndex;
        }

        if (requestParameters.permission !== undefined) {
            queryParameters['permission'] = requestParameters.permission;
        }

        if (requestParameters.type !== undefined) {
            queryParameters['type'] = requestParameters.type;
        }

        if (requestParameters.fuzzy !== undefined) {
            queryParameters['fuzzy'] = requestParameters.fuzzy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/search/plans`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Performs a \"starts with\" search against full plan name and full plan key.  Use \"type\" argument to filter by plan type by default will return TopLevelPlans
     */
    async searchPlans(requestParameters: SearchPlansRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchResultsList> {
        const response = await this.searchPlansRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Performs a contains search against project name.
     */
    async searchProjectsRaw(requestParameters: SearchProjectsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchResultsList>> {
        const queryParameters: any = {};

        if (requestParameters.maxResult !== undefined) {
            queryParameters['max-result'] = requestParameters.maxResult;
        }

        if (requestParameters.searchTerm !== undefined) {
            queryParameters['searchTerm'] = requestParameters.searchTerm;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['start-index'] = requestParameters.startIndex;
        }

        if (requestParameters.permission !== undefined) {
            queryParameters['permission'] = requestParameters.permission;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/search/projects`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Performs a contains search against project name.
     */
    async searchProjects(requestParameters: SearchProjectsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchResultsList> {
        const response = await this.searchProjectsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search for divergent branches names (i.e. vcs branches that have RSS execution results).
     */
    async searchSpecsBranchesRaw(requestParameters: SearchSpecsBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestBranchList>> {
        if (requestParameters.repositoryId === null || requestParameters.repositoryId === undefined) {
            throw new runtime.RequiredError('repositoryId','Required parameter requestParameters.repositoryId was null or undefined when calling searchSpecsBranches.');
        }

        const queryParameters: any = {};

        if (requestParameters.searchTerm !== undefined) {
            queryParameters['searchTerm'] = requestParameters.searchTerm;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/repository/{repositoryId}/rssBranches`.replace(`{${"repositoryId"}}`, encodeURIComponent(String(requestParameters.repositoryId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Search for divergent branches names (i.e. vcs branches that have RSS execution results).
     */
    async searchSpecsBranches(requestParameters: SearchSpecsBranchesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestBranchList> {
        const response = await this.searchSpecsBranchesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Performs a \"starts with\" search against full stage name.
     */
    async searchStagesRaw(requestParameters: SearchStagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchResultsList>> {
        if (requestParameters.planKey === null || requestParameters.planKey === undefined) {
            throw new runtime.RequiredError('planKey','Required parameter requestParameters.planKey was null or undefined when calling searchStages.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResult !== undefined) {
            queryParameters['max-result'] = requestParameters.maxResult;
        }

        if (requestParameters.searchTerm !== undefined) {
            queryParameters['searchTerm'] = requestParameters.searchTerm;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['start-index'] = requestParameters.startIndex;
        }

        if (requestParameters.stageId !== undefined) {
            queryParameters['stageId'] = requestParameters.stageId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/search/stages/{planKey}`.replace(`{${"planKey"}}`, encodeURIComponent(String(requestParameters.planKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Performs a \"starts with\" search against full stage name.
     */
    async searchStages(requestParameters: SearchStagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchResultsList> {
        const response = await this.searchStagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * A starts-with search of users based on their username, full-name and if allowed email address.
     */
    async searchUsersRaw(requestParameters: SearchUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchResultsList>> {
        if (requestParameters.searchTerm === null || requestParameters.searchTerm === undefined) {
            throw new runtime.RequiredError('searchTerm','Required parameter requestParameters.searchTerm was null or undefined when calling searchUsers.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResult !== undefined) {
            queryParameters['max-result'] = requestParameters.maxResult;
        }

        if (requestParameters.includeAvatars !== undefined) {
            queryParameters['includeAvatars'] = requestParameters.includeAvatars;
        }

        if (requestParameters.searchTerm !== undefined) {
            queryParameters['searchTerm'] = requestParameters.searchTerm;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['start-index'] = requestParameters.startIndex;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/search/users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * A starts-with search of users based on their username, full-name and if allowed email address.
     */
    async searchUsers(requestParameters: SearchUsersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchResultsList> {
        const response = await this.searchUsersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Performs a contains search against a version name.
     */
    async searchVersionsRaw(requestParameters: SearchVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchResultsList>> {
        if (requestParameters.deploymentProjectId === null || requestParameters.deploymentProjectId === undefined) {
            throw new runtime.RequiredError('deploymentProjectId','Required parameter requestParameters.deploymentProjectId was null or undefined when calling searchVersions.');
        }

        const queryParameters: any = {};

        if (requestParameters.maxResult !== undefined) {
            queryParameters['max-result'] = requestParameters.maxResult;
        }

        if (requestParameters.branchKey !== undefined) {
            queryParameters['branchKey'] = requestParameters.branchKey;
        }

        if (requestParameters.searchTerm !== undefined) {
            queryParameters['searchTerm'] = requestParameters.searchTerm;
        }

        if (requestParameters.startIndex !== undefined) {
            queryParameters['start-index'] = requestParameters.startIndex;
        }

        if (requestParameters.deploymentProjectId !== undefined) {
            queryParameters['deploymentProjectId'] = requestParameters.deploymentProjectId;
        }

        if (requestParameters.chronologicalOrder !== undefined) {
            queryParameters['chronologicalOrder'] = requestParameters.chronologicalOrder;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/search/versions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Performs a contains search against a version name.
     */
    async searchVersions(requestParameters: SearchVersionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchResultsList> {
        const response = await this.searchVersionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update global build and deployment expiry configuration for this Bamboo instance. Partial configuration is not allowed (it will fail validation).
     */
    async setConfigurationRaw(requestParameters: SetConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestCombinedExpiryConfiguration>> {
        if (requestParameters.restCombinedExpiryConfiguration === null || requestParameters.restCombinedExpiryConfiguration === undefined) {
            throw new runtime.RequiredError('restCombinedExpiryConfiguration','Required parameter requestParameters.restCombinedExpiryConfiguration was null or undefined when calling setConfiguration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/expiry/configuration`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restCombinedExpiryConfiguration,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update global build and deployment expiry configuration for this Bamboo instance. Partial configuration is not allowed (it will fail validation).
     */
    async setConfiguration(requestParameters: SetConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestCombinedExpiryConfiguration> {
        const response = await this.setConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Saves the list of visible quick filters for currently logged in user.
     */
    async setVisibleFiltersRaw(requestParameters: SetVisibleFiltersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.requestBody === null || requestParameters.requestBody === undefined) {
            throw new runtime.RequiredError('requestBody','Required parameter requestParameters.requestBody was null or undefined when calling setVisibleFilters.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/quickFilter/visible`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.requestBody,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Saves the list of visible quick filters for currently logged in user.
     */
    async setVisibleFilters(requestParameters: SetVisibleFiltersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.setVisibleFiltersRaw(requestParameters, initOverrides);
    }

    /**
     * Fire build execution for specified plan. Effectively, this method adds build to the build queue, so is not guarantied that build would be executed immediately. Depending on currently executed builds and length of build queue, build may be executed when queue would be drained. Additional variables could be passed to this method either as form encoded POST payload or query parameters. PLEASE note: Query parameters are more important - override those stored in form payload. Variables defined in Bamboo as global variables or plan variables MUST be prefixed with bamboo.variable ie. <code>bamboo.variable.myVariable=valueForMyVariable</code>. When global or plan variables would be passed to this method, will override default values for variables.
     */
    async startBuildRaw(requestParameters: StartBuildOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestQueuedBuild>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling startBuild.');
        }

        if (requestParameters.buildKey === null || requestParameters.buildKey === undefined) {
            throw new runtime.RequiredError('buildKey','Required parameter requestParameters.buildKey was null or undefined when calling startBuild.');
        }

        const queryParameters: any = {};

        if (requestParameters.executeAllStages !== undefined) {
            queryParameters['executeAllStages'] = requestParameters.executeAllStages;
        }

        if (requestParameters.customRevision !== undefined) {
            queryParameters['customRevision'] = requestParameters.customRevision;
        }

        if (requestParameters.stage !== undefined) {
            queryParameters['stage'] = requestParameters.stage;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/xml';

        const response = await this.request({
            path: `/api/latest/queue/{projectKey}-{buildKey}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters.buildKey))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.startBuildRequest,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Fire build execution for specified plan. Effectively, this method adds build to the build queue, so is not guarantied that build would be executed immediately. Depending on currently executed builds and length of build queue, build may be executed when queue would be drained. Additional variables could be passed to this method either as form encoded POST payload or query parameters. PLEASE note: Query parameters are more important - override those stored in form payload. Variables defined in Bamboo as global variables or plan variables MUST be prefixed with bamboo.variable ie. <code>bamboo.variable.myVariable=valueForMyVariable</code>. When global or plan variables would be passed to this method, will override default values for variables.
     */
    async startBuild(requestParameters: StartBuildOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestQueuedBuild> {
        const response = await this.startBuildRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Stop build execution.
     */
    async stopBuildRaw(requestParameters: StopBuildRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectKey === null || requestParameters.projectKey === undefined) {
            throw new runtime.RequiredError('projectKey','Required parameter requestParameters.projectKey was null or undefined when calling stopBuild.');
        }

        if (requestParameters.buildKey === null || requestParameters.buildKey === undefined) {
            throw new runtime.RequiredError('buildKey','Required parameter requestParameters.buildKey was null or undefined when calling stopBuild.');
        }

        if (requestParameters.buildNumber === null || requestParameters.buildNumber === undefined) {
            throw new runtime.RequiredError('buildNumber','Required parameter requestParameters.buildNumber was null or undefined when calling stopBuild.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/queue/{projectKey}-{buildKey}-{buildNumber}`.replace(`{${"projectKey"}}`, encodeURIComponent(String(requestParameters.projectKey))).replace(`{${"buildKey"}}`, encodeURIComponent(String(requestParameters.buildKey))).replace(`{${"buildNumber"}}`, encodeURIComponent(String(requestParameters.buildNumber))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Stop build execution.
     */
    async stopBuild(requestParameters: StopBuildRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.stopBuildRaw(requestParameters, initOverrides);
    }

    /**
     * Test connection to ephemeral agents provider.
     */
    async testConnectionRaw(requestParameters: TestConnectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TestConnectionResultDto>> {
        if (requestParameters.ephemeralAgentsConfigurationDTO === null || requestParameters.ephemeralAgentsConfigurationDTO === undefined) {
            throw new runtime.RequiredError('ephemeralAgentsConfigurationDTO','Required parameter requestParameters.ephemeralAgentsConfigurationDTO was null or undefined when calling testConnection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/ephemeral/config/test-connection`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.ephemeralAgentsConfigurationDTO,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Test connection to ephemeral agents provider.
     */
    async testConnection(requestParameters: TestConnectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TestConnectionResultDto> {
        const response = await this.testConnectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Tests connection to a repository if the repository type supports connection testing. Request payload should contain repository configuration.
     */
    async testConnection1Raw(requestParameters: TestConnection1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRepositoryConnectionResult>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/repository/testConnection`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Tests connection to a repository if the repository type supports connection testing. Request payload should contain repository configuration.
     */
    async testConnection1(requestParameters: TestConnection1Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRepositoryConnectionResult> {
        const response = await this.testConnection1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Trigger background job execution.
     */
    async triggerJobRaw(requestParameters: TriggerJobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestQuarantineConfig>> {
        if (requestParameters.restScheduledJob === null || requestParameters.restScheduledJob === undefined) {
            throw new runtime.RequiredError('restScheduledJob','Required parameter requestParameters.restScheduledJob was null or undefined when calling triggerJob.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/scheduler/jobs/trigger`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restScheduledJob,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Trigger background job execution.
     */
    async triggerJob(requestParameters: TriggerJobRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestQuarantineConfig> {
        const response = await this.triggerJobRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Webhook resource for triggering Repository-stored Bamboo Specs. Either repository ID or name must be provided via query parameters to identify the linked repository in which Bamboo Specs are defined.  Ambiguous requests, which reference more than one repository via the query params, will result in one parameter taking precedence over the others. There\'s no guarantee which one.  This resource does not require authorisation. It will always return HTTP 204 response on every valid request, even if the targeted repository doesn\'t exist or does not contain Bamboo Specs.
     */
    async triggerSpecsScanningRaw(requestParameters: TriggerSpecsScanningRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.repositoryId !== undefined) {
            queryParameters['repositoryId'] = requestParameters.repositoryId;
        }

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.repositoryName !== undefined) {
            queryParameters['repositoryName'] = requestParameters.repositoryName;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/repository/scan`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Webhook resource for triggering Repository-stored Bamboo Specs. Either repository ID or name must be provided via query parameters to identify the linked repository in which Bamboo Specs are defined.  Ambiguous requests, which reference more than one repository via the query params, will result in one parameter taking precedence over the others. There\'s no guarantee which one.  This resource does not require authorisation. It will always return HTTP 204 response on every valid request, even if the targeted repository doesn\'t exist or does not contain Bamboo Specs.
     */
    async triggerSpecsScanning(requestParameters: TriggerSpecsScanningRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.triggerSpecsScanningRaw(requestParameters, initOverrides);
    }

    /**
     * Resource for triggering Repository-stored Bamboo Specs in a \'forced\' way. Successful requests to this resource will trigger Bamboo Specs execution even if standard processing would have been skipped (e.g. no new commits to process).
     */
    async triggerSpecsScanning1Raw(requestParameters: TriggerSpecsScanning1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.repositoryId === null || requestParameters.repositoryId === undefined) {
            throw new runtime.RequiredError('repositoryId','Required parameter requestParameters.repositoryId was null or undefined when calling triggerSpecsScanning1.');
        }

        const queryParameters: any = {};

        if (requestParameters.branch !== undefined) {
            queryParameters['branch'] = requestParameters.branch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/repository/{repositoryId}/scanNow`.replace(`{${"repositoryId"}}`, encodeURIComponent(String(requestParameters.repositoryId))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Resource for triggering Repository-stored Bamboo Specs in a \'forced\' way. Successful requests to this resource will trigger Bamboo Specs execution even if standard processing would have been skipped (e.g. no new commits to process).
     */
    async triggerSpecsScanning1(requestParameters: TriggerSpecsScanning1Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.triggerSpecsScanning1Raw(requestParameters, initOverrides);
    }

    /**
     * Update existing agent capability. It\'s allowed to skip capability key at request payload.
     */
    async updateAgentCapabilityRaw(requestParameters: UpdateAgentCapabilityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.agentId === null || requestParameters.agentId === undefined) {
            throw new runtime.RequiredError('agentId','Required parameter requestParameters.agentId was null or undefined when calling updateAgentCapability.');
        }

        if (requestParameters.capabilityKey === null || requestParameters.capabilityKey === undefined) {
            throw new runtime.RequiredError('capabilityKey','Required parameter requestParameters.capabilityKey was null or undefined when calling updateAgentCapability.');
        }

        if (requestParameters.restRemoteAgentCapability === null || requestParameters.restRemoteAgentCapability === undefined) {
            throw new runtime.RequiredError('restRemoteAgentCapability','Required parameter requestParameters.restRemoteAgentCapability was null or undefined when calling updateAgentCapability.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/agent/{agentId}/capability/{capabilityKey}`.replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters.agentId))).replace(`{${"capabilityKey"}}`, encodeURIComponent(String(requestParameters.capabilityKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restRemoteAgentCapability,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update existing agent capability. It\'s allowed to skip capability key at request payload.
     */
    async updateAgentCapability(requestParameters: UpdateAgentCapabilityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateAgentCapabilityRaw(requestParameters, initOverrides);
    }

    /**
     * Update Agent-Local Artifact Handler configuration.
     */
    async updateAgentLocalHandlerRaw(requestParameters: UpdateAgentLocalHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestArtifactHandler>> {
        if (requestParameters.restArtifactHandler === null || requestParameters.restArtifactHandler === undefined) {
            throw new runtime.RequiredError('restArtifactHandler','Required parameter requestParameters.restArtifactHandler was null or undefined when calling updateAgentLocalHandler.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/artifactHandlers/agentLocal`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restArtifactHandler,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update Agent-Local Artifact Handler configuration.
     */
    async updateAgentLocalHandler(requestParameters: UpdateAgentLocalHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestArtifactHandler> {
        const response = await this.updateAgentLocalHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Bulk update of all images AMI id.
     */
    async updateAllImageIdsRaw(requestParameters: UpdateAllImageIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.imageId === null || requestParameters.imageId === undefined) {
            throw new runtime.RequiredError('imageId','Required parameter requestParameters.imageId was null or undefined when calling updateAllImageIds.');
        }

        if (requestParameters.newImageId === null || requestParameters.newImageId === undefined) {
            throw new runtime.RequiredError('newImageId','Required parameter requestParameters.newImageId was null or undefined when calling updateAllImageIds.');
        }

        const queryParameters: any = {};

        if (requestParameters.newImageId !== undefined) {
            queryParameters['newImageId'] = requestParameters.newImageId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/elasticConfiguration/image-id/{imageId}`.replace(`{${"imageId"}}`, encodeURIComponent(String(requestParameters.imageId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Bulk update of all images AMI id.
     */
    async updateAllImageIds(requestParameters: UpdateAllImageIdsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateAllImageIdsRaw(requestParameters, initOverrides);
    }

    /**
     * Enable/disable audit log.
     */
    async updateAuditLogConfigurationRaw(requestParameters: UpdateAuditLogConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAuditLogConfiguration>> {
        if (requestParameters.restAuditLogConfiguration === null || requestParameters.restAuditLogConfiguration === undefined) {
            throw new runtime.RequiredError('restAuditLogConfiguration','Required parameter requestParameters.restAuditLogConfiguration was null or undefined when calling updateAuditLogConfiguration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/config/auditLog`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restAuditLogConfiguration,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Enable/disable audit log.
     */
    async updateAuditLogConfiguration(requestParameters: UpdateAuditLogConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAuditLogConfiguration> {
        const response = await this.updateAuditLogConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Bamboo Server Artifact Handler configuration.
     */
    async updateBambooRemoteHandlerRaw(requestParameters: UpdateBambooRemoteHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestArtifactHandler>> {
        if (requestParameters.simpleRestArtifactHandler === null || requestParameters.simpleRestArtifactHandler === undefined) {
            throw new runtime.RequiredError('simpleRestArtifactHandler','Required parameter requestParameters.simpleRestArtifactHandler was null or undefined when calling updateBambooRemoteHandler.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/artifactHandlers/bambooRemote`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.simpleRestArtifactHandler,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update Bamboo Server Artifact Handler configuration.
     */
    async updateBambooRemoteHandler(requestParameters: UpdateBambooRemoteHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestArtifactHandler> {
        const response = await this.updateBambooRemoteHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update ephemeral agent template capability.
     */
    async updateCapabilityRaw(requestParameters: UpdateCapabilityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.configurationId === null || requestParameters.configurationId === undefined) {
            throw new runtime.RequiredError('configurationId','Required parameter requestParameters.configurationId was null or undefined when calling updateCapability.');
        }

        if (requestParameters.restCapability === null || requestParameters.restCapability === undefined) {
            throw new runtime.RequiredError('restCapability','Required parameter requestParameters.restCapability was null or undefined when calling updateCapability.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/ephemeral/templateConfiguration/{configurationId}/capability`.replace(`{${"configurationId"}}`, encodeURIComponent(String(requestParameters.configurationId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restCapability,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update ephemeral agent template capability.
     */
    async updateCapability(requestParameters: UpdateCapabilityRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateCapabilityRaw(requestParameters, initOverrides);
    }

    /**
     * Update elastic image configuration.
     */
    async updateConfigurationRaw(requestParameters: UpdateConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestElasticImageConfig>> {
        if (requestParameters.configurationId === null || requestParameters.configurationId === undefined) {
            throw new runtime.RequiredError('configurationId','Required parameter requestParameters.configurationId was null or undefined when calling updateConfiguration.');
        }

        if (requestParameters.restElasticImageConfig === null || requestParameters.restElasticImageConfig === undefined) {
            throw new runtime.RequiredError('restElasticImageConfig','Required parameter requestParameters.restElasticImageConfig was null or undefined when calling updateConfiguration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/elasticConfiguration/{configurationId}`.replace(`{${"configurationId"}}`, encodeURIComponent(String(requestParameters.configurationId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restElasticImageConfig,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update elastic image configuration.
     */
    async updateConfiguration(requestParameters: UpdateConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestElasticImageConfig> {
        const response = await this.updateConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update bamboo server general configurations. Partially update supported.
     */
    async updateGeneralConfigurationRaw(requestParameters: UpdateGeneralConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestBuildConcurrency>> {
        if (requestParameters.restGeneralConfiguration === null || requestParameters.restGeneralConfiguration === undefined) {
            throw new runtime.RequiredError('restGeneralConfiguration','Required parameter requestParameters.restGeneralConfiguration was null or undefined when calling updateGeneralConfiguration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/config/general`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restGeneralConfiguration,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update bamboo server general configurations. Partially update supported.
     */
    async updateGeneralConfiguration(requestParameters: UpdateGeneralConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestBuildConcurrency> {
        const response = await this.updateGeneralConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update value of a global variable.
     */
    async updateGlobalVariableRaw(requestParameters: UpdateGlobalVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestGlobalVariable>> {
        if (requestParameters.variableId === null || requestParameters.variableId === undefined) {
            throw new runtime.RequiredError('variableId','Required parameter requestParameters.variableId was null or undefined when calling updateGlobalVariable.');
        }

        if (requestParameters.restGlobalVariable === null || requestParameters.restGlobalVariable === undefined) {
            throw new runtime.RequiredError('restGlobalVariable','Required parameter requestParameters.restGlobalVariable was null or undefined when calling updateGlobalVariable.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/globalVariables/{variableId}`.replace(`{${"variableId"}}`, encodeURIComponent(String(requestParameters.variableId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restGlobalVariable,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update value of a global variable.
     */
    async updateGlobalVariable(requestParameters: UpdateGlobalVariableRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestGlobalVariable> {
        const response = await this.updateGlobalVariableRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update or create existing IM server configuration in bamboo. If IM server is already configured in bamboo, update existing configuration. Otherwise, create IM server configuration.
     */
    async updateIMServerConfigRaw(requestParameters: UpdateIMServerConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestIMServerConfiguration>> {
        if (requestParameters.restIMServerConfiguration === null || requestParameters.restIMServerConfiguration === undefined) {
            throw new runtime.RequiredError('restIMServerConfiguration','Required parameter requestParameters.restIMServerConfiguration was null or undefined when calling updateIMServerConfig.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/config/imServer`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restIMServerConfiguration,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update or create existing IM server configuration in bamboo. If IM server is already configured in bamboo, update existing configuration. Otherwise, create IM server configuration.
     */
    async updateIMServerConfig(requestParameters: UpdateIMServerConfigRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestIMServerConfiguration> {
        const response = await this.updateIMServerConfigRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the mail server configuration.
     */
    async updateMailConfigurationRaw(requestParameters: UpdateMailConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestMailConfiguration>> {
        if (requestParameters.restMailConfiguration === null || requestParameters.restMailConfiguration === undefined) {
            throw new runtime.RequiredError('restMailConfiguration','Required parameter requestParameters.restMailConfiguration was null or undefined when calling updateMailConfiguration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/config/mailServer`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restMailConfiguration,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the mail server configuration.
     */
    async updateMailConfiguration(requestParameters: UpdateMailConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestMailConfiguration> {
        const response = await this.updateMailConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Bamboo quarantine settings.
     */
    async updateQuarantineSettingsRaw(requestParameters: UpdateQuarantineSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestQuarantineConfig>> {
        if (requestParameters.restQuarantineConfig === null || requestParameters.restQuarantineConfig === undefined) {
            throw new runtime.RequiredError('restQuarantineConfig','Required parameter requestParameters.restQuarantineConfig was null or undefined when calling updateQuarantineSettings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/config/quarantine`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restQuarantineConfig,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update Bamboo quarantine settings.
     */
    async updateQuarantineSettings(requestParameters: UpdateQuarantineSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestQuarantineConfig> {
        const response = await this.updateQuarantineSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update quick filter\'s basic configuration, e.g. name or position on list. This method does not allow to configure quick filter\'s rules.
     */
    async updateQuickFilterRaw(requestParameters: UpdateQuickFilterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestQuickFilter>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling updateQuickFilter.');
        }

        if (requestParameters.restQuickFilter === null || requestParameters.restQuickFilter === undefined) {
            throw new runtime.RequiredError('restQuickFilter','Required parameter requestParameters.restQuickFilter was null or undefined when calling updateQuickFilter.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/quickFilter/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restQuickFilter,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update quick filter\'s basic configuration, e.g. name or position on list. This method does not allow to configure quick filter\'s rules.
     */
    async updateQuickFilter(requestParameters: UpdateQuickFilterRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestQuickFilter> {
        const response = await this.updateQuickFilterRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update the remote agent configuration
     */
    async updateRemoteAgentConfigurationRaw(requestParameters: UpdateRemoteAgentConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestRemoteAgentConfiguration>> {
        if (requestParameters.restRemoteAgentConfiguration === null || requestParameters.restRemoteAgentConfiguration === undefined) {
            throw new runtime.RequiredError('restRemoteAgentConfiguration','Required parameter requestParameters.restRemoteAgentConfiguration was null or undefined when calling updateRemoteAgentConfiguration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/config/remoteAgentSupport`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restRemoteAgentConfiguration,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update the remote agent configuration
     */
    async updateRemoteAgentConfiguration(requestParameters: UpdateRemoteAgentConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestRemoteAgentConfiguration> {
        const response = await this.updateRemoteAgentConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update agent details
     */
    async updateRestAgentRaw(requestParameters: UpdateRestAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestAgent>> {
        if (requestParameters.agentId === null || requestParameters.agentId === undefined) {
            throw new runtime.RequiredError('agentId','Required parameter requestParameters.agentId was null or undefined when calling updateRestAgent.');
        }

        if (requestParameters.restAgent === null || requestParameters.restAgent === undefined) {
            throw new runtime.RequiredError('restAgent','Required parameter requestParameters.restAgent was null or undefined when calling updateRestAgent.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/config/agents/{agentId}`.replace(`{${"agentId"}}`, encodeURIComponent(String(requestParameters.agentId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restAgent,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update agent details
     */
    async updateRestAgent(requestParameters: UpdateRestAgentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestAgent> {
        const response = await this.updateRestAgentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update build concurrency settings. Partially update supported.
     */
    async updateRestBuildConcurrencyRaw(requestParameters: UpdateRestBuildConcurrencyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestBuildConcurrency>> {
        if (requestParameters.restBuildConcurrency === null || requestParameters.restBuildConcurrency === undefined) {
            throw new runtime.RequiredError('restBuildConcurrency','Required parameter requestParameters.restBuildConcurrency was null or undefined when calling updateRestBuildConcurrency.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/config/build/concurrency`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restBuildConcurrency,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update build concurrency settings. Partially update supported.
     */
    async updateRestBuildConcurrency(requestParameters: UpdateRestBuildConcurrencyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestBuildConcurrency> {
        const response = await this.updateRestBuildConcurrencyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update build monitoring settings. Partially update supported.
     */
    async updateRestBuildMonitoringRaw(requestParameters: UpdateRestBuildMonitoringRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BuildMonitoringLink>> {
        if (requestParameters.restBuildMonitoring === null || requestParameters.restBuildMonitoring === undefined) {
            throw new runtime.RequiredError('restBuildMonitoring','Required parameter requestParameters.restBuildMonitoring was null or undefined when calling updateRestBuildMonitoring.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/config/build/monitoring`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restBuildMonitoring,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update build monitoring settings. Partially update supported.
     */
    async updateRestBuildMonitoring(requestParameters: UpdateRestBuildMonitoringRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BuildMonitoringLink> {
        const response = await this.updateRestBuildMonitoringRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update elastic configuration.
     */
    async updateRestElasticConfigurationRaw(requestParameters: UpdateRestElasticConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestElasticConfiguration>> {
        if (requestParameters.restElasticConfiguration === null || requestParameters.restElasticConfiguration === undefined) {
            throw new runtime.RequiredError('restElasticConfiguration','Required parameter requestParameters.restElasticConfiguration was null or undefined when calling updateRestElasticConfiguration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/elastic/config`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restElasticConfiguration,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update elastic configuration.
     */
    async updateRestElasticConfiguration(requestParameters: UpdateRestElasticConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestElasticConfiguration> {
        const response = await this.updateRestElasticConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update security settings. Partial update supported.
     */
    async updateRestSecuritySettingsRaw(requestParameters: UpdateRestSecuritySettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SecuritySettingsLink>> {
        if (requestParameters.restSecuritySettings === null || requestParameters.restSecuritySettings === undefined) {
            throw new runtime.RequiredError('restSecuritySettings','Required parameter requestParameters.restSecuritySettings was null or undefined when calling updateRestSecuritySettings.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/security/settings`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restSecuritySettings,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update security settings. Partial update supported.
     */
    async updateRestSecuritySettings(requestParameters: UpdateRestSecuritySettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SecuritySettingsLink> {
        const response = await this.updateRestSecuritySettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update S3 Artifact Handler configuration.
     */
    async updateS3HandlerRaw(requestParameters: UpdateS3HandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestArtifactHandler>> {
        if (requestParameters.restArtifactHandler === null || requestParameters.restArtifactHandler === undefined) {
            throw new runtime.RequiredError('restArtifactHandler','Required parameter requestParameters.restArtifactHandler was null or undefined when calling updateS3Handler.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/artifactHandlers/s3`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restArtifactHandler,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update S3 Artifact Handler configuration.
     */
    async updateS3Handler(requestParameters: UpdateS3HandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestArtifactHandler> {
        const response = await this.updateS3HandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update SFTP Artifact Handler configuration.
     */
    async updateSftpHandlerRaw(requestParameters: UpdateSftpHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestArtifactHandler>> {
        if (requestParameters.simpleRestArtifactHandler === null || requestParameters.simpleRestArtifactHandler === undefined) {
            throw new runtime.RequiredError('simpleRestArtifactHandler','Required parameter requestParameters.simpleRestArtifactHandler was null or undefined when calling updateSftpHandler.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/artifactHandlers/sftp`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.simpleRestArtifactHandler,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update SFTP Artifact Handler configuration.
     */
    async updateSftpHandler(requestParameters: UpdateSftpHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestArtifactHandler> {
        const response = await this.updateSftpHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update ephemeral agent template.
     */
    async updateTemplateConfigurationRaw(requestParameters: UpdateTemplateConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestEphemeralAgentTemplate>> {
        if (requestParameters.configurationId === null || requestParameters.configurationId === undefined) {
            throw new runtime.RequiredError('configurationId','Required parameter requestParameters.configurationId was null or undefined when calling updateTemplateConfiguration.');
        }

        if (requestParameters.restEphemeralAgentTemplate === null || requestParameters.restEphemeralAgentTemplate === undefined) {
            throw new runtime.RequiredError('restEphemeralAgentTemplate','Required parameter requestParameters.restEphemeralAgentTemplate was null or undefined when calling updateTemplateConfiguration.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/latest/ephemeral/templateConfiguration/{configurationId}`.replace(`{${"configurationId"}}`, encodeURIComponent(String(requestParameters.configurationId))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restEphemeralAgentTemplate,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update ephemeral agent template.
     */
    async updateTemplateConfiguration(requestParameters: UpdateTemplateConfigurationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestEphemeralAgentTemplate> {
        const response = await this.updateTemplateConfigurationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update deployment version status.
     */
    async updateVersionStatusRaw(requestParameters: UpdateVersionStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RestDeploymentVersionStatus>> {
        if (requestParameters.deploymentVersionId === null || requestParameters.deploymentVersionId === undefined) {
            throw new runtime.RequiredError('deploymentVersionId','Required parameter requestParameters.deploymentVersionId was null or undefined when calling updateVersionStatus.');
        }

        if (requestParameters.newStatus === null || requestParameters.newStatus === undefined) {
            throw new runtime.RequiredError('newStatus','Required parameter requestParameters.newStatus was null or undefined when calling updateVersionStatus.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/latest/deploy/version/{deploymentVersionId}/status/{newStatus}`.replace(`{${"deploymentVersionId"}}`, encodeURIComponent(String(requestParameters.deploymentVersionId))).replace(`{${"newStatus"}}`, encodeURIComponent(String(requestParameters.newStatus))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Update deployment version status.
     */
    async updateVersionStatus(requestParameters: UpdateVersionStatusRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RestDeploymentVersionStatus> {
        const response = await this.updateVersionStatusRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Server side verification that the encrypted value of a global variable has changed.
     */
    async verifyGlobalVariableValueRaw(requestParameters: VerifyGlobalVariableValueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.restVerificationRequest === null || requestParameters.restVerificationRequest === undefined) {
            throw new runtime.RequiredError('restVerificationRequest','Required parameter requestParameters.restVerificationRequest was null or undefined when calling verifyGlobalVariableValue.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/admin/latest/globalVariables/verify`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.restVerificationRequest,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Server side verification that the encrypted value of a global variable has changed.
     */
    async verifyGlobalVariableValue(requestParameters: VerifyGlobalVariableValueRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.verifyGlobalVariableValueRaw(requestParameters, initOverrides);
    }

}

/**
 * @export
 */
export const ExportProjectSpecsFormatEnum = {
    Java: 'JAVA',
    Yaml: 'YAML'
} as const;
export type ExportProjectSpecsFormatEnum = typeof ExportProjectSpecsFormatEnum[keyof typeof ExportProjectSpecsFormatEnum];
/**
 * @export
 */
export const SearchSearchEntityEnum = {
    Project: 'PROJECT',
    Plan: 'PLAN',
    Deployment: 'DEPLOYMENT',
    PlanBranch: 'PLAN_BRANCH'
} as const;
export type SearchSearchEntityEnum = typeof SearchSearchEntityEnum[keyof typeof SearchSearchEntityEnum];
/**
 * @export
 */
export const SearchDeploymentsPermissionEnum = {
    Read: 'READ',
    Write: 'WRITE',
    Administration: 'ADMINISTRATION'
} as const;
export type SearchDeploymentsPermissionEnum = typeof SearchDeploymentsPermissionEnum[keyof typeof SearchDeploymentsPermissionEnum];
/**
 * @export
 */
export const SearchPlansPermissionEnum = {
    Read: 'READ',
    Write: 'WRITE',
    Build: 'BUILD',
    Clone: 'CLONE',
    ViewConfiguration: 'VIEW_CONFIGURATION',
    Administration: 'ADMINISTRATION'
} as const;
export type SearchPlansPermissionEnum = typeof SearchPlansPermissionEnum[keyof typeof SearchPlansPermissionEnum];
/**
 * @export
 */
export const SearchPlansTypeEnum = {
    Chain: 'CHAIN',
    Job: 'JOB',
    ChainBranch: 'CHAIN_BRANCH'
} as const;
export type SearchPlansTypeEnum = typeof SearchPlansTypeEnum[keyof typeof SearchPlansTypeEnum];
/**
 * @export
 */
export const SearchProjectsPermissionEnum = {
    Read: 'READ',
    Write: 'WRITE',
    Administration: 'ADMINISTRATION'
} as const;
export type SearchProjectsPermissionEnum = typeof SearchProjectsPermissionEnum[keyof typeof SearchProjectsPermissionEnum];
