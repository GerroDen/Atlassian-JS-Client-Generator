/* tslint:disable */
/* eslint-disable */
/**
 * The Confluence Cloud REST API
 * This document describes the REST API and resources provided by Confluence. The REST APIs are for developers who want to integrate Confluence into their application and for administrators who want to script interactions with the Confluence server.Confluence\'s REST APIs provide access to resources (data entities) via URI paths. To use a REST API, your application will make an HTTP request and parse the response. The response format is JSON. Your methods will be the standard HTTP methods like GET, PUT, POST and DELETE. Because the REST API is based on open standards, you can use any web development language to access the API.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Relation,
  RelationArray,
} from '../models';

export interface CreateRelationshipRequest {
    relationName: string;
    sourceType: CreateRelationshipSourceTypeEnum;
    sourceKey: string;
    targetType: CreateRelationshipTargetTypeEnum;
    targetKey: string;
    sourceStatus?: string;
    targetStatus?: string;
    sourceVersion?: number;
    targetVersion?: number;
}

export interface DeleteRelationshipRequest {
    relationName: string;
    sourceType: DeleteRelationshipSourceTypeEnum;
    sourceKey: string;
    targetType: DeleteRelationshipTargetTypeEnum;
    targetKey: string;
    sourceStatus?: string;
    targetStatus?: string;
    sourceVersion?: number;
    targetVersion?: number;
}

export interface FindSourcesForTargetRequest {
    relationName: string;
    sourceType: FindSourcesForTargetSourceTypeEnum;
    targetType: FindSourcesForTargetTargetTypeEnum;
    targetKey: string;
    sourceStatus?: string;
    targetStatus?: string;
    sourceVersion?: number;
    targetVersion?: number;
    expand?: Array<FindSourcesForTargetExpandEnum>;
    start?: number;
    limit?: number;
}

export interface FindTargetFromSourceRequest {
    relationName: string;
    sourceType: FindTargetFromSourceSourceTypeEnum;
    sourceKey: string;
    targetType: FindTargetFromSourceTargetTypeEnum;
    sourceStatus?: string;
    targetStatus?: string;
    sourceVersion?: number;
    targetVersion?: number;
    expand?: Array<FindTargetFromSourceExpandEnum>;
    start?: number;
    limit?: number;
}

export interface GetRelationshipRequest {
    relationName: string;
    sourceType: GetRelationshipSourceTypeEnum;
    sourceKey: string;
    targetType: GetRelationshipTargetTypeEnum;
    targetKey: string;
    sourceStatus?: string;
    targetStatus?: string;
    sourceVersion?: number;
    targetVersion?: number;
    expand?: Array<GetRelationshipExpandEnum>;
}

/**
 * 
 */
export class RelationApi extends runtime.BaseAPI {

    /**
     * Creates a relationship between two entities (user, space, content). The \'favourite\' relationship is supported by default, but you can use this method to create any type of relationship between two entities.  For example, the following method creates a \'sibling\' relationship between two pieces of content: `GET /wiki/rest/api/relation/sibling/from/content/123/to/content/456`  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to access the Confluence site (\'Can use\' global permission).
     * Create relationship
     */
    async createRelationshipRaw(requestParameters: CreateRelationshipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Relation>> {
        if (requestParameters.relationName === null || requestParameters.relationName === undefined) {
            throw new runtime.RequiredError('relationName','Required parameter requestParameters.relationName was null or undefined when calling createRelationship.');
        }

        if (requestParameters.sourceType === null || requestParameters.sourceType === undefined) {
            throw new runtime.RequiredError('sourceType','Required parameter requestParameters.sourceType was null or undefined when calling createRelationship.');
        }

        if (requestParameters.sourceKey === null || requestParameters.sourceKey === undefined) {
            throw new runtime.RequiredError('sourceKey','Required parameter requestParameters.sourceKey was null or undefined when calling createRelationship.');
        }

        if (requestParameters.targetType === null || requestParameters.targetType === undefined) {
            throw new runtime.RequiredError('targetType','Required parameter requestParameters.targetType was null or undefined when calling createRelationship.');
        }

        if (requestParameters.targetKey === null || requestParameters.targetKey === undefined) {
            throw new runtime.RequiredError('targetKey','Required parameter requestParameters.targetKey was null or undefined when calling createRelationship.');
        }

        const queryParameters: any = {};

        if (requestParameters.sourceStatus !== undefined) {
            queryParameters['sourceStatus'] = requestParameters.sourceStatus;
        }

        if (requestParameters.targetStatus !== undefined) {
            queryParameters['targetStatus'] = requestParameters.targetStatus;
        }

        if (requestParameters.sourceVersion !== undefined) {
            queryParameters['sourceVersion'] = requestParameters.sourceVersion;
        }

        if (requestParameters.targetVersion !== undefined) {
            queryParameters['targetVersion'] = requestParameters.targetVersion;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["write:confluence-content"]);
        }

        const response = await this.request({
            path: `/wiki/rest/api/relation/{relationName}/from/{sourceType}/{sourceKey}/to/{targetType}/{targetKey}`.replace(`{${"relationName"}}`, encodeURIComponent(String(requestParameters.relationName))).replace(`{${"sourceType"}}`, encodeURIComponent(String(requestParameters.sourceType))).replace(`{${"sourceKey"}}`, encodeURIComponent(String(requestParameters.sourceKey))).replace(`{${"targetType"}}`, encodeURIComponent(String(requestParameters.targetType))).replace(`{${"targetKey"}}`, encodeURIComponent(String(requestParameters.targetKey))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Creates a relationship between two entities (user, space, content). The \'favourite\' relationship is supported by default, but you can use this method to create any type of relationship between two entities.  For example, the following method creates a \'sibling\' relationship between two pieces of content: `GET /wiki/rest/api/relation/sibling/from/content/123/to/content/456`  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to access the Confluence site (\'Can use\' global permission).
     * Create relationship
     */
    async createRelationship(requestParameters: CreateRelationshipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Relation> {
        const response = await this.createRelationshipRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes a relationship between two entities (user, space, content).  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to access the Confluence site (\'Can use\' global permission). For favourite relationships, the current user can only delete their own favourite relationships. A space administrator can delete favourite relationships for any user.
     * Delete relationship
     */
    async deleteRelationshipRaw(requestParameters: DeleteRelationshipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.relationName === null || requestParameters.relationName === undefined) {
            throw new runtime.RequiredError('relationName','Required parameter requestParameters.relationName was null or undefined when calling deleteRelationship.');
        }

        if (requestParameters.sourceType === null || requestParameters.sourceType === undefined) {
            throw new runtime.RequiredError('sourceType','Required parameter requestParameters.sourceType was null or undefined when calling deleteRelationship.');
        }

        if (requestParameters.sourceKey === null || requestParameters.sourceKey === undefined) {
            throw new runtime.RequiredError('sourceKey','Required parameter requestParameters.sourceKey was null or undefined when calling deleteRelationship.');
        }

        if (requestParameters.targetType === null || requestParameters.targetType === undefined) {
            throw new runtime.RequiredError('targetType','Required parameter requestParameters.targetType was null or undefined when calling deleteRelationship.');
        }

        if (requestParameters.targetKey === null || requestParameters.targetKey === undefined) {
            throw new runtime.RequiredError('targetKey','Required parameter requestParameters.targetKey was null or undefined when calling deleteRelationship.');
        }

        const queryParameters: any = {};

        if (requestParameters.sourceStatus !== undefined) {
            queryParameters['sourceStatus'] = requestParameters.sourceStatus;
        }

        if (requestParameters.targetStatus !== undefined) {
            queryParameters['targetStatus'] = requestParameters.targetStatus;
        }

        if (requestParameters.sourceVersion !== undefined) {
            queryParameters['sourceVersion'] = requestParameters.sourceVersion;
        }

        if (requestParameters.targetVersion !== undefined) {
            queryParameters['targetVersion'] = requestParameters.targetVersion;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["write:confluence-content"]);
        }

        const response = await this.request({
            path: `/wiki/rest/api/relation/{relationName}/from/{sourceType}/{sourceKey}/to/{targetType}/{targetKey}`.replace(`{${"relationName"}}`, encodeURIComponent(String(requestParameters.relationName))).replace(`{${"sourceType"}}`, encodeURIComponent(String(requestParameters.sourceType))).replace(`{${"sourceKey"}}`, encodeURIComponent(String(requestParameters.sourceKey))).replace(`{${"targetType"}}`, encodeURIComponent(String(requestParameters.targetType))).replace(`{${"targetKey"}}`, encodeURIComponent(String(requestParameters.targetKey))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a relationship between two entities (user, space, content).  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to access the Confluence site (\'Can use\' global permission). For favourite relationships, the current user can only delete their own favourite relationships. A space administrator can delete favourite relationships for any user.
     * Delete relationship
     */
    async deleteRelationship(requestParameters: DeleteRelationshipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteRelationshipRaw(requestParameters, initOverrides);
    }

    /**
     * Returns all target entities that have a particular relationship to the source entity. Note, relationships are one way.  For example, the following method finds all users that have a \'collaborator\' relationship to a piece of content with an ID of \'1234\': `GET /wiki/rest/api/relation/collaborator/to/content/1234/from/user` Note, \'collaborator\' is an example custom relationship type.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view both the target entity and source entity.
     * Find source entities related to a target entity
     */
    async findSourcesForTargetRaw(requestParameters: FindSourcesForTargetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RelationArray>> {
        if (requestParameters.relationName === null || requestParameters.relationName === undefined) {
            throw new runtime.RequiredError('relationName','Required parameter requestParameters.relationName was null or undefined when calling findSourcesForTarget.');
        }

        if (requestParameters.sourceType === null || requestParameters.sourceType === undefined) {
            throw new runtime.RequiredError('sourceType','Required parameter requestParameters.sourceType was null or undefined when calling findSourcesForTarget.');
        }

        if (requestParameters.targetType === null || requestParameters.targetType === undefined) {
            throw new runtime.RequiredError('targetType','Required parameter requestParameters.targetType was null or undefined when calling findSourcesForTarget.');
        }

        if (requestParameters.targetKey === null || requestParameters.targetKey === undefined) {
            throw new runtime.RequiredError('targetKey','Required parameter requestParameters.targetKey was null or undefined when calling findSourcesForTarget.');
        }

        const queryParameters: any = {};

        if (requestParameters.sourceStatus !== undefined) {
            queryParameters['sourceStatus'] = requestParameters.sourceStatus;
        }

        if (requestParameters.targetStatus !== undefined) {
            queryParameters['targetStatus'] = requestParameters.targetStatus;
        }

        if (requestParameters.sourceVersion !== undefined) {
            queryParameters['sourceVersion'] = requestParameters.sourceVersion;
        }

        if (requestParameters.targetVersion !== undefined) {
            queryParameters['targetVersion'] = requestParameters.targetVersion;
        }

        if (requestParameters.expand) {
            queryParameters['expand'] = requestParameters.expand.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:confluence-content.summary"]);
        }

        const response = await this.request({
            path: `/wiki/rest/api/relation/{relationName}/to/{targetType}/{targetKey}/from/{sourceType}`.replace(`{${"relationName"}}`, encodeURIComponent(String(requestParameters.relationName))).replace(`{${"sourceType"}}`, encodeURIComponent(String(requestParameters.sourceType))).replace(`{${"targetType"}}`, encodeURIComponent(String(requestParameters.targetType))).replace(`{${"targetKey"}}`, encodeURIComponent(String(requestParameters.targetKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns all target entities that have a particular relationship to the source entity. Note, relationships are one way.  For example, the following method finds all users that have a \'collaborator\' relationship to a piece of content with an ID of \'1234\': `GET /wiki/rest/api/relation/collaborator/to/content/1234/from/user` Note, \'collaborator\' is an example custom relationship type.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view both the target entity and source entity.
     * Find source entities related to a target entity
     */
    async findSourcesForTarget(requestParameters: FindSourcesForTargetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RelationArray> {
        const response = await this.findSourcesForTargetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all target entities that have a particular relationship to the source entity. Note, relationships are one way.  For example, the following method finds all content that the current user has an \'ignore\' relationship with: `GET /wiki/rest/api/relation/ignore/from/user/current/to/content` Note, \'ignore\' is an example custom relationship type.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view both the target entity and source entity.
     * Find target entities related to a source entity
     */
    async findTargetFromSourceRaw(requestParameters: FindTargetFromSourceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RelationArray>> {
        if (requestParameters.relationName === null || requestParameters.relationName === undefined) {
            throw new runtime.RequiredError('relationName','Required parameter requestParameters.relationName was null or undefined when calling findTargetFromSource.');
        }

        if (requestParameters.sourceType === null || requestParameters.sourceType === undefined) {
            throw new runtime.RequiredError('sourceType','Required parameter requestParameters.sourceType was null or undefined when calling findTargetFromSource.');
        }

        if (requestParameters.sourceKey === null || requestParameters.sourceKey === undefined) {
            throw new runtime.RequiredError('sourceKey','Required parameter requestParameters.sourceKey was null or undefined when calling findTargetFromSource.');
        }

        if (requestParameters.targetType === null || requestParameters.targetType === undefined) {
            throw new runtime.RequiredError('targetType','Required parameter requestParameters.targetType was null or undefined when calling findTargetFromSource.');
        }

        const queryParameters: any = {};

        if (requestParameters.sourceStatus !== undefined) {
            queryParameters['sourceStatus'] = requestParameters.sourceStatus;
        }

        if (requestParameters.targetStatus !== undefined) {
            queryParameters['targetStatus'] = requestParameters.targetStatus;
        }

        if (requestParameters.sourceVersion !== undefined) {
            queryParameters['sourceVersion'] = requestParameters.sourceVersion;
        }

        if (requestParameters.targetVersion !== undefined) {
            queryParameters['targetVersion'] = requestParameters.targetVersion;
        }

        if (requestParameters.expand) {
            queryParameters['expand'] = requestParameters.expand.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.start !== undefined) {
            queryParameters['start'] = requestParameters.start;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:confluence-content.summary"]);
        }

        const response = await this.request({
            path: `/wiki/rest/api/relation/{relationName}/from/{sourceType}/{sourceKey}/to/{targetType}`.replace(`{${"relationName"}}`, encodeURIComponent(String(requestParameters.relationName))).replace(`{${"sourceType"}}`, encodeURIComponent(String(requestParameters.sourceType))).replace(`{${"sourceKey"}}`, encodeURIComponent(String(requestParameters.sourceKey))).replace(`{${"targetType"}}`, encodeURIComponent(String(requestParameters.targetType))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns all target entities that have a particular relationship to the source entity. Note, relationships are one way.  For example, the following method finds all content that the current user has an \'ignore\' relationship with: `GET /wiki/rest/api/relation/ignore/from/user/current/to/content` Note, \'ignore\' is an example custom relationship type.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view both the target entity and source entity.
     * Find target entities related to a source entity
     */
    async findTargetFromSource(requestParameters: FindTargetFromSourceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RelationArray> {
        const response = await this.findTargetFromSourceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Find whether a particular type of relationship exists from a source entity to a target entity. Note, relationships are one way.  For example, you can use this method to find whether the current user has selected a particular page as a favorite (i.e. \'save for later\'): `GET /wiki/rest/api/relation/favourite/from/user/current/to/content/123`  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view both the target entity and source entity.
     * Find relationship from source to target
     */
    async getRelationshipRaw(requestParameters: GetRelationshipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Relation>> {
        if (requestParameters.relationName === null || requestParameters.relationName === undefined) {
            throw new runtime.RequiredError('relationName','Required parameter requestParameters.relationName was null or undefined when calling getRelationship.');
        }

        if (requestParameters.sourceType === null || requestParameters.sourceType === undefined) {
            throw new runtime.RequiredError('sourceType','Required parameter requestParameters.sourceType was null or undefined when calling getRelationship.');
        }

        if (requestParameters.sourceKey === null || requestParameters.sourceKey === undefined) {
            throw new runtime.RequiredError('sourceKey','Required parameter requestParameters.sourceKey was null or undefined when calling getRelationship.');
        }

        if (requestParameters.targetType === null || requestParameters.targetType === undefined) {
            throw new runtime.RequiredError('targetType','Required parameter requestParameters.targetType was null or undefined when calling getRelationship.');
        }

        if (requestParameters.targetKey === null || requestParameters.targetKey === undefined) {
            throw new runtime.RequiredError('targetKey','Required parameter requestParameters.targetKey was null or undefined when calling getRelationship.');
        }

        const queryParameters: any = {};

        if (requestParameters.sourceStatus !== undefined) {
            queryParameters['sourceStatus'] = requestParameters.sourceStatus;
        }

        if (requestParameters.targetStatus !== undefined) {
            queryParameters['targetStatus'] = requestParameters.targetStatus;
        }

        if (requestParameters.sourceVersion !== undefined) {
            queryParameters['sourceVersion'] = requestParameters.sourceVersion;
        }

        if (requestParameters.targetVersion !== undefined) {
            queryParameters['targetVersion'] = requestParameters.targetVersion;
        }

        if (requestParameters.expand) {
            queryParameters['expand'] = requestParameters.expand.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:confluence-content.summary"]);
        }

        const response = await this.request({
            path: `/wiki/rest/api/relation/{relationName}/from/{sourceType}/{sourceKey}/to/{targetType}/{targetKey}`.replace(`{${"relationName"}}`, encodeURIComponent(String(requestParameters.relationName))).replace(`{${"sourceType"}}`, encodeURIComponent(String(requestParameters.sourceType))).replace(`{${"sourceKey"}}`, encodeURIComponent(String(requestParameters.sourceKey))).replace(`{${"targetType"}}`, encodeURIComponent(String(requestParameters.targetType))).replace(`{${"targetKey"}}`, encodeURIComponent(String(requestParameters.targetKey))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Find whether a particular type of relationship exists from a source entity to a target entity. Note, relationships are one way.  For example, you can use this method to find whether the current user has selected a particular page as a favorite (i.e. \'save for later\'): `GET /wiki/rest/api/relation/favourite/from/user/current/to/content/123`  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: Permission to view both the target entity and source entity.
     * Find relationship from source to target
     */
    async getRelationship(requestParameters: GetRelationshipRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Relation> {
        const response = await this.getRelationshipRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const CreateRelationshipSourceTypeEnum = {
    User: 'user',
    Content: 'content',
    Space: 'space'
} as const;
export type CreateRelationshipSourceTypeEnum = typeof CreateRelationshipSourceTypeEnum[keyof typeof CreateRelationshipSourceTypeEnum];
/**
 * @export
 */
export const CreateRelationshipTargetTypeEnum = {
    User: 'user',
    Content: 'content',
    Space: 'space'
} as const;
export type CreateRelationshipTargetTypeEnum = typeof CreateRelationshipTargetTypeEnum[keyof typeof CreateRelationshipTargetTypeEnum];
/**
 * @export
 */
export const DeleteRelationshipSourceTypeEnum = {
    User: 'user',
    Content: 'content',
    Space: 'space'
} as const;
export type DeleteRelationshipSourceTypeEnum = typeof DeleteRelationshipSourceTypeEnum[keyof typeof DeleteRelationshipSourceTypeEnum];
/**
 * @export
 */
export const DeleteRelationshipTargetTypeEnum = {
    User: 'user',
    Content: 'content',
    Space: 'space'
} as const;
export type DeleteRelationshipTargetTypeEnum = typeof DeleteRelationshipTargetTypeEnum[keyof typeof DeleteRelationshipTargetTypeEnum];
/**
 * @export
 */
export const FindSourcesForTargetSourceTypeEnum = {
    User: 'user',
    Content: 'content',
    Space: 'space'
} as const;
export type FindSourcesForTargetSourceTypeEnum = typeof FindSourcesForTargetSourceTypeEnum[keyof typeof FindSourcesForTargetSourceTypeEnum];
/**
 * @export
 */
export const FindSourcesForTargetTargetTypeEnum = {
    User: 'user',
    Content: 'content',
    Space: 'space'
} as const;
export type FindSourcesForTargetTargetTypeEnum = typeof FindSourcesForTargetTargetTypeEnum[keyof typeof FindSourcesForTargetTargetTypeEnum];
/**
 * @export
 */
export const FindSourcesForTargetExpandEnum = {
    RelationData: 'relationData',
    Source: 'source',
    Target: 'target'
} as const;
export type FindSourcesForTargetExpandEnum = typeof FindSourcesForTargetExpandEnum[keyof typeof FindSourcesForTargetExpandEnum];
/**
 * @export
 */
export const FindTargetFromSourceSourceTypeEnum = {
    User: 'user',
    Content: 'content',
    Space: 'space'
} as const;
export type FindTargetFromSourceSourceTypeEnum = typeof FindTargetFromSourceSourceTypeEnum[keyof typeof FindTargetFromSourceSourceTypeEnum];
/**
 * @export
 */
export const FindTargetFromSourceTargetTypeEnum = {
    User: 'user',
    Content: 'content',
    Space: 'space'
} as const;
export type FindTargetFromSourceTargetTypeEnum = typeof FindTargetFromSourceTargetTypeEnum[keyof typeof FindTargetFromSourceTargetTypeEnum];
/**
 * @export
 */
export const FindTargetFromSourceExpandEnum = {
    RelationData: 'relationData',
    Source: 'source',
    Target: 'target'
} as const;
export type FindTargetFromSourceExpandEnum = typeof FindTargetFromSourceExpandEnum[keyof typeof FindTargetFromSourceExpandEnum];
/**
 * @export
 */
export const GetRelationshipSourceTypeEnum = {
    User: 'user',
    Content: 'content',
    Space: 'space'
} as const;
export type GetRelationshipSourceTypeEnum = typeof GetRelationshipSourceTypeEnum[keyof typeof GetRelationshipSourceTypeEnum];
/**
 * @export
 */
export const GetRelationshipTargetTypeEnum = {
    User: 'user',
    Content: 'content',
    Space: 'space'
} as const;
export type GetRelationshipTargetTypeEnum = typeof GetRelationshipTargetTypeEnum[keyof typeof GetRelationshipTargetTypeEnum];
/**
 * @export
 */
export const GetRelationshipExpandEnum = {
    RelationData: 'relationData',
    Source: 'source',
    Target: 'target'
} as const;
export type GetRelationshipExpandEnum = typeof GetRelationshipExpandEnum[keyof typeof GetRelationshipExpandEnum];
