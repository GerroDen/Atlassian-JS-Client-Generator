/* tslint:disable */
/* eslint-disable */
/**
 * The Confluence Cloud REST API
 * This document describes the REST API and resources provided by Confluence. The REST APIs are for developers who want to integrate Confluence into their application and for administrators who want to script interactions with the Confluence server.Confluence\'s REST APIs provide access to resources (data entities) via URI paths. To use a REST API, your application will make an HTTP request and parse the response. The response format is JSON. Your methods will be the standard HTTP methods like GET, PUT, POST and DELETE. Because the REST API is based on open standards, you can use any web development language to access the API.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Content,
  ContentArray,
  ContentChildren,
  CopyPageHierarchyRequest,
  CopyPageRequest,
  LongTask,
  MovePage200Response,
} from '../models/index';

export interface CopyPageOperationRequest {
    id: string;
    request: CopyPageRequest;
    expand?: Array<string>;
}

export interface CopyPageHierarchyOperationRequest {
    id: string;
    request: CopyPageHierarchyRequest;
}

export interface GetContentChildrenRequest {
    id: string;
    expand?: Array<string>;
    parentVersion?: number;
}

export interface GetContentChildrenByTypeRequest {
    id: string;
    type: string;
    expand?: Array<string>;
    parentVersion?: number;
    start?: number;
    limit?: number;
}

export interface GetContentDescendantsRequest {
    id: string;
    expand?: Array<GetContentDescendantsExpandEnum>;
}

export interface GetDescendantsOfTypeRequest {
    id: string;
    type: GetDescendantsOfTypeTypeEnum;
    depth?: GetDescendantsOfTypeDepthEnum;
    expand?: Array<string>;
    start?: number;
    limit?: number;
}

export interface MovePageRequest {
    pageId: string;
    position: MovePagePositionEnum;
    targetId: string;
}

/**
 * 
 */
export class ContentChildrenAndDescendantsApi extends runtime.BaseAPI {

    /**
     * Copies a single page and its associated properties, permissions, attachments, and custom contents.  The `id` path parameter refers to the content ID of the page to copy. The target of the page to be copied  is defined using the `destination` in the request body and can be one of the following types.    - `space`: page will be copied to the specified space as a root page on the space   - `parent_page`: page will be copied as a child of the specified parent page   - `existing_page`: page will be copied and replace the specified page  By default, the following objects are expanded: `space`, `history`, `version`.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \'Add\' permission for the space that the content will be copied in and permission to update the content if copying to an `existing_page`.
     * Copy single page
     */
    async copyPageRaw(requestParameters: CopyPageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Content>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling copyPage().'
            );
        }

        if (requestParameters['request'] == null) {
            throw new runtime.RequiredError(
                'request',
                'Required parameter "request" was null or undefined when calling copyPage().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['expand'] != null) {
            queryParameters['expand'] = requestParameters['expand']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["write:confluence-content"]);
        }

        const response = await this.request({
            path: `/wiki/rest/api/content/{id}/copy`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['request'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Copies a single page and its associated properties, permissions, attachments, and custom contents.  The `id` path parameter refers to the content ID of the page to copy. The target of the page to be copied  is defined using the `destination` in the request body and can be one of the following types.    - `space`: page will be copied to the specified space as a root page on the space   - `parent_page`: page will be copied as a child of the specified parent page   - `existing_page`: page will be copied and replace the specified page  By default, the following objects are expanded: `space`, `history`, `version`.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \'Add\' permission for the space that the content will be copied in and permission to update the content if copying to an `existing_page`.
     * Copy single page
     */
    async copyPage(requestParameters: CopyPageOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Content> {
        const response = await this.copyPageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Copy page hierarchy allows the copying of an entire hierarchy of pages and their associated properties, permissions and attachments.  The id path parameter refers to the content id of the page to copy, and the new parent of this copied page is defined using the destinationPageId in the request body.  The titleOptions object defines the rules of renaming page titles during the copy;  for example, search and replace can be used in conjunction to rewrite the copied page titles.   Response example:  <pre><code>  {       \"id\" : \"1180606\",       \"links\" : {            \"status\" : \"/rest/api/longtask/1180606\"       }  }  </code></pre>  Use the /longtask/<taskId> REST API to get the copy task status.
     * Copy page hierarchy
     */
    async copyPageHierarchyRaw(requestParameters: CopyPageHierarchyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LongTask>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling copyPageHierarchy().'
            );
        }

        if (requestParameters['request'] == null) {
            throw new runtime.RequiredError(
                'request',
                'Required parameter "request" was null or undefined when calling copyPageHierarchy().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["write:confluence-content"]);
        }

        const response = await this.request({
            path: `/wiki/rest/api/content/{id}/pagehierarchy/copy`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['request'],
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Copy page hierarchy allows the copying of an entire hierarchy of pages and their associated properties, permissions and attachments.  The id path parameter refers to the content id of the page to copy, and the new parent of this copied page is defined using the destinationPageId in the request body.  The titleOptions object defines the rules of renaming page titles during the copy;  for example, search and replace can be used in conjunction to rewrite the copied page titles.   Response example:  <pre><code>  {       \"id\" : \"1180606\",       \"links\" : {            \"status\" : \"/rest/api/longtask/1180606\"       }  }  </code></pre>  Use the /longtask/<taskId> REST API to get the copy task status.
     * Copy page hierarchy
     */
    async copyPageHierarchy(requestParameters: CopyPageHierarchyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LongTask> {
        const response = await this.copyPageHierarchyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deprecated, use [Confluence\'s v2 API](https://developer.atlassian.com/cloud/confluence/rest/v2/intro/).  Returns a map of the direct children of a piece of content. A piece of content has different types of child content, depending on its type. These are the default parent-child content type relationships:  - `page`: child content is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `whiteboard`: child content is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `database`: child content is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `embed`: child content is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `folder`: child content is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `blogpost`: child content is `comment`, `attachment` - `attachment`: child content is `comment` - `comment`: child content is `attachment`  Apps can override these default relationships. Apps can also introduce new content types that create new parent-child content relationships.  Note, the map will always include all child content types that are valid for the content. However, if the content has no instances of a child content type, the map will contain an empty array for that child content type.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \'View\' permission for the space, and permission to view the content if it is a page.
     * Get content children
     * @deprecated
     */
    async getContentChildrenRaw(requestParameters: GetContentChildrenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContentChildren>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getContentChildren().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['expand'] != null) {
            queryParameters['expand'] = requestParameters['expand']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['parentVersion'] != null) {
            queryParameters['parentVersion'] = requestParameters['parentVersion'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:confluence-content.summary"]);
        }

        const response = await this.request({
            path: `/wiki/rest/api/content/{id}/child`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deprecated, use [Confluence\'s v2 API](https://developer.atlassian.com/cloud/confluence/rest/v2/intro/).  Returns a map of the direct children of a piece of content. A piece of content has different types of child content, depending on its type. These are the default parent-child content type relationships:  - `page`: child content is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `whiteboard`: child content is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `database`: child content is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `embed`: child content is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `folder`: child content is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `blogpost`: child content is `comment`, `attachment` - `attachment`: child content is `comment` - `comment`: child content is `attachment`  Apps can override these default relationships. Apps can also introduce new content types that create new parent-child content relationships.  Note, the map will always include all child content types that are valid for the content. However, if the content has no instances of a child content type, the map will contain an empty array for that child content type.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \'View\' permission for the space, and permission to view the content if it is a page.
     * Get content children
     * @deprecated
     */
    async getContentChildren(requestParameters: GetContentChildrenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContentChildren> {
        const response = await this.getContentChildrenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deprecated, use [Confluence\'s v2 API](https://developer.atlassian.com/cloud/confluence/rest/v2/intro/).  Returns all children of a given type, for a piece of content. A piece of content has different types of child content, depending on its type:  - `page`: child content is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `whiteboard`: child content is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `database`: child content is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `embed`: child content is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `folder`: child content is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `blogpost`: child content is `comment`, `attachment` - `attachment`: child content is `comment` - `comment`: child content is `attachment`  Custom content types that are provided by apps can also be returned.  Note, this method only returns direct children. To return children at all levels, use [Get descendants by type](#api-content-id-descendant-type-get).  Starting on Dec 10, 2024, if the expand query parameter is used with the `body.export_view` and/or `body.styled_view` properties, then the query limit parameter will be restricted to a maximum value of 25.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \'View\' permission for the space, and permission to view the content if it is a page.
     * Get content children by type
     * @deprecated
     */
    async getContentChildrenByTypeRaw(requestParameters: GetContentChildrenByTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContentArray>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getContentChildrenByType().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling getContentChildrenByType().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['expand'] != null) {
            queryParameters['expand'] = requestParameters['expand']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['parentVersion'] != null) {
            queryParameters['parentVersion'] = requestParameters['parentVersion'];
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:confluence-content.summary"]);
        }

        const response = await this.request({
            path: `/wiki/rest/api/content/{id}/child/{type}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Deprecated, use [Confluence\'s v2 API](https://developer.atlassian.com/cloud/confluence/rest/v2/intro/).  Returns all children of a given type, for a piece of content. A piece of content has different types of child content, depending on its type:  - `page`: child content is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `whiteboard`: child content is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `database`: child content is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `embed`: child content is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `folder`: child content is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `blogpost`: child content is `comment`, `attachment` - `attachment`: child content is `comment` - `comment`: child content is `attachment`  Custom content types that are provided by apps can also be returned.  Note, this method only returns direct children. To return children at all levels, use [Get descendants by type](#api-content-id-descendant-type-get).  Starting on Dec 10, 2024, if the expand query parameter is used with the `body.export_view` and/or `body.styled_view` properties, then the query limit parameter will be restricted to a maximum value of 25.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \'View\' permission for the space, and permission to view the content if it is a page.
     * Get content children by type
     * @deprecated
     */
    async getContentChildrenByType(requestParameters: GetContentChildrenByTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContentArray> {
        const response = await this.getContentChildrenByTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a map of the descendants of a piece of content. This is similar to [Get content children](#api-content-id-child-get), except that this method returns child pages at all levels, rather than just the direct child pages.  A piece of content has different types of descendants, depending on its type:  - `page`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `whiteboard`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `database`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `embed`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `folder`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `blogpost`: descendant is `comment`, `attachment` - `attachment`: descendant is `comment` - `comment`: descendant is `attachment`  The map will always include all descendant types that are valid for the content. However, if the content has no instances of a descendant type, the map will contain an empty array for that descendant type.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \'View\' permission for the space, and permission to view the content if it is a page.
     * Get content descendants
     */
    async getContentDescendantsRaw(requestParameters: GetContentDescendantsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContentChildren>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getContentDescendants().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['expand'] != null) {
            queryParameters['expand'] = requestParameters['expand']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:confluence-content.summary"]);
        }

        const response = await this.request({
            path: `/wiki/rest/api/content/{id}/descendant`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns a map of the descendants of a piece of content. This is similar to [Get content children](#api-content-id-child-get), except that this method returns child pages at all levels, rather than just the direct child pages.  A piece of content has different types of descendants, depending on its type:  - `page`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `whiteboard`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `database`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `embed`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `folder`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `blogpost`: descendant is `comment`, `attachment` - `attachment`: descendant is `comment` - `comment`: descendant is `attachment`  The map will always include all descendant types that are valid for the content. However, if the content has no instances of a descendant type, the map will contain an empty array for that descendant type.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \'View\' permission for the space, and permission to view the content if it is a page.
     * Get content descendants
     */
    async getContentDescendants(requestParameters: GetContentDescendantsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContentChildren> {
        const response = await this.getContentDescendantsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns all descendants of a given type, for a piece of content. This is similar to [Get content children by type](#api-content-id-child-type-get), except that this method returns child pages at all levels, rather than just the direct child pages.  A piece of content has different types of descendants, depending on its type:  - `page`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `whiteboard`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `database`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `embed`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `folder`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `blogpost`: descendant is `comment`, `attachment` - `attachment`: descendant is `comment` - `comment`: descendant is `attachment`  Custom content types that are provided by apps can also be returned.  Starting on Dec 10, 2024, if the expand query parameter is used with the `body.export_view` and/or `body.styled_view` properties, then the query limit parameter will be restricted to a maximum value of 25.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \'View\' permission for the space, and permission to view the content if it is a page.
     * Get content descendants by type
     */
    async getDescendantsOfTypeRaw(requestParameters: GetDescendantsOfTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ContentArray>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getDescendantsOfType().'
            );
        }

        if (requestParameters['type'] == null) {
            throw new runtime.RequiredError(
                'type',
                'Required parameter "type" was null or undefined when calling getDescendantsOfType().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['depth'] != null) {
            queryParameters['depth'] = requestParameters['depth'];
        }

        if (requestParameters['expand'] != null) {
            queryParameters['expand'] = requestParameters['expand']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['start'] != null) {
            queryParameters['start'] = requestParameters['start'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["read:confluence-content.summary"]);
        }

        const response = await this.request({
            path: `/wiki/rest/api/content/{id}/descendant/{type}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))).replace(`{${"type"}}`, encodeURIComponent(String(requestParameters['type']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns all descendants of a given type, for a piece of content. This is similar to [Get content children by type](#api-content-id-child-type-get), except that this method returns child pages at all levels, rather than just the direct child pages.  A piece of content has different types of descendants, depending on its type:  - `page`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `whiteboard`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `database`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `embed`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `folder`: descendant is `page`, `whiteboard`, `database`, `embed`, `folder`, `comment`, `attachment` - `blogpost`: descendant is `comment`, `attachment` - `attachment`: descendant is `comment` - `comment`: descendant is `attachment`  Custom content types that are provided by apps can also be returned.  Starting on Dec 10, 2024, if the expand query parameter is used with the `body.export_view` and/or `body.styled_view` properties, then the query limit parameter will be restricted to a maximum value of 25.  **[Permissions](https://confluence.atlassian.com/x/_AozKw) required**: \'View\' permission for the space, and permission to view the content if it is a page.
     * Get content descendants by type
     */
    async getDescendantsOfType(requestParameters: GetDescendantsOfTypeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ContentArray> {
        const response = await this.getDescendantsOfTypeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Move a page to a new location relative to a target page:  * `before` - move the page under the same parent as the target, before the target in the list of children * `after` - move the page under the same parent as the target, after the target in the list of children * `append` - move the page to be a child of the target  Caution: This API can move pages to the top level of a space. Top-level pages are difficult to find in the UI because they do not show up in the page tree display. To avoid this, never use `before` or `after` positions when the `targetId` is a top-level page.
     * Move a page to a new location relative to a target page
     */
    async movePageRaw(requestParameters: MovePageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MovePage200Response>> {
        if (requestParameters['pageId'] == null) {
            throw new runtime.RequiredError(
                'pageId',
                'Required parameter "pageId" was null or undefined when calling movePage().'
            );
        }

        if (requestParameters['position'] == null) {
            throw new runtime.RequiredError(
                'position',
                'Required parameter "position" was null or undefined when calling movePage().'
            );
        }

        if (requestParameters['targetId'] == null) {
            throw new runtime.RequiredError(
                'targetId',
                'Required parameter "targetId" was null or undefined when calling movePage().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oAuthDefinitions", ["write:confluence-content"]);
        }

        const response = await this.request({
            path: `/wiki/rest/api/content/{pageId}/move/{position}/{targetId}`.replace(`{${"pageId"}}`, encodeURIComponent(String(requestParameters['pageId']))).replace(`{${"position"}}`, encodeURIComponent(String(requestParameters['position']))).replace(`{${"targetId"}}`, encodeURIComponent(String(requestParameters['targetId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Move a page to a new location relative to a target page:  * `before` - move the page under the same parent as the target, before the target in the list of children * `after` - move the page under the same parent as the target, after the target in the list of children * `append` - move the page to be a child of the target  Caution: This API can move pages to the top level of a space. Top-level pages are difficult to find in the UI because they do not show up in the page tree display. To avoid this, never use `before` or `after` positions when the `targetId` is a top-level page.
     * Move a page to a new location relative to a target page
     */
    async movePage(requestParameters: MovePageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MovePage200Response> {
        const response = await this.movePageRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetContentDescendantsExpandEnum = {
    Attachment: 'attachment',
    Comment: 'comment',
    Page: 'page'
} as const;
export type GetContentDescendantsExpandEnum = typeof GetContentDescendantsExpandEnum[keyof typeof GetContentDescendantsExpandEnum];
/**
 * @export
 */
export const GetDescendantsOfTypeTypeEnum = {
    Page: 'page',
    Comment: 'comment',
    Attachment: 'attachment'
} as const;
export type GetDescendantsOfTypeTypeEnum = typeof GetDescendantsOfTypeTypeEnum[keyof typeof GetDescendantsOfTypeTypeEnum];
/**
 * @export
 */
export const GetDescendantsOfTypeDepthEnum = {
    All: 'all',
    Root: 'root',
    AnyPositiveIntegerArgumentInTheRangeOf1And100: '<any positive integer argument in the range of 1 and 100>'
} as const;
export type GetDescendantsOfTypeDepthEnum = typeof GetDescendantsOfTypeDepthEnum[keyof typeof GetDescendantsOfTypeDepthEnum];
/**
 * @export
 */
export const MovePagePositionEnum = {
    Before: 'before',
    After: 'after',
    Append: 'append'
} as const;
export type MovePagePositionEnum = typeof MovePagePositionEnum[keyof typeof MovePagePositionEnum];
