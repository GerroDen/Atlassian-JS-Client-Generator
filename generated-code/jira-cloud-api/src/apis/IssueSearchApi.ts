/* tslint:disable */
/* eslint-disable */
/**
 * The Jira Cloud platform REST API
 * Jira Cloud platform REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0-SNAPSHOT
 * Contact: ecosystem@atlassian.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  IssueMatches,
  IssuePickerSuggestions,
  IssuesAndJQLQueries,
  SearchRequestBean,
  SearchResults,
} from '../models';

export interface GetIssuePickerResourceRequest {
    query?: string;
    currentJQL?: string;
    currentIssueKey?: string;
    currentProjectId?: string;
    showSubTasks?: boolean;
    showSubTaskParent?: boolean;
}

export interface MatchIssuesRequest {
    issuesAndJQLQueries: IssuesAndJQLQueries;
}

export interface SearchForIssuesUsingJqlRequest {
    jql?: string;
    startAt?: number;
    maxResults?: number;
    validateQuery?: SearchForIssuesUsingJqlValidateQueryEnum;
    fields?: Array<string>;
    expand?: string;
    properties?: Array<string>;
    fieldsByKeys?: boolean;
}

export interface SearchForIssuesUsingJqlPostRequest {
    searchRequestBean: SearchRequestBean;
}

/**
 * 
 */
export class IssueSearchApi extends runtime.BaseAPI {

    /**
     * Returns lists of issues matching a query string. Use this resource to provide auto-completion suggestions when the user is looking for an issue using a word or string.  This operation returns two lists:   *  `History Search` which includes issues from the user\'s history of created, edited, or viewed issues that contain the string in the `query` parameter.  *  `Current Search` which includes issues that match the JQL expression in `currentJQL` and contain the string in the `query` parameter.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** None.
     * Get issue picker suggestions
     */
    async getIssuePickerResourceRaw(requestParameters: GetIssuePickerResourceRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IssuePickerSuggestions>> {
        const queryParameters: any = {};

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.currentJQL !== undefined) {
            queryParameters['currentJQL'] = requestParameters.currentJQL;
        }

        if (requestParameters.currentIssueKey !== undefined) {
            queryParameters['currentIssueKey'] = requestParameters.currentIssueKey;
        }

        if (requestParameters.currentProjectId !== undefined) {
            queryParameters['currentProjectId'] = requestParameters.currentProjectId;
        }

        if (requestParameters.showSubTasks !== undefined) {
            queryParameters['showSubTasks'] = requestParameters.showSubTasks;
        }

        if (requestParameters.showSubTaskParent !== undefined) {
            queryParameters['showSubTaskParent'] = requestParameters.showSubTaskParent;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["read:jira-work"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/issue/picker`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Returns lists of issues matching a query string. Use this resource to provide auto-completion suggestions when the user is looking for an issue using a word or string.  This operation returns two lists:   *  `History Search` which includes issues from the user\'s history of created, edited, or viewed issues that contain the string in the `query` parameter.  *  `Current Search` which includes issues that match the JQL expression in `currentJQL` and contain the string in the `query` parameter.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** None.
     * Get issue picker suggestions
     */
    async getIssuePickerResource(requestParameters: GetIssuePickerResourceRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IssuePickerSuggestions> {
        const response = await this.getIssuePickerResourceRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Checks whether one or more issues would be returned by one or more JQL queries.  **[Permissions](#permissions) required:** None, however, issues are only matched against JQL queries where the user has:   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
     * Check issues against JQL
     */
    async matchIssuesRaw(requestParameters: MatchIssuesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IssueMatches>> {
        if (requestParameters.issuesAndJQLQueries === null || requestParameters.issuesAndJQLQueries === undefined) {
            throw new runtime.RequiredError('issuesAndJQLQueries','Required parameter requestParameters.issuesAndJQLQueries was null or undefined when calling matchIssues.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["read:jira-work"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/jql/match`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.issuesAndJQLQueries,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Checks whether one or more issues would be returned by one or more JQL queries.  **[Permissions](#permissions) required:** None, however, issues are only matched against JQL queries where the user has:   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
     * Check issues against JQL
     */
    async matchIssues(requestParameters: MatchIssuesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IssueMatches> {
        const response = await this.matchIssuesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Searches for issues using [JQL](https://confluence.atlassian.com/x/egORLQ).  If the JQL query expression is too large to be encoded as a query parameter, use the [POST](#api-rest-api-3-search-post) version of this resource.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** Issues are included in the response where the user has:   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
     * Search for issues using JQL (GET)
     */
    async searchForIssuesUsingJqlRaw(requestParameters: SearchForIssuesUsingJqlRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchResults>> {
        const queryParameters: any = {};

        if (requestParameters.jql !== undefined) {
            queryParameters['jql'] = requestParameters.jql;
        }

        if (requestParameters.startAt !== undefined) {
            queryParameters['startAt'] = requestParameters.startAt;
        }

        if (requestParameters.maxResults !== undefined) {
            queryParameters['maxResults'] = requestParameters.maxResults;
        }

        if (requestParameters.validateQuery !== undefined) {
            queryParameters['validateQuery'] = requestParameters.validateQuery;
        }

        if (requestParameters.fields) {
            queryParameters['fields'] = requestParameters.fields;
        }

        if (requestParameters.expand !== undefined) {
            queryParameters['expand'] = requestParameters.expand;
        }

        if (requestParameters.properties) {
            queryParameters['properties'] = requestParameters.properties;
        }

        if (requestParameters.fieldsByKeys !== undefined) {
            queryParameters['fieldsByKeys'] = requestParameters.fieldsByKeys;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["read:jira-work"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Searches for issues using [JQL](https://confluence.atlassian.com/x/egORLQ).  If the JQL query expression is too large to be encoded as a query parameter, use the [POST](#api-rest-api-3-search-post) version of this resource.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** Issues are included in the response where the user has:   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
     * Search for issues using JQL (GET)
     */
    async searchForIssuesUsingJql(requestParameters: SearchForIssuesUsingJqlRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchResults> {
        const response = await this.searchForIssuesUsingJqlRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Searches for issues using [JQL](https://confluence.atlassian.com/x/egORLQ).  There is a [GET](#api-rest-api-3-search-get) version of this resource that can be used for smaller JQL query expressions.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** Issues are included in the response where the user has:   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
     * Search for issues using JQL (POST)
     */
    async searchForIssuesUsingJqlPostRaw(requestParameters: SearchForIssuesUsingJqlPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchResults>> {
        if (requestParameters.searchRequestBean === null || requestParameters.searchRequestBean === undefined) {
            throw new runtime.RequiredError('searchRequestBean','Required parameter requestParameters.searchRequestBean was null or undefined when calling searchForIssuesUsingJqlPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("OAuth2", ["read:jira-work"]);
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/rest/api/3/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.searchRequestBean,
        }, initOverrides);

        return new runtime.JSONApiResponse(response);
    }

    /**
     * Searches for issues using [JQL](https://confluence.atlassian.com/x/egORLQ).  There is a [GET](#api-rest-api-3-search-get) version of this resource that can be used for smaller JQL query expressions.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** Issues are included in the response where the user has:   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
     * Search for issues using JQL (POST)
     */
    async searchForIssuesUsingJqlPost(requestParameters: SearchForIssuesUsingJqlPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchResults> {
        const response = await this.searchForIssuesUsingJqlPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const SearchForIssuesUsingJqlValidateQueryEnum = {
    Strict: 'strict',
    Warn: 'warn',
    None: 'none',
    True: 'true',
    False: 'false'
} as const;
export type SearchForIssuesUsingJqlValidateQueryEnum = typeof SearchForIssuesUsingJqlValidateQueryEnum[keyof typeof SearchForIssuesUsingJqlValidateQueryEnum];
